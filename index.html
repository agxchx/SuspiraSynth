<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SUSPIRA - Playground de Síntesis</title>
  <link rel="icon" type="image/png" href="1.png">
  <script src="soundtouch-compiled.js"></script>
  <style>
    :root {
      --primary-bg-color: #303030;
      --secondary-bg-color: #222;
      --control-panel-bg: rgba(255, 255, 255, 0.85);
      --casilla-bg-color: #333;
      --text-color: #fff;
      --control-text-color: #000;
      --button-bg-color: #505050;
      --button-text-color: #fff;
      --border-color: #ccc;
      --highlight-color: #f0f;
      --loop-selection-bg: rgba(255, 255, 0, 0.3);
      --sample-selection-bg: rgba(0, 150, 255, 0.3);
      --font-main: 'Avenir', Arial, sans-serif;
      --switch-bg-off: #777;
      --switch-thumb-off: #ccc;
    }

    html {
      font-size: clamp(12px, 1.1vw, 16px);
    }

    *, *::before, *::after { box-sizing: border-box; }

    body {
      font-family: var(--font-main);
      font-size: 0.875rem;
      margin: 0;
      padding: 10px;
      background-color: var(--primary-bg-color);
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      min-height: calc(100vh - 20px);
      overflow-x: hidden;
      overflow-y: auto;
    }
    
    body.easy-mode-active {
        overflow: hidden;
        padding: 0;
    }

    #loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background-color: black;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        transition: opacity 0.5s ease;
        overflow: hidden;
    }
    #loading-overlay video {
        position: absolute;
        top: 50%;
        left: 50%;
        min-width: 100%;
        min-height: 100%;
        width: auto;
        height: auto;
        transform: translate(-50%, -50%) scale(1.5);
        object-fit: cover;
        z-index: 1;
        opacity: 0.35; /* CAMBIO: Opacidad reducida y consistente */
        transition: opacity 0.5s ease;
    }
    #loading-text {
        color: rgba(255, 255, 255, 0.8);
        font-size: 1.5rem;
        z-index: 3;
        animation: pulse 1.8s infinite ease-in-out;
    }
    @keyframes pulse {
        0% { opacity: 0.4; }
        50% { opacity: 1; }
        100% { opacity: 0.4; }
    }
    #loading-buttons-container {
        display: none;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        z-index: 2;
        position: relative;
    }
     #bottom-buttons-row {
    width: 100%;
    display: flex;
    justify-content: space-between;
}
    #loading-buttons-container a,
    #loading-buttons-container button {
        background-color: transparent;
        border: none;
        color: rgba(255, 255, 255, 0.7);
        font-size: 1.2rem;
        cursor: pointer;
        transition: color 0.3s ease;
        text-decoration: none;
        padding: 0 5px; /* Add some padding for touch targets */
    }
    #loading-buttons-container a:hover,
    #loading-buttons-container button:hover {
        color: white;
    }


    /* --- ESTILOS PARA EL NUEVO MODO FÁCIL --- */
    body.easy-mode-active .main-container,
    body.easy-mode-active #loopSection {
        display: none;
    }

    body.easy-mode-active #reverb-eq-visualizer-casilla {
        display: flex;
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 2000;
        padding: 0;
        background-color: var(--primary-bg-color);
        border: none;
        border-radius: 0;
    }

    body.easy-mode-active #reverb-eq-visualizer-casilla > *:not(#spectrumCanvas):not(.loader-overlay):not(#easyModeExitBtn):not(#easyModeSourceControls):not(#source-controls-casilla):not(#easyModeTopControls):not(#easyModeBottomControls):not(#easyModeFadersContainer) {
        display: none;
    }
    
    #source-controls-casilla {
      transition: all 0.3s ease-in-out;
    }
    body.easy-mode-active #source-controls-casilla {
        display: none;
    }
    body.easy-mode-active #source-controls-casilla.floating {
        display: flex !important;
        position: absolute;
        bottom: 70px;
        left: 20px;
        width: 280px;
        z-index: 2200;
        background-color: rgba(34, 34, 34, 0.85);
        backdrop-filter: blur(5px);
        border: 1px solid #666;
    }

    body.easy-mode-active #reverb-eq-visualizer-casilla #spectrumCanvas {
        width: 100%;
        height: 100%;
        min-height: 0;
        aspect-ratio: unset;
    }
    
    #easyModeSourceControls {
        display: none;
        position: absolute;
        bottom: 20px;
        left: 20px;
        z-index: 2100;
        align-items: center;
        gap: 2px;
        opacity: 0;
        transition: opacity 0.25s ease;
    }

    body.easy-mode-active #easyModeSourceControls {
        display: flex;
    }
    
    #easyModeTopControls, #easyModeBottomControls {
        display: none;
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        z-index: 2100;
        opacity: 0;
        transition: opacity 0.25s ease;
        display: flex;
        gap: 10px;
        align-items: center;
    }
    #easyModeTopControls { top: 20px; }
    #easyModeBottomControls { bottom: 20px; }

    body.easy-mode-active:hover #easyModeSourceControls,
    body.easy-mode-active:hover #easyModeExitBtn,
    body.easy-mode-active:hover #easyModeTopControls,
    body.easy-mode-active:hover #easyModeBottomControls,
    body.easy-mode-active:hover #easyModeFadersContainer {
        opacity: 0.6;
    }
    body.easy-mode-active #easyModeSourceControls:hover,
    body.easy-mode-active #easyModeExitBtn:hover,
    body.easy-mode-active #easyModeTopControls:hover,
    body.easy-mode-active #easyModeBottomControls:hover,
    body.easy-mode-active #easyModeFadersContainer:hover {
        opacity: 1;
    }
    
    .easy-mode-btn-round {
        background-color: rgba(128, 128, 128, 0.7);
        color: white;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1rem;
        width: 38px;
        height: 38px;
    }
    .easy-mode-btn-round.main-rec {
        width: 44px;
        height: 44px;
        font-size: 1.5rem;
        color: #ff4d4d;
    }
     .easy-mode-btn-round.main-rec.is-recording {
        background-color: #ff4d4d;
        color: white;
        animation: blink-red 1s infinite;
    }

    #easyModeSourceControls .control-group {
        display: flex;
        background-color: rgba(128, 128, 128, 0.7);
        border-radius: 22px;
        padding: 4px;
        gap: 4px;
    }

    #easyModeSourceControls button,
    #easyModeSourceControls select {
        background-color: transparent;
        color: white;
        border: none;
        cursor: pointer;
        height: 36px;
        font-size: 0.9rem;
        padding: 0 12px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    #easyModeAudioFileBtn { border-radius: 18px; }
    #easyModeMicSelect {
        border-radius: 18px;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        min-width: 120px;
        text-align: center;
    }
    #easyModeSourceToggleBtn, #easyModePanelToggleBtn {
        font-size: 1.2rem;
        width: 36px;
        border-radius: 50%;
    }
     #easyModeSourceToggleBtn:hover, #easyModePanelToggleBtn:hover {
         background-color: rgba(255, 255, 255, 0.2);
     }

    #easyModeExitBtn {
        display: none;
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 2100;
        background-color: transparent;
        border: none;
        cursor: pointer;
        opacity: 0;
        transition: opacity 0.25s ease;
        padding: 0;
    }
    #easyModeExitBtn img {
        width: 40px;
        height: auto;
    }
    body.easy-mode-active #easyModeExitBtn {
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    #easyModeFadersContainer {
        display: none;
        position: absolute;
        bottom: 20px;
        right: 20px;
        z-index: 2100;
        gap: 15px;
        align-items: flex-end;
        opacity: 0;
        transition: opacity 0.25s ease;
    }
    
    .easy-mode-fader-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 6px;
        width: 25px;
        height: 150px;
    }

    .easy-mode-fader-wrapper label {
        color: white;
        font-size: 0.7rem;
        opacity: 0.8;
        white-space: nowrap;
    }
    
    #easyModeGranulatorVolume, #easyModeMasterVolume {
        writing-mode: bt-lr;
        -webkit-appearance: slider-vertical;
        width: 8px;
        height: 120px;
        margin: 0;
    }

    body.easy-mode-active #easyModeFadersContainer {
        display: flex;
    }

    h1, h2, h3, h4 { text-align: center; margin-top: 0.4em; margin-bottom: 0.4em; }
    h3 { font-size: 1.1em; }
    h4 { font-size: 0.95em; }

    button {
      cursor: pointer; padding: 4px 8px; border: none; border-radius: 3px;
      background-color: var(--button-bg-color); color: var(--button-text-color);
      font-family: inherit; font-size: 0.85rem; min-height: 26px;
      display: inline-flex; align-items: center; justify-content: center;
    }
    button:disabled {
      background-color: #383838;
      color: #777;
      cursor: not-allowed;
    }
    input[type="range"] { vertical-align: middle; min-height: 20px; }

    .dial-value-input,
    .fader-value-input,
    .loop-controls input[type="number"] {
        border: none;
        background-color: transparent;
        color: var(--text-color);
        padding: 1px 2px;
        margin-left: 3px;
        margin-right: 3px;
        font-family: inherit;
        -moz-appearance: textfield;
        appearance: textfield;
        cursor: default;
    }

    .dial-value-input::-webkit-outer-spin-button,
    .dial-value-input::-webkit-inner-spin-button,
    .fader-value-input::-webkit-outer-spin-button,
    .fader-value-input::-webkit-inner-spin-button,
    .loop-controls input[type="number"]::-webkit-outer-spin-button,
    .loop-controls input[type="number"]::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
    }

    .dial-value-input:focus,
    .fader-value-input:focus,
    .loop-controls input[type="number"]:focus {
        outline: 1px solid var(--highlight-color);
        background-color: rgba(80, 80, 80, 0.7);
        color: var(--text-color);
        cursor: text;
    }
    
    .dial-value-input {
        font-size: 0.7rem;
        min-width: 30px;
        width: auto;
        max-width: 65px;
        margin-top: 6px;
        text-align: center;
    }
    .fader-value-input {
        font-size: 0.75rem;
        width: 50px;
        text-align: right;
    }
     #masterTimelineContainer input[type="number"].fader-value-input,
     #timelineValueInput.fader-value-input {
        width: 60px;
    }

    .loop-controls input[type="number"] {
        width: 50px;
        font-size: 0.75rem;
        text-align: right;
        flex-shrink: 0;
    }
     .fader-containerloop input[type="number"].fader-value-input {
        position: absolute;
        bottom: -28px;
        left: 50%;
        transform: translateX(-50%);
        width: 45px;
        font-size: 0.65rem;
        text-align: center;
        padding: 2px;
    }

    label { display: inline-block; margin-right: 4px; font-size: 0.85rem; }
    select {
      font-size: 0.8rem; padding: 5px; height: 30px; border-radius: 3px;
      border: 1px solid var(--border-color); background-color: #fff; color: var(--control-text-color);
    }

    .main-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex-grow: 1;
        padding: 8px;
        gap: 8px;
        width: 100%;
    }

    .top-controls-grid {
        display: flex;
        flex-direction: row;
        gap: 1rem;
        width: 95%;
        max-width: 1800px;
        padding: 3px;
        align-items: stretch;
    }

    @media (max-width: 1024px) {
      .top-controls-grid {
        flex-direction: column;
        width: 98%;
      }
    }

    .column-left, .column-middle, .column-right {
        display: flex;
        flex-direction: column;
        gap: 8px;
        transition: all 0.3s ease-in-out;
    }

    .column-left { flex: 1; min-width: 250px; }
    .column-middle { flex: 2.5; min-width: 320px; }
    .column-right { flex: 1; min-width: 250px; }


    .casilla {
      background-color: var(--casilla-bg-color); padding: 8px; border-radius: 6px;
      border: 1px solid #555; display: flex; flex-direction: column; gap: 6px; position: relative;
    }
    .casilla h3, .casilla h4 { color: var(--text-color); margin-top: 0; margin-bottom: 0.25em; }
    .casilla label { color: var(--text-color); }
    
    #source-controls-casilla .control-panel { background-color: var(--secondary-bg-color); color: var(--text-color); border: 1px solid #444; padding: 6px; border-radius: 3px; }
    #source-controls-casilla .control-panel label, #source-controls-casilla .control-panel span { color: var(--text-color); }
    #sourceToggleButton {
        position: absolute; top: -2px; right: 4px; left: auto; width: 20px; height: 20px; padding: 0; margin: 0;
        background-color: transparent !important; color: var(--text-color); display: flex; justify-content: center;
        align-items: center; border: none; border-radius: 50%; cursor: pointer; z-index: 10;
    }
    #sourceToggleButton::before {
        content: ''; display: block; width: 2.5px; height: 2.5px; background-color: currentColor;
        border-radius: 50%; box-shadow: -5px 0 0 currentColor, 5px 0 0 currentColor;
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    }
    #micPanel, #filePanel { margin-top: 5px; min-height: auto; }
    .panel-controls-grid { display: flex; flex-direction: column; gap: 8px; width: 100%; padding-top: 3px; }
    .file-panel-top-row { display: flex; align-items: center; gap: 6px; }
    .file-panel-top-row #dropZoneTrigger {
        flex-grow: 1; text-align: center; padding: 5px 8px; min-height: 30px; font-size: 0.8rem;
        background-color: #666; border: 1px solid #777; border-radius: 3px;
    }
    .file-panel-top-row .file-panel-top-row-buttons { display: flex; gap: 4px; flex-shrink: 0; }
    .file-panel-top-row .file-panel-top-row-buttons button {
        padding: 4px; min-width: 30px; min-height: 30px; font-size: 0.9rem;
        background-color: var(--button-bg-color); border: 1px solid #585858; border-radius: 3px;
    }
    .file-panel-top-row .file-panel-top-row-buttons button#exportToBuffersBtn {
        font-size: 0.7rem;
        padding: 4px 6px;
    }
    .file-panel-top-row .file-panel-top-row-buttons button:hover:not(:disabled) { background-color: #606060; }
    
    .file-panel-volume-row { display: flex; align-items: center; gap: 6px; width: 100%; flex-wrap: wrap; }
    .file-panel-volume-row label[for="volumeFader"] { margin-right: 2px; flex-shrink: 0; font-size: 0.75rem; }
    .file-panel-volume-row #volumeFader { width: 60px; flex-shrink: 0; margin: 0; }
    .file-panel-volume-row .switch-control-row { flex-grow: 1; }

    .file-panel-bottom-row { display: flex; align-items: center; gap: 6px; width: 100%; flex-wrap: wrap; }
    .file-panel-bottom-row #timeline { flex-grow: 1; min-width: 40px; margin: 0; }
    .file-panel-bottom-row #currentTimeDisplay { min-width: 30px; text-align: right; flex-shrink: 0; font-size: 0.75rem; padding-left: 4px; }
    
    .mic-panel-top-row { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }
    .mic-panel-top-row select { flex-grow: 1; height: 30px; font-size: 0.75rem; border: 1px solid #585858; padding: 4px 6px; min-width: 120px; }
    
    .mic-panel-bottom-row { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }
    .mic-panel-bottom-row #micMuteBtn { flex-shrink: 0; padding: 5px 10px; min-height: 30px; font-size: 0.7rem; border: 1px solid #585858; border-radius: 3px; }
    .mic-panel-bottom-row #micMuteBtn[aria-pressed="true"] { background-color: #c04040; }
    .mic-panel-bottom-row #micMuteBtn[aria-pressed="true"]:hover { background-color: #d05050; }
    .mic-panel-bottom-row #micVolumeFader { flex-grow: 1; margin: 0; }
    .mic-panel-bottom-row .switch-control-row { justify-content: flex-end; }


    .switch-control-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      padding: 2px 0;
    }
    .switch-control-row label:first-child {
        font-size: 0.8rem;
    }
    .toggle-switch-container {
      display: inline-block;
      position: relative;
      width: 35px;
      height: 19px;
    }
    .toggle-switch-input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .toggle-switch-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--switch-bg-off);
      transition: .4s;
      border-radius: 19px;
      border: 1px solid #555;
    }
    .toggle-switch-slider:before {
      position: absolute;
      content: "";
      height: 14px;
      width: 14px;
      left: 2px;
      bottom: 1.5px;
      background-color: var(--switch-thumb-off);
      transition: .4s;
      border-radius: 50%;
    }
    .toggle-switch-input:checked + .toggle-switch-slider {
      background-color: var(--highlight-color);
    }
    .toggle-switch-input:focus + .toggle-switch-slider {
      box-shadow: 0 0 2px var(--highlight-color);
    }
    .toggle-switch-input:checked + .toggle-switch-slider:before {
      transform: translateX(16px);
      background-color: white;
    }

    .toggle-switch-container.small-switch {
        width: 28px;
        height: 15.2px;
    }
    .toggle-switch-container.small-switch .toggle-switch-slider {
        border-radius: 15.2px;
    }
    .toggle-switch-container.small-switch .toggle-switch-slider:before {
        height: 11.2px;
        width: 11.2px;
        left: 1.6px;
        bottom: 1.2px;
    }
    .toggle-switch-container.small-switch .toggle-switch-input:checked + .toggle-switch-slider:before {
        transform: translateX(12.8px);
    }

    #lfo-controls-casilla > div:first-of-type {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        margin-bottom: 8px;
    }
    #lfo-controls-casilla h4 { text-align: left; margin: 0; }
    #lfo-controls-casilla .control-row { display: flex; flex-direction:row; align-items: center; gap: 5px; }
    #lfo-controls-casilla label { font-size: 0.8rem; }
    #lfo-controls-casilla .control-row label { flex-shrink: 0; }
    #lfo-controls-casilla .control-row input[type="range"] { flex-grow: 1; }
    #lfo-controls-casilla .control-row input[type="number"].fader-value-input { width: 60px; flex-shrink: 0; }

    .reverb-eq-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .reverb-eq-header .header-buttons {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    #reverb-eq-visualizer-casilla canvas#spectrumCanvas {
        border: 1px solid #555;
        background-color: rgb(0, 0, 0); /* CAMBIO: Fondo negro */
        margin-bottom: 0;
        cursor: pointer;
        width: 100%;
        aspect-ratio: 2 / 1;
        object-fit: contain;
        display: block;
        min-height: 200px;
    }
    #reverb-eq-visualizer-casilla label.canvas-label { margin-top: 10px; margin-bottom: 5px; font-size: 1em; font-weight: bold; }

    #undoDrawingBtn, #midiMapBtn, #togglePatchBayBtn, #clearDrawingBtn, #toggleFullscreenBtn, #saveSessionBtn, #infoBtn {
      font-size: 0.7rem; padding: 3px 6px; min-height: 22px;
    }
    #midiMapBtn.active {
      background-color: var(--highlight-color);
      color: white;
      box-shadow: 0 0 8px var(--highlight-color);
    }
    
    .actions-container {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        width: 100%;
        gap: 6px;
        margin-top: 10px;
    }
    .rec-action-buttons, .visualizer-action-buttons { display: flex; flex-wrap: wrap; gap: 4px; }
    .rec-action-buttons { justify-content: flex-start; }
    .visualizer-action-buttons { justify-content: flex-end; align-items: center; }
    .rec-action-buttons button, .visualizer-action-buttons button { font-size: 0.7rem; padding: 4px 6px; flex-grow: 0; min-height: 24px; }
    
    #utility-casilla {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
    #utility-casilla .utility-row {
        display: flex;
        flex-wrap: nowrap;
        gap: 8px;
        justify-content: space-between;
        align-items: center;
    }
    #utility-casilla .utility-row .btn-group {
        display: flex;
        gap: 4px;
    }
    #utility-casilla .utility-row button {
        flex-grow: 1;
        font-size: 0.65rem;
        padding: 4px 5px;
        min-height: 22px;
    }

    #master-controls-casilla { display: flex; flex-direction: column; gap: 8px; }
    .master-timeline-and-buttons-container { display: flex; flex-direction: row; align-items: center; gap: 8px; flex-wrap: wrap; }
    #master-controls-casilla #masterTimelineContainer { flex-grow: 1; display: flex; align-items: center; gap: 4px; min-width: 120px; }
    #master-controls-casilla #masterTimelineContainer input[type="range"] { flex-grow: 1; }
    #master-controls-casilla #masterTimelineContainer span { font-size: 0.75rem; }
    .master-recording-buttons { display: flex; gap: 4px; flex-shrink: 0; }
    .master-recording-buttons button { font-size: 0.7rem; padding: 4px 6px; min-height: 24px; }
    #master-controls-casilla #masterVolumeControl { display: flex; flex-direction: row; align-items: center; gap: 6px; margin: 0; width: 100%; }
    #master-controls-casilla #masterVolumeControl label { white-space: nowrap; font-size: 0.8rem; }
    #master-controls-casilla #masterVolumeFader { flex-grow: 1; }
    #master-controls-casilla #masterVolumeValue { min-width: 45px; text-align: right; font-size: 0.75rem; }

    #granulator-main-casilla .granulator-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
    #granulator-main-casilla .granulator-header h4 { margin: 0; text-align: left; }
    #granulator-main-casilla .granulator-header div { display: flex; gap: 4px; }
    #granulator-main-casilla .granulator-fader-container { display: flex; align-items: center; gap: 5px; margin-bottom: 5px;}
    #granulator-main-casilla .granulator-fader-container label { flex-shrink: 0; }
    #granulator-main-casilla .granulator-fader-container input[type="range"] { flex-grow: 1; }
    #granulator-main-casilla .granulator-fader-container input[type="number"].fader-value-input { width: 60px; }
    #granulator-main-casilla .granulator-filter-sidechain-controls { display: flex; gap: 4px; margin-top: 6px; margin-bottom: 4px; width: 100%; }
    #granulator-main-casilla .granulator-filter-sidechain-controls button { flex-grow: 1; font-size: 0.7rem; padding: 4px 6px; }
    #granulatorPlayToggleBtn { font-size: 1.1em; padding: 4px; min-width: 28px; min-height: 28px; }
     #granulator-main-casilla #recordedWaveform {
        width: 100%;
        height: 30px;
        background-color: var(--primary-bg-color);
        border: 1px solid #555;
        border-radius: 3px;
        margin-bottom: 6px;
        cursor: pointer;
    }

    #granulator-main-casilla .dial-controls-container { margin: 6px 0; }
    #granulator-main-casilla label { font-size: 0.8rem; }
    #granulator-main-casilla input[type="range"]:not(.fader),
    #granulator-main-casilla button:not(#granulatorPlayToggleBtn):not(#toggleGranulatorFilterBtn):not(#toggleGranulatorSidechainFilterModBtn) {
        width: 100%; font-size: 0.7rem;
    }
    #granulator-main-casilla > div:has(> #granulatorVolume) { margin-top: 6px; }

    #reverb-dials-casilla h4 { text-align: left; }
    #reverb-dials-casilla .dial-controls-container input[type="number"].dial-value-input { width: 60px; }


    #sidechain-envelope-casilla { position: relative; }
    #sidechain-envelope-casilla h4 { text-align: left; margin-bottom: 6px; }
    #sidechain-envelope-casilla .dial-controls-container input[type="number"].dial-value-input { width: 70px; }

    .dial-controls-container { display: flex; flex-direction: row; justify-content: space-around; align-items: flex-start; gap: 4px; flex-wrap: wrap; }
    .dial-container { display: flex; flex-direction: column; align-items: center; text-align: center; user-select: none; flex: 1; min-width: 55px; }
    .dial-container label { font-size: 0.7rem; margin-bottom: 4px; }
    .dial { width: 40px; height: 40px; background-color: #eee; border: 1.5px solid var(--border-color); border-radius: 50%; position: relative; cursor: grab; box-shadow: inset 0 0 4px rgba(0,0,0,0.3); }
    .dial:active { cursor: grabbing; }
    .dial-indicator { width: 3px; height: 16px; background-color: var(--button-bg-color); position: absolute; top: 4px; left: 50%; transform: translateX(-50%) rotate(0deg); transform-origin: 50% calc(100% - 1.5px); border-radius: 1.5px; }
    
    #loopSection {
        display: flex; flex-direction: row; flex-wrap: wrap; gap: 12px;
        margin: 8px auto; padding: 12px;
        background-color: var(--primary-bg-color); color: var(--text-color);
        border-radius: 6px; width: 95%; max-width: 1800px;
        justify-content: center; border: 1px solid #555;
    }
    .loop-visualizer-group {
        padding: 8px; border-radius: 4px; background-color: var(--casilla-bg-color);
        border: 1px solid #555; display: flex; flex-direction: column; gap: 6px;
        flex-grow: 1;
        flex-basis: 280px;
        min-width: 240px;
        position: relative;
    }
    .loop-visualizer-group label { color: var(--text-color); font-size: 0.8rem; }

    .loop-canvas-container { position: relative; width: 100%; }
    .loop-visualizer-group canvas { width: 100%; height: 80px; background-color: rgb(105, 105, 105); border: 1px solid #555; cursor: crosshair; }
    .loop-zoom-controls { position: absolute; bottom: 5px; left: 50%; transform: translateX(-50%); display: flex; gap: 8px; z-index: 6; }
    .loop-zoom-controls button { width: 20px; height: 20px; padding: 0; border: none; border-radius: 30%; background-color: rgba(50, 50, 50, 0); color: var(--text-color); cursor: pointer; display: flex; align-items: center; justify-content: center; position: relative; font-size: 0; }
    .loop-zoom-controls button:hover { background-color: rgba(70, 70, 70, 0.85); }
    .loop-zoom-controls button::before, .loop-zoom-controls button::after { content: ''; position: absolute; background-color: currentColor; }
    .loop-zoom-controls .zoom-out-btn::before { width: 8px; height: 2px; top: 50%; left: 50%; transform: translate(-50%, -50%); }
    .loop-zoom-controls .zoom-out-btn::after { display: none; }
    .loop-zoom-controls .zoom-in-btn::before { width: 8px; height: 2px; top: 50%; left: 50%; transform: translate(-50%, -50%); }
    .loop-zoom-controls .zoom-in-btn::after { width: 2px; height: 8px; top: 50%; left: 50%; transform: translate(-50%, -50%); }
    
    .loop-sidechain-switch-container {
        position: absolute;
        top: 4px;
        right: 4px;
        z-index: 5;
    }

    .visualizer-volume-container { display: flex; flex-direction: row; align-items: center; gap: 6px; }
    .fader-containerloop { display: flex; align-items: center; width: 25px; justify-content: center; position:relative; }
    .fader-containerloop input[type="range"] { writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 8px; height: 70px; padding: 0 4px; }

    .loop-controls { display: flex; flex-direction: column; gap: 6px; align-items: stretch; margin-top: 6px; }
    .loop-controls > div:first-child {
        display: flex;
        align-items: center;
        gap: 4px;
        justify-content: flex-start;
    }
    .loop-controls > div { display: flex; align-items: center; gap: 4px; justify-content: space-between; }
    .loop-controls label { flex-shrink: 0; margin-right: 4px; }
    .loop-controls input[type="range"] { flex-grow: 1; }
    
    .loop-actions {
        display: flex;
        gap: 6px;
        margin-top: 4px;
    }
    .loop-actions button {
        flex: 1;
        font-size: 0.75rem;
        padding: 4px;
    }
    .loop-actions button[aria-pressed="true"] {
        background-color: var(--highlight-color);
        box-shadow: 0 0 8px var(--highlight-color);
        color: white;
    }

    .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0; }

    #patch-bay-casilla, #routing-patch-bay-casilla {
      display: none;
    }
    #patch-bay-casilla.visible, #routing-patch-bay-casilla.visible {
        display: flex;
        flex-direction: column;
        position: absolute;
        z-index: 150;
        border: 2px solid var(--highlight-color);
        box-shadow: 0 5px 15px rgba(0,0,0,0.5);
    }
    #patch-bay-casilla.visible {
        top: 35px;
        right: 5px;
        width: clamp(380px, 22vw, 420px);
        height: auto;
    }
    #routing-patch-bay-casilla.visible {
        top: 35px;
        right: clamp(400px, 25vw, 450px);
        width: clamp(280px, 18vw, 320px);
        max-height: 300px;
    }
    .drag-handle {
        cursor: move;
        user-select: none;
        padding: 4px;
        padding-left: 30px;
    }
    .patch-bay-content {
        overflow-y: auto;
        flex-grow: 1;
        min-height: 0;
        padding: 4px;
    }
    #patch-bay-casilla .patch-bay-content {
      overflow-y: hidden;
    }
    .close-btn {
        position: absolute;
        top: 6px;
        left: 6px;
        width: 20px;
        height: 20px;
        background-color: transparent;
        border: none;
        color: white;
        font-size: 1.4rem;
        line-height: 1;
        padding: 0;
        cursor: pointer;
        z-index: 10;
        opacity: 0.7;
    }
    .close-btn:hover {
        opacity: 1;
    }

    #patch-bay-casilla h4, #routing-patch-bay-casilla h4 {
      text-align: left;
      margin-bottom: 6px;
    }
    #patchBayGrid, #routingPatchBayGrid {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.7rem;
    }
    #patchBayGrid th, #patchBayGrid td,
    #routingPatchBayGrid th, #routingPatchBayGrid td {
      border: 1px solid #555;
      padding: 3px;
      text-align: center;
      vertical-align: middle;
      white-space: nowrap;
    }
    #patchBayGrid th:first-child, #patchBayGrid td:first-child,
    #routingPatchBayGrid th:first-child, #routingPatchBayGrid td:first-child {
      text-align: left;
      min-width: 70px;
      font-weight: bold;
    }
    #patchBayGrid th, #routingPatchBayGrid th {
        font-size: 0.65rem;
    }
    #patchBayGrid input[type="checkbox"], #routingPatchBayGrid input[type="checkbox"] {
      vertical-align: middle;
      cursor: pointer;
      margin: 0;
    }
    
    body.midi-mapping-active .mappable, 
    body.midi-mapping-active .eq-band-mappable,
    body.midi-mapping-active #recordedWaveform {
      outline: 2px solid var(--highlight-color);
      outline-offset: 2px;
      cursor: copy !important;
      transition: outline 0.2s ease-in-out;
    }
    body.midi-mapping-active .control-listening {
      outline: 3px solid yellow;
      box-shadow: 0 0 10px yellow;
    }
    
    .hidden { display: none !important; }

    .loader-overlay {
        position: absolute;
        top: 0; right: 0; bottom: 0; left: 0;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
        flex-direction: column;
    }
    .loader {
        border: 5px solid #f3f3f3;
        border-top: 5px solid #3498db;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        animation: spin 1s linear infinite;
    }
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    .loader-overlay p {
        margin-top: 1rem;
        color: #FFFFFF;
    }

    @keyframes blink-red {
        50% { background-color: #c04040; box-shadow: 0 0 8px #c04040; }
    }
    button.automation-armed {
        animation: blink-red 1s infinite;
    }
    button.automation-has-data,
    button.state-has-data {
        background-color: green;
    }
    button.automation-playing {
        background-color: lightblue;
        color: black;
    }
    
    /* --- Estilos para el Modal de Guardado --- */
    #save-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background-color: rgba(0, 0, 0, 0.6);
        z-index: 8000;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    #save-modal-container {
        background-color: var(--primary-bg-color);
        border: 1px solid var(--highlight-color);
        border-radius: 6px;
        padding: 18px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        width: 90%;
        max-width: 350px;
        box-shadow: 0 5px 20px rgba(0,0,0,0.5);
    }
    #save-modal-container label {
      font-size: 0.9rem;
    }
    #save-modal-container input[type="text"] {
        width: 100%;
        padding: 8px;
        border-radius: 3px;
        border: 1px solid #777;
        background-color: #444;
        color: var(--text-color);
        font-family: inherit;
        font-size: 0.9rem;
    }
     #save-modal-container input[type="text"]:focus {
        outline: 1px solid var(--highlight-color);
     }
    #save-modal-buttons {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        margin-top: 8px;
    }
    #save-modal-buttons button {
      padding: 6px 14px;
    }
    #save-modal-buttons button#confirm-save-btn {
        background-color: var(--highlight-color);
        color: white;
    }

    /* --- NUEVO: Estilos para el Modal de Información --- */
    #info-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background-color: rgba(0, 0, 0, 0.6);
        z-index: 8000;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    #info-modal-container {
        background-color: var(--primary-bg-color);
        border: 1px solid var(--highlight-color);
        border-radius: 6px;
        padding: 18px;
        display: flex;
        flex-direction: column;
        gap: 15px;
        width: 90%;
        max-width: 450px;
        box-shadow: 0 5px 20px rgba(0,0,0,0.5);
        position: relative;
    }
    #info-modal-container h3 {
      margin: 0 0 10px 0;
      text-align: left;
    }
    #info-modal-container .info-section {
      font-size: 0.9rem;
    }
    #info-modal-container .info-section strong {
      color: var(--highlight-color);
      display: block;
      margin-bottom: 5px;
    }
    #info-modal-container .info-section p,
    #info-modal-container .info-section table {
      margin: 0;
      font-size: 0.85rem;
      color: #ddd;
    }
    #info-modal-container #info-modal-eq-table {
      width: 100%;
      border-collapse: collapse;
    }
    #info-modal-container #info-modal-eq-table th,
    #info-modal-container #info-modal-eq-table td {
      border: 1px solid #555;
      padding: 5px;
      text-align: center;
    }
    #info-modal-container #info-modal-eq-table th {
      background-color: #444;
    }
    #info-modal-close-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 25px;
        height: 25px;
        background-color: transparent;
        border: none;
        color: white;
        font-size: 1.6rem;
        line-height: 1;
        padding: 0;
        cursor: pointer;
        opacity: 0.7;
    }
    #info-modal-close-btn:hover {
        opacity: 1;
    }


  </style>
</head>
<body>
  <div id="loading-overlay">
    <video src="INFO.mov" autoplay muted loop></video>
    <div id="loading-text">_cargando</div>
    <div id="loading-buttons-container">
        <button id="startButton">_inicio</button>
        <div id="bottom-buttons-row">
            <a href="info.html">_info</a>
            <a href="documentacion.html">_documentación</a>
        </div>
    </div>
  </div>
  <main class="main-container">
    <div class="top-controls-grid">
      <div class="column-left">
        <div class="casilla" id="source-controls-casilla">
          <h3 class="sr-only">Fuente de Audio</h3>
          <div id="sourceSelectContainer">
            <button type="button" id="sourceToggleButton" aria-label="Cambiar fuente de audio"></button>
            <select id="sourceSelect" style="display:none;">
              <option value="file" selected>Fuente: Archivo</option>
              <option value="mic">Fuente: Micrófono</option>
            </select>
          </div>
          <div id="filePanel" class="control-panel">
            <div class="panel-controls-grid">
              <div class="file-panel-top-row">
                <button id="dropZoneTrigger" type="button" aria-label="Agregar archivo de audio">Agregar Audio</button>
                <div class="file-panel-top-row-buttons">
                  <button id="playPauseBtn" aria-label="Reproducir o pausar audio" class="mappable">▶</button>
                  <button id="exportToBuffersBtn" aria-label="Exportar a Buffers" disabled>→ Buffers</button>
                </div>
              </div>
              <div class="file-panel-volume-row">
                <label for="volumeFader">Vol</label>
                <input type="range" id="volumeFader" min="0" max="1" step="0.01" value="0.9" aria-label="Volumen del reproductor" class="mappable">
                <input type="number" id="volumeFaderValueInput" class="fader-value-input" min="0" max="1" step="0.01" value="0.9" aria-label="Volumen del reproductor (valor)">
                <div class="switch-control-row">
                    <label for="sourceSidechainSendSwitch_file" style="font-size: 0.8rem;">Envío Sidechain</label>
                    <label class="toggle-switch-container">
                        <input type="checkbox" id="sourceSidechainSendSwitch_file" class="toggle-switch-input source-sidechain-switch">
                        <span class="toggle-switch-slider"></span>
                    </label>
                </div>
              </div>
              <div class="file-panel-bottom-row">
                <input type="range" id="timeline" value="0" min="0" max="100" step="0.1" aria-label="Progreso del audio">
                <input type="number" id="timelineValueInput" class="fader-value-input" value="0" min="0" max="100" step="0.1" aria-label="Progreso del audio (valor)">
                <span id="currentTimeDisplay" aria-live="polite">0:00</span>
              </div>
            </div>
            <input type="file" id="audioFileInput" accept="audio/*" style="display:none;">
            <div id="dropZoneActual" style="display:none;">Arrastre aquí</div>
          </div>
          <div id="micPanel" class="control-panel" style="display:none;">
            <div class="panel-controls-grid">
              <div class="mic-panel-top-row">
                <select id="micSelect" aria-label="Seleccionar dispositivo de micrófono"></select>
                <select id="channelSelect" aria-label="Seleccionar canal de micrófono">
                  <option value="0">Canal 1</option>
                  <option value="1">Canal 2</option>
                </select>
              </div>
              <div class="mic-panel-bottom-row">
                <button id="micMuteBtn" type="button" aria-pressed="false" class="mappable">Mute</button>
                <div class="switch-control-row" style="width: auto;">
                    <label class="toggle-switch-container">
                        <input type="checkbox" id="sourceSidechainSendSwitch_mic" class="toggle-switch-input source-sidechain-switch">
                        <span class="toggle-switch-slider"></span>
                    </label>
                </div>
                <input type="range" id="micVolumeFader" min="0" max="1" step="0.01" value="1" aria-label="Volumen del micrófono" class="mappable">
                <input type="number" id="micVolumeFaderValueInput" class="fader-value-input" min="0" max="1" step="0.01" value="1" aria-label="Volumen del micrófono (valor)">
              </div>
            </div>
          </div>
        </div>
        <div class="casilla" id="granulator-main-casilla">
            <div class="granulator-header">
              <h4 id="granulator-heading">Granulador</h4>
              <div>
                <button id="granulatorPlayToggleBtn" aria-label="Iniciar o detener granulador" class="mappable">▶</button>
              </div>
            </div>
            <canvas id="recordedWaveform" width="250" height="40"></canvas>
            <div class="dial-controls-container">
              <div class="dial-container" id="overlapDialContainer">
                <label for="overlapDial" id="overlapDialLabel">Overlap</label>
                <div class="dial mappable" id="overlapDial" data-min="0" data-max="1" data-step="0.01" data-value="0.8" data-decimals="2">
                  <div class="dial-indicator"></div>
                </div>
                <input type="number" class="dial-value-input" id="overlapDialValue" value="0.80" min="0" max="1" step="0.01" data-decimals="2" aria-labelledby="overlapDialLabel">
              </div>
              <div class="dial-container" id="grainLengthDialContainer">
                <label for="grainLengthDial" id="grainLengthDialLabel">G.Length</label>
                <div class="dial mappable" id="grainLengthDial" data-min="0.01" data-max="1" data-step="0.01" data-value="0.6" data-decimals="2">
                  <div class="dial-indicator"></div>
                </div>
                <input type="number" class="dial-value-input" id="grainLengthDialValue" value="0.60" min="0.01" max="1" step="0.01" data-decimals="2" aria-labelledby="grainLengthDialLabel">
              </div>
              <div class="dial-container" id="pitchBendDialContainer">
                <label for="pitchBendDial" id="pitchBendDialLabel">Pitch Bend</label>
                <div class="dial mappable" id="pitchBendDial" data-min="-12" data-max="12" data-step="0.1" data-value="0" data-decimals="1" data-unit="st">
                  <div class="dial-indicator"></div>
                </div>
                <input type="number" class="dial-value-input" id="pitchBendDialValue" value="0.0" min="-12" max="12" step="0.1" data-decimals="1" data-unit="st" aria-labelledby="pitchBendDialLabel">
              </div>
            </div>
            <div class="granulator-fader-container">
              <label for="granulatorVolume" id="granulatorVolumeLabel">Vol.</label>
              <input type="range" id="granulatorVolume" class="fader mappable" min="0" max="1" step="0.01" value="0.2">
              <input type="number" id="granulatorVolumeValueInput" class="fader-value-input" min="0" max="1" step="0.01" value="0.20" aria-labelledby="granulatorVolumeLabel">
              <span id="granulatorVolumeValue" class="sr-only">0.2</span>
            </div>
        </div>
        <div class="casilla" id="spectral-synth-casilla">
            <div class="switch-control-row">
                <h4>Espectro</h4>
                <label class="toggle-switch-container">
                    <input type="checkbox" id="spectralSynthPowerSwitch" class="toggle-switch-input mappable">
                    <span class="toggle-switch-slider"></span>
                </label>
            </div>
            <div class="granulator-fader-container">
                <label for="spectralSynthVolume" id="spectralSynthVolumeLabel">Volumen:</label>
                <input type="range" id="spectralSynthVolume" class="fader mappable" min="0" max="1" step="0.01" value="0.9">
                <input type="number" id="spectralSynthVolumeValueInput" class="fader-value-input" min="0" max="1" step="0.01" value="0.90" aria-labelledby="spectralSynthVolumeLabel">
            </div>
            <div class="switch-control-row" style="padding-top: 5px;">
              <label for="spectralSynthDrawModeSwitch">Modo Dibujo</label>
              <label class="toggle-switch-container">
                  <input type="checkbox" id="spectralSynthDrawModeSwitch" class="toggle-switch-input" checked>
                  <span class="toggle-switch-slider"></span>
              </label>
            </div>
        </div>
      </div>
      <div class="column-middle">
        <div class="casilla" id="reverb-eq-visualizer-casilla">
            <button id="easyModeExitBtn" aria-label="Salir de Modo Fácil">
                <img src="sintxart.png" alt="Salir de Modo Fácil">
            </button>
            <div id="easyModeSourceControls">
                <div class="control-group">
                    <button id="easyModeAudioFileBtn" title="Agregar Audio">Agregar Audio</button>
                    <select id="easyModeMicSelect" class="hidden" title="Seleccionar Micrófono"></select>
                </div>
                <button id="easyModeSourceToggleBtn" title="Cambiar a Micrófono">···</button>
                <button id="easyModePanelToggleBtn" title="Abrir panel de fuente completo">↗</button>
            </div>
             <div id="easyModeFadersContainer">
                <div class="easy-mode-fader-wrapper">
                    <label for="easyModeMasterVolume">Master</label>
                    <input type="range" id="easyModeMasterVolume" min="0" max="1.5" step="0.01" value="1.0">
                </div>
                <div class="easy-mode-fader-wrapper">
                    <label for="easyModeGranulatorVolume">Grl.</label>
                    <input type="range" id="easyModeGranulatorVolume" min="0" max="1" step="0.01" value="0.2">
                </div>
            </div>
            <div id="easyModeTopControls">
                <button id="easyModeAppendBtn" class="easy-mode-btn-round" title="Append (Añadir Grabación)">+</button>
                <button id="easyModeRecordBtn" class="easy-mode-btn-round main-rec" title="Record/Stop">●</button>
                <button id="easyModeOverdubBtn" class="easy-mode-btn-round" title="Overdub (Sobrescribir)">◎</button>
                <button id="easyModeClearBtn" class="easy-mode-btn-round" title="Clear (Borrar)">⌫</button>
            </div>
            <div id="easyModeBottomControls">
                 <button id="easyModeRecordMasterBtn" class="easy-mode-btn-round main-rec" title="Grabar/Detener Master">●</button>
                 <button id="easyModePlayMasterBtn" class="easy-mode-btn-round" title="Reproducir Grabación Master">▶</button>
            </div>
            <div class="reverb-eq-header"></div>
            <canvas id="spectrumCanvas" width="600" height="300"></canvas>
            <div id="loader-overlay" class="loader-overlay hidden">
                <div class="loader"></div>
                <p>Procesando...</p>
            </div>
            <div class="actions-container">
                <div class="rec-action-buttons">
                    <button id="recordBtn" class="mappable">Record</button>
                    <button id="stopRecBtn" class="mappable" disabled>Stop</button>
                    <button id="appendRecBtn" class="mappable">Append</button>
                    <button id="overdubNowBtn" class="mappable">Overdub</button>
                    <button id="clearRecBtn" class="mappable">Clear</button>
                </div>
                <div class="visualizer-action-buttons">
                    <div class="switch-control-row" style="width: auto; padding: 0; gap: 6px;">
                        <label for="animationPowerSwitch" style="font-size: 0.8rem;">Animación</label>
                        <label class="toggle-switch-container small-switch">
                            <input type="checkbox" id="animationPowerSwitch" class="toggle-switch-input" checked>
                            <span class="toggle-switch-slider"></span>
                        </label>
                    </div>
                    <button id="clearDrawingBtn" aria-label="Limpiar Dibujo Espectral">Limpiar Dibujo</button>
                    <button id="undoDrawingBtn" aria-label="Deshacer último trazo">Retroceder</button>
                    <button id="saveSessionBtn" aria-label="Guardar Sesión">Guardar Sesión</button>
                </div>
            </div>
        </div>
        <div class="casilla" id="master-controls-casilla">
          <h3 class="sr-only">Controles Master</h3>
          <div class="master-timeline-and-buttons-container">
            <div id="masterTimelineContainer" class="timeline-container">
              <label for="masterTimeline" class="sr-only" id="masterTimelineLabel">Línea de tiempo del Master</label>
              <input type="range" id="masterTimeline" value="0" min="0" step="0.1">
              <input type="number" id="masterTimelineValueInput" class="fader-value-input" value="0" min="0" step="0.1" aria-labelledby="masterTimelineLabel">
              <span id="masterCurrentTime" aria-live="polite">0:00</span> / <span id="masterDuration">0:00</span>
            </div>
            <div class="master-recording-buttons">
                <button id="recordMasterBtn" class="mappable">Grabar Master</button>
                <button id="playMasterBufferBtn" class="mappable">Play Grab.</button>
                <button id="pauseMasterBufferBtn" class="mappable">Pause Grab.</button>
                <button id="downloadMasterBtn">Descargar</button>
            </div>
          </div>
          <div id="masterVolumeControl">
            <label for="masterVolumeFader" id="masterVolumeLabel">Volumen Master:</label>
            <input type="range" id="masterVolumeFader" min="0" max="1.5" step="0.01" value="1" class="mappable">
            <input type="number" id="masterVolumeFaderValueInput" class="fader-value-input" min="0" max="1.5" step="0.01" value="1" aria-labelledby="masterVolumeLabel">
            <span id="masterVolumeValue" aria-live="polite">0.0 dB</span>
          </div>
        </div>
      </div>
      <div class="column-right">
        <div class="casilla" id="utility-casilla">
            <div class="utility-row">
                <button id="toggleFullscreenBtn" aria-label="Activar Modo fácil">Modo fácil</button>
                <button id="midiMapBtn" aria-label="Activar mapeo MIDI">MIDI</button>
                <button id="togglePatchBayBtn" aria-label="Toggle Patch Bay">PatchBay</button>
                <button id="infoBtn" aria-label="Mostrar información de la sesión">Info</button>
            </div>
            <div class="utility-row">
                <div class="btn-group save-action-buttons">
                    <button id="stateBtn1" aria-label="Guardar o cargar estado A" class="mappable">Save-A</button>
                    <button id="stateBtn2" aria-label="Guardar o cargar estado B" class="mappable">Save-B</button>
                    <button id="stateBtn3" aria-label="Guardar o cargar estado C" class="mappable">Save-C</button>
                    <button id="stateBtn4" aria-label="Guardar o cargar estado D" class="mappable">Save-D</button>
                </div>
                <div class="btn-group mem-buttons">
                    <button id="memBtn1" aria-label="Grabar o reproducir automatización A" class="mappable">Aut-A</button>
                    <button id="memBtn2" aria-label="Grabar o reproducir automatización B" class="mappable">Aut-B</button>
                    <button id="memBtn3" aria-label="Grabar o reproducir automatización C" class="mappable">Aut-C</button>
                    <button id="memBtn4" aria-label="Grabar o reproducir automatización D" class="mappable">Aut-D</button>
                </div>
            </div>
        </div>
        <div class="casilla" id="reverb-dials-casilla">
            <h4>Reverb</h4>
            <div class="dial-controls-container">
                <div class="dial-container" id="reverbSizeDialContainer">
                    <label for="reverbSizeDial" id="reverbSizeDialLabel">Size</label>
                    <div class="dial mappable" id="reverbSizeDial" data-min="0.1" data-max="6" data-step="0.1" data-value="5.0" data-unit="s" data-decimals="1">
                        <div class="dial-indicator"></div>
                    </div>
                    <input type="number" class="dial-value-input" id="reverbSizeDialValue" value="5.0" min="0.1" max="6" step="0.1" data-unit="s" data-decimals="1" aria-labelledby="reverbSizeDialLabel">
                </div>
                <div class="dial-container" id="reverbDryWetDialContainer">
                    <label for="reverbDryWetDial" id="reverbDryWetDialLabel">Dry/Wet</label>
                    <div class="dial mappable" id="reverbDryWetDial" data-min="0" data-max="1" data-step="0.01" data-value="0.85" data-decimals="2">
                        <div class="dial-indicator"></div>
                    </div>
                    <input type="number" class="dial-value-input" id="reverbDryWetDialValue" value="0.85" min="0" max="1" step="0.01" data-decimals="2" aria-labelledby="reverbDryWetDialLabel">
                </div>
                <div class="dial-container" id="granulatorFilterFreqContainer">
                  <label for="granulatorFilterFreq" id="granulatorFilterFreqLabel">Cutoff</label>
                  <div class="dial mappable" id="granulatorFilterFreq" data-min="20" data-max="20000" data-step="1" data-value="10000" data-decimals="0">
                    <div class="dial-indicator"></div>
                  </div>
                  <input type="number" class="dial-value-input" id="granulatorFilterFreqValue" value="10000" min="20" max="20000" step="1" data-decimals="0" aria-labelledby="granulatorFilterFreqLabel">
                </div>
            </div>
             <button id="toggleGranulatorFilterBtn" type="button" class="mappable" style="width:100%; margin-top: 8px; font-size: 0.7rem; padding: 4px 6px;">Filtro: Highpass</button>
        </div>
        <div class="casilla" id="lfo-controls-casilla">
            <div>
                <h4>LFO</h4>
                <label class="toggle-switch-container">
                    <input type="checkbox" id="lfoPowerSwitch" class="toggle-switch-input">
                    <span class="toggle-switch-slider"></span>
                </label>
            </div>
            <div class="control-row">
              <label for="granulatorLfoSpeed" id="granulatorLfoSpeedLabel">Rate</label>
              <input type="range" id="granulatorLfoSpeed" min="0.1" max="20" step="0.01" value="1" class="mappable">
              <input type="number" id="granulatorLfoSpeedValueInput" class="fader-value-input" min="0.1" max="20" step="0.01" value="1" aria-labelledby="granulatorLfoSpeedLabel">
            </div>
            <div class="control-row">
              <label for="granulatorLfoDepth" id="granulatorLfoDepthLabel">Depth</label>
              <input type="range" id="granulatorLfoDepth" min="0" max="10000" step="1" value="500" class="mappable">
              <input type="number" id="granulatorLfoDepthValueInput" class="fader-value-input" min="0" max="10000" step="1" value="500" aria-labelledby="granulatorLfoDepthLabel">
            </div>
        </div>
        <div class="casilla" id="sidechain-envelope-casilla">
  <div class="switch-control-row">
    <h4>Sidechain Envelope (Post-Reverb)</h4>
    <label class="toggle-switch-container">
        <input type="checkbox" id="sidechainEnvelopePowerSwitch" class="toggle-switch-input">
        <span class="toggle-switch-slider"></span>
    </label>
  </div>
  <div class="dial-controls-container">
    <div class="dial-container" id="sidechainThresholdDialContainer">
      <label for="sidechainThresholdDial" id="sidechainThresholdDialLabel">Umbral</label>
      <div class="dial mappable" id="sidechainThresholdDial" data-min="-70" data-max="0" data-step="1" data-value="-24" data-unit="dB" data-decimals="0">
        <div class="dial-indicator"></div>
      </div>
      <input type="number" class="dial-value-input" id="sidechainThresholdDialValue" value="-24" min="-70" max="0" step="1" data-unit="dB" data-decimals="0" aria-labelledby="sidechainThresholdDialLabel">
    </div>
    <div class="dial-container" id="sidechainAttackDialContainer">
      <label for="sidechainAttackDial" id="sidechainAttackDialLabel">Ataque</label>
      <div class="dial mappable" id="sidechainAttackDial" data-min="0.001" data-max="0.5" data-step="0.001" data-value="0.01" data-unit="s" data-decimals="3">
        <div class="dial-indicator"></div>
      </div>
      <input type="number" class="dial-value-input" id="sidechainAttackDialValue" value="0.010" min="0.001" max="0.5" step="0.001" data-unit="s" data-decimals="3" aria-labelledby="sidechainAttackDialLabel">
    </div>
     <div class="dial-container" id="sidechainReleaseDialContainer">
      <label for="sidechainReleaseDial" id="sidechainReleaseDialLabel">Relaj.</label>
      <div class="dial mappable" id="sidechainReleaseDial" data-min="0.01" data-max="1.0" data-step="0.01" data-value="0.1" data-unit="s" data-decimals="2">
        <div class="dial-indicator"></div>
      </div>
      <input type="number" class="dial-value-input" id="sidechainReleaseDialValue" value="0.10" min="0.01" max="1.0" step="0.01" data-unit="s" data-decimals="2" aria-labelledby="sidechainReleaseDialLabel">
    </div>
    <div class="dial-container" id="sidechainAmountDialContainer">
      <label for="sidechainAmountDial" id="sidechainAmountDialLabel">Cantidad</label>
      <div class="dial mappable" id="sidechainAmountDial" data-min="0" data-max="12000" data-step="100" data-value="1000" data-unit="Hz" data-decimals="0">
        <div class="dial-indicator"></div>
      </div>
      <input type="number" class="dial-value-input" id="sidechainAmountDialValue" value="1000" min="0" max="12000" step="100" data-unit="Hz" data-decimals="0" aria-labelledby="sidechainAmountDialLabel">
    </div>
  </div>
</div>
        </div>
        <div class="casilla" id="routing-patch-bay-casilla">
          <button class="close-btn" aria-label="Cerrar Patch Bay">&times;</button>
          <h4 class="drag-handle">Patch Bay de Ruteo de Audio</h4>
          <div class="patch-bay-content">
            <table id="routingPatchBayGrid">
              <thead>
                <tr>
                  <th>Fuente</th>
                  <th>Master</th>
                  <th>Reverb</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Reproductor</td>
                  <td><input type="checkbox" data-source="filePlayer" data-dest="dry" checked></td>
                  <td><input type="checkbox" data-source="filePlayer" data-dest="wet" checked></td>
                </tr>
                <tr>
                  <td>Micrófono</td>
                  <td><input type="checkbox" data-source="mic" data-dest="dry" checked></td>
                  <td><input type="checkbox" data-source="mic" data-dest="wet" checked></td>
                </tr>
                <tr>
                  <td>Granulador</td>
                  <td><input type="checkbox" data-source="granulator" data-dest="dry" checked></td>
                  <td><input type="checkbox" data-source="granulator" data-dest="wet" checked></td>
                </tr>
                <tr>
                  <td>Sint. Espectral</td>
                  <td><input type="checkbox" data-source="spectralSynth" data-dest="dry" checked></td>
                  <td><input type="checkbox" data-source="spectralSynth" data-dest="wet" checked></td>
                </tr>
                <tr>
                  <td>Loop 1</td>
                  <td><input type="checkbox" data-source="loop1" data-dest="dry" checked></td>
                  <td><input type="checkbox" data-source="loop1" data-dest="wet" checked></td>
                </tr>
                <tr>
                  <td>Loop 2</td>
                  <td><input type="checkbox" data-source="loop2" data-dest="dry" checked></td>
                  <td><input type="checkbox" data-source="loop2" data-dest="wet" checked></td>
                </tr>
                <tr>
                  <td>Loop 3</td>
                  <td><input type="checkbox" data-source="loop3" data-dest="dry" checked></td>
                  <td><input type="checkbox" data-source="loop3" data-dest="wet" checked></td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <div class="casilla" id="patch-bay-casilla">
          <button class="close-btn" aria-label="Cerrar Patch Bay">&times;</button>
          <h4 class="drag-handle">Modulación Directa (Patch Bay)</h4>
          <div class="patch-bay-content">
            <p style="font-size: 0.75rem; margin-bottom: 8px; color: #ccc;">Marca las casillas para asignar el control del ratón (sobre esta ventana) a los parámetros. El movimiento se escala al rango del parámetro.</p>
            <table id="patchBayGrid">
              <thead>
                <tr>
                  <th>Control</th>
                  <th>Vel. LFO</th>
                  <th>Grain Pos</th>
                  <th>Cutoff</th>
                  <th>PitchBend</th>
                  <th>Size</th>
                  <th>Dry/Wet</th>
                </tr>
              </thead>
              <tbody>
                <tr data-mouse-axis="mouseY">
                  <td>Ratón Y (Vertical)</td>
                  <td><input type="checkbox" data-param-id="granulatorLfoSpeed" aria-label="Mapear Ratón Y a Velocidad LFO"></td>
                  <td><input type="checkbox" data-param-id="grainPosFader" aria-label="Mapear Ratón Y a Posición de Grano Principal"></td>
                  <td><input type="checkbox" data-param-id="granulatorFilterFreq" aria-label="Mapear Ratón Y a Cutoff de Filtro"></td>
                  <td><input type="checkbox" data-param-id="pitchBendDial" aria-label="Mapear Ratón Y a Pitch Bend"></td>
                  <td><input type="checkbox" data-param-id="reverbSizeDial" aria-label="Mapear Ratón Y a Tamaño de Reverb"></td>
                  <td><input type="checkbox" data-param-id="reverbDryWetDial" aria-label="Mapear Ratón Y a Dry/Wet de Reverb"></td>
                </tr>
                <tr data-mouse-axis="mouseX">
                  <td>Ratón X (Horizontal)</td>
                  <td><input type="checkbox" data-param-id="granulatorLfoSpeed" aria-label="Mapear Ratón X a Velocidad LFO"></td>
                  <td><input type="checkbox" data-param-id="grainPosFader" aria-label="Mapear Ratón X a Posición de Grano Principal"></td>
                  <td><input type="checkbox" data-param-id="granulatorFilterFreq" aria-label="Mapear Ratón X a Cutoff de Filtro"></td>
                  <td><input type="checkbox" data-param-id="pitchBendDial" aria-label="Mapear Ratón X a Pitch Bend"></td>
                  <td><input type="checkbox" data-param-id="reverbSizeDial" aria-label="Mapear Ratón X a Tamaño de Reverb"></td>
                  <td><input type="checkbox" data-param-id="reverbDryWetDial" aria-label="Mapear Ratón X a Dry/Wet de Reverb"></td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
    <section id="loopSection" aria-labelledby="loop-section-heading">
      <h2 id="loop-section-heading" class="sr-only">Sección de Loops</h2>
      <div class="loop-visualizer-group">
        <div class="visualizer-volume-container">
          <div class="loop-canvas-container">
            <div class="loop-sidechain-switch-container">
              <label class="toggle-switch-container small-switch" title="Envío a Sidechain Loop 1">
                <input type="checkbox" id="loop1SidechainSendSwitch" class="toggle-switch-input" data-loopindex="0">
                <span class="toggle-switch-slider"></span>
              </label>
            </div>
            <canvas id="loopCanvas1" width="300" height="100" class="mappable"></canvas>
            <div class="loop-zoom-controls">
                <button class="zoom-out-btn" data-loopindex="0" aria-label="Zoom out loop 1"></button>
                <button class="zoom-in-btn" data-loopindex="0" aria-label="Zoom in loop 1"></button>
            </div>
          </div>
          <div class="fader-containerloop">
            <label for="loopVolume1" class="sr-only" id="loopVolume1Label">Volumen Loop 1</label>
            <input type="range" id="loopVolume1" min="0" max="1" step="0.01" value="1" orient="vertical" class="mappable">
            <input type="number" id="loopVolume1ValueInput" class="fader-value-input" min="0" max="1" step="0.01" value="1" aria-labelledby="loopVolume1Label">
          </div>
        </div>
        <div class="loop-controls">
          <div>
            <label for="speedControl1" id="speedControl1Label">Velocidad:</label>
            <input type="range" id="speedControl1" min="0.1" max="4" step="0.01" value="1" data-decimals="2" class="mappable">
            <input type="number" id="speedValue1" min="0.1" max="4" step="0.01" value="1" data-decimals="2" aria-labelledby="speedControl1Label">
          </div>
          <div class="loop-actions">
            <button id="reverseBtn1" class="loop-action-btn mappable" aria-pressed="false" aria-label="Reversa Loop 1">REV</button>
            <button id="loopPlayPauseBtn1" type="button" class="mappable">Play</button>
            <button id="flexPitchBtn1" class="loop-action-btn mappable" aria-pressed="false" aria-label="Flex Pitch Loop 1">FLEX</button>
          </div>
        </div>
      </div>
      <div class="loop-visualizer-group">
        <div class="visualizer-volume-container">
          <div class="loop-canvas-container">
            <div class="loop-sidechain-switch-container">
              <label class="toggle-switch-container small-switch" title="Envío a Sidechain Loop 2">
                <input type="checkbox" id="loop2SidechainSendSwitch" class="toggle-switch-input" data-loopindex="1">
                <span class="toggle-switch-slider"></span>
              </label>
            </div>
            <canvas id="loopCanvas2" width="300" height="100" class="mappable"></canvas>
            <div class="loop-zoom-controls">
                <button class="zoom-out-btn" data-loopindex="1" aria-label="Zoom out loop 2"></button>
                <button class="zoom-in-btn" data-loopindex="1" aria-label="Zoom in loop 2"></button>
            </div>
          </div>
          <div class="fader-containerloop">
            <label for="loopVolume2" class="sr-only" id="loopVolume2Label">Volumen Loop 2</label>
            <input type="range" id="loopVolume2" min="0" max="1" step="0.01" value="1" orient="vertical" class="mappable">
            <input type="number" id="loopVolume2ValueInput" class="fader-value-input" min="0" max="1" step="0.01" value="1" aria-labelledby="loopVolume2Label">
          </div>
        </div>
        <div class="loop-controls">
          <div>
            <label for="speedControl2" id="speedControl2Label">Velocidad:</label>
            <input type="range" id="speedControl2" min="0.1" max="4" step="0.01" value="1" data-decimals="2" class="mappable">
            <input type="number" id="speedValue2" min="0.1" max="4" step="0.01" value="1" data-decimals="2" aria-labelledby="speedControl2Label">
          </div>
          <div class="loop-actions">
            <button id="reverseBtn2" class="loop-action-btn mappable" aria-pressed="false" aria-label="Reversa Loop 2">REV</button>
            <button id="loopPlayPauseBtn2" type="button" class="mappable">Play</button>
            <button id="flexPitchBtn2" class="loop-action-btn mappable" aria-pressed="false" aria-label="Flex Pitch Loop 2">FLEX</button>
          </div>
        </div>
      </div>
      <div class="loop-visualizer-group">
        <div class="visualizer-volume-container">
          <div class="loop-canvas-container">
             <div class="loop-sidechain-switch-container">
              <label class="toggle-switch-container small-switch" title="Envío a Sidechain Loop 3">
                <input type="checkbox" id="loop3SidechainSendSwitch" class="toggle-switch-input" data-loopindex="2">
                <span class="toggle-switch-slider"></span>
              </label>
            </div>
            <canvas id="loopCanvas3" width="300" height="100" class="mappable"></canvas>
            <div class="loop-zoom-controls">
                <button class="zoom-out-btn" data-loopindex="2" aria-label="Zoom out loop 2"></button>
                <button class="zoom-in-btn" data-loopindex="2" aria-label="Zoom in loop 2"></button>
            </div>
          </div>
          <div class="fader-containerloop">
            <label for="loopVolume3" class="sr-only" id="loopVolume3Label">Volumen Loop 3</label>
            <input type="range" id="loopVolume3" min="0" max="1" step="0.01" value="1" orient="vertical" class="mappable">
            <input type="number" id="loopVolume3ValueInput" class="fader-value-input" min="0" max="1" step="0.01" value="1" aria-labelledby="loopVolume3Label">
          </div>
        </div>
        <div class="loop-controls">
          <div>
            <label for="speedControl3" id="speedControl3Label">Velocidad:</label>
            <input type="range" id="speedControl3" min="0.1" max="4" step="0.01" value="1" data-decimals="2" class="mappable">
            <input type="number" id="speedValue3" min="0.1" max="4" step="0.01" value="1" data-decimals="2" aria-labelledby="speedControl3Label">
          </div>
          <div class="loop-actions">
            <button id="reverseBtn3" class="loop-action-btn mappable" aria-pressed="false" aria-label="Reversa Loop 3">REV</button>
            <button id="loopPlayPauseBtn3" type="button" class="mappable">Play</button>
            <button id="flexPitchBtn3" class="loop-action-btn mappable" aria-pressed="false" aria-label="Flex Pitch Loop 3">FLEX</button>
          </div>
        </div>
      </div>
    </section>
  </main>
  <div id="info-modal-overlay" class="hidden">
    <div id="info-modal-container">
        <button id="info-modal-close-btn" aria-label="Cerrar">&times;</button>
        <h3>Información de la Sesión</h3>
        
        <div class="info-section">
            <strong>Archivo de Audio</strong>
            <p id="info-audio-file-name">No hay ningún archivo cargado.</p>
        </div>
        
        <div class="info-section">
            <strong>Sample Rate del Sistema</strong>
            <p id="info-sample-rate">N/A</p>
        </div>

        <div class="info-section">
            <strong>Valores del Ecualizador</strong>
            <table id="info-modal-eq-table">
                <thead>
                    <tr>
                        <th>Banda</th>
                        <th>Frecuencia (Hz)</th>
                        <th>Ganancia (dB)</th>
                        <th>Q</th>
                    </tr>
                </thead>
                <tbody id="info-eq-table-body">
                    </tbody>
            </table>
        </div>
    </div>
  </div>
  <script>
function degToRad(deg) { return deg * (Math.PI / 180); }
function radToDeg(rad) { return rad * (180 / Math.PI); }

function initDial(dialElement) {
    const dial = dialElement;
    const indicator = dial.querySelector('.dial-indicator');
    const displayInput = dial.parentElement.querySelector('input[type="number"].dial-value-input');
    if (!indicator) { console.error("Dial indicator not found for:", dial.id); return; }

    const min = parseFloat(dial.getAttribute('data-min'));
    const max = parseFloat(dial.getAttribute('data-max'));
    const step = parseFloat(dial.getAttribute('data-step'));
    let currentValue = parseFloat(dial.getAttribute('data-value'));
    const angleMin = -135, angleMax = 135;
    
    if (isNaN(min) || isNaN(max) || isNaN(step)) {
        console.error("Atributo data-* inválido en el dial:", dial.id);
        return;
    }

    const dataDecimalsAttr = dial.getAttribute('data-decimals');
    const finalDecimals = dataDecimalsAttr ?
                          parseInt(dataDecimalsAttr) :
                          (step.toString().includes('.') ? step.toString().split('.')[1].length : 0);

    function updateDialVisuals(valToUpdate, dispatchChangeEvent = true) {
        const percent = (max - min === 0) ? 0 : (valToUpdate - min) / (max - min);
        const angle = angleMin + percent * (angleMax - angleMin);
        indicator.style.transform = `translateX(-50%) rotate(${angle}deg)`;

        if (displayInput) {
            let numericValue = parseFloat(valToUpdate.toFixed(finalDecimals));
            displayInput.value = numericValue;
        }
        dial.setAttribute('data-value', valToUpdate);
        dial.setAttribute('aria-valuenow', valToUpdate);

        if (dispatchChangeEvent) {
            const event = new CustomEvent('dialChange', { bubbles: true, detail: { value: valToUpdate } });
            dial.dispatchEvent(event);
            
            if(window.recordAutomationEvent) {
                window.recordAutomationEvent(dial.id, valToUpdate);
            }
        }
    }
    updateDialVisuals(currentValue, false);

    if (displayInput) {
        displayInput.min = min;
        displayInput.max = max;
        displayInput.step = step;

        displayInput.addEventListener('input', (e) => {
            let rawValue = e.target.value;
            if (rawValue === "" || rawValue === "-" || rawValue.endsWith(".")) {
                return;
            }
            let newValue = parseFloat(rawValue);
            if (isNaN(newValue)) return;

            const tempVal = Math.min(max, Math.max(min, newValue));
            const percent = (max - min === 0) ? 0 : (tempVal - min) / (max - min);
            const angle = angleMin + percent * (angleMax - angleMin);
            indicator.style.transform = `translateX(-50%) rotate(${angle}deg)`;
            dial.setAttribute('data-value', tempVal);
        });

        displayInput.addEventListener('change', (e) => {
            let finalValue = parseFloat(e.target.value);
            if (isNaN(finalValue)) {
                finalValue = currentValue;
            } else {
                finalValue = Math.min(max, Math.max(min, finalValue));
                finalValue = Math.round(finalValue / step) * step;
            }
            currentValue = finalValue;
            updateDialVisuals(currentValue, true);
        });
    }

    let isDragging = false;
    function onMove(event) {
        let clientX, clientY;
        if (event.touches) { clientX = event.touches[0].clientX; clientY = event.touches[0].clientY; }
        else { clientX = event.clientX; clientY = event.clientY; }
        const rect = dial.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2, centerY = rect.top + rect.height / 2;
        const dx = clientX - centerX, dy = clientY - centerY;
        let angleRad = Math.atan2(dy, dx);
        let angleDeg = radToDeg(angleRad) + 90;
        if (angleDeg < -180) angleDeg += 360; if (angleDeg > 180) angleDeg -= 360;
        angleDeg = Math.max(angleMin, Math.min(angleMax, angleDeg));
        const percent = (angleMax - angleMin === 0) ? 0 : (angleDeg - angleMin) / (angleMax - angleMin);
        
        let newValue = min + percent * (max - min);
        newValue = Math.round(newValue / step) * step;

        currentValue = Math.min(max, Math.max(min, newValue));
        updateDialVisuals(currentValue, true);
    }
    dial.addEventListener('mousedown', (e) => { if (e.button !== 0) return; isDragging = true; document.body.style.cursor = 'grabbing'; dial.style.cursor = 'grabbing'; onMove(e); e.preventDefault(); });
    dial.addEventListener('touchstart', (e) => { isDragging = true; onMove(e); e.preventDefault(); }, { passive: false });
    window.addEventListener('mousemove', (e) => { if (isDragging) onMove(e); });
    window.addEventListener('touchmove', (e) => { if (isDragging) onMove(e); }, { passive: false });
    const stopDragging = () => { 
        if (isDragging) { 
            isDragging = false; 
            document.body.style.cursor = 'default'; 
            dial.style.cursor = 'grab';
        } 
    };
    window.addEventListener('mouseup', stopDragging);
    window.addEventListener('touchend', stopDragging);
}

function makeDraggable(element, handle) {
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

    const dragMouseDown = (e) => {
        e = e || window.event;
        e.preventDefault();
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        document.onmousemove = elementDrag;
    };

    handle.onmousedown = dragMouseDown;

    const elementDrag = (e) => {
        e = e || window.event;
        e.preventDefault();
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        element.style.top = (element.offsetTop - pos2) + "px";
        element.style.left = (element.offsetLeft - pos1) + "px";
    };

    const closeDragElement = () => {
        document.onmouseup = null;
        document.onmousemove = null;
    };
}


document.addEventListener('DOMContentLoaded', function() {
    console.log("DOM Content Loaded. Initializing Dials, Faders and UI...");

    const sourceControlsCasilla = document.getElementById('source-controls-casilla');
    
    // CORRECCIÓN 5: Evitar que el panel de micrófono se cierre solo.
    sourceControlsCasilla.addEventListener('click', (e) => e.stopPropagation());

    // --- LÓGICA MODO FÁCIL ---
    const toggleFullscreenBtn = document.getElementById('toggleFullscreenBtn');
    const visualizerCasilla = document.getElementById('reverb-eq-visualizer-casilla');
    
    const visualizerOriginalParent = visualizerCasilla.parentNode;
    const visualizerOriginalNextSibling = visualizerCasilla.nextSibling;
    const sourceOriginalParent = sourceControlsCasilla.parentNode;
    const sourceOriginalNextSibling = sourceControlsCasilla.nextSibling;
    
    const easyModeAudioFileBtn = document.getElementById('easyModeAudioFileBtn');
    const easyModeMicSelect = document.getElementById('easyModeMicSelect');
    const easyModeSourceToggleBtn = document.getElementById('easyModeSourceToggleBtn');
    const easyModePanelToggleBtn = document.getElementById('easyModePanelToggleBtn');
    const easyModeSourceControls = document.getElementById('easyModeSourceControls');

    function toggleEasyMode() {
        const isInEasyMode = document.body.classList.contains('easy-mode-active');
        
        if (isInEasyMode) {
            document.body.classList.remove('easy-mode-active');
            visualizerOriginalParent.insertBefore(visualizerCasilla, visualizerOriginalNextSibling);
            sourceOriginalParent.insertBefore(sourceControlsCasilla, sourceOriginalNextSibling);
            sourceControlsCasilla.classList.remove('floating');

        } else {
            document.body.appendChild(visualizerCasilla); 
            document.body.classList.add('easy-mode-active');
            if (window.currentAudioSourceType === 'mic') {
                easyModeAudioFileBtn.classList.add('hidden');
                easyModeMicSelect.classList.remove('hidden');
                easyModeSourceToggleBtn.title = "Cambiar a Archivo";
            } else {
                easyModeAudioFileBtn.classList.remove('hidden');
                easyModeMicSelect.classList.add('hidden');
                easyModeSourceToggleBtn.title = "Cambiar a Micrófono";
            }
        }

        toggleFullscreenBtn.textContent = document.body.classList.contains('easy-mode-active') ? "Salir de Fácil" : "Modo fácil";

        setTimeout(() => {
            window.dispatchEvent(new Event('resize'));
        }, 50);
    }
    
    toggleEasyMode(); 

    if (toggleFullscreenBtn) {
        toggleFullscreenBtn.addEventListener('click', toggleEasyMode);
    }
    if (document.getElementById('easyModeExitBtn')) {
        document.getElementById('easyModeExitBtn').addEventListener('click', toggleEasyMode);
    }
    
    if (easyModeAudioFileBtn) {
        easyModeAudioFileBtn.addEventListener('click', () => document.getElementById('audioFileInput')?.click());
    }

    if (easyModeSourceToggleBtn) {
        easyModeSourceToggleBtn.addEventListener('click', () => {
            document.getElementById('sourceToggleButton')?.click();
        });
    }
    
    if (easyModePanelToggleBtn) {
        easyModePanelToggleBtn.addEventListener('click', () => {
            if (document.body.classList.contains('easy-mode-active')) {
                visualizerCasilla.appendChild(sourceControlsCasilla);
                sourceControlsCasilla.classList.toggle('floating');
            }
        });
    }
    
    if (easyModeMicSelect) {
        easyModeMicSelect.addEventListener('change', (e) => {
            const mainMicSelect = document.getElementById('micSelect');
            if (mainMicSelect) {
                mainMicSelect.value = e.target.value;
                mainMicSelect.dispatchEvent(new Event('change', { bubbles: true }));
            }
        });
    }

    document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && document.body.classList.contains('easy-mode-active')) {
            toggleEasyMode();
        }
    });
    // --- FIN LÓGICA MODO FÁCIL ---

    // --- CONEXIONES PARA CONTROLES DE MODO FÁCIL ---
    console.log("Conectando controles de Modo Fácil...");

    const easyModeRecordBtn = document.getElementById('easyModeRecordBtn');
    const easyModeAppendBtn = document.getElementById('easyModeAppendBtn');
    const easyModeOverdubBtn = document.getElementById('easyModeOverdubBtn');
    const easyModeClearBtn = document.getElementById('easyModeClearBtn');
    const easyModeRecordMasterBtn = document.getElementById('easyModeRecordMasterBtn');
    const easyModePlayMasterBtn = document.getElementById('easyModePlayMasterBtn');
    
    // 1. Botón principal de Grabación / Parada del buffer
    if (easyModeRecordBtn) {
        easyModeRecordBtn.addEventListener('click', () => {
            // Verificamos si ya se está grabando. El botón de stop original
            // es la mejor manera de saberlo: si no está deshabilitado, es que se está grabando.
            const isRecording = !document.getElementById('stopRecBtn').disabled;
            if (isRecording) {
                document.getElementById('stopRecBtn').click();
            } else {
                document.getElementById('recordBtn').click();
            }
        });
    }

    // 2. Otros botones de control del buffer
    if (easyModeAppendBtn) easyModeAppendBtn.addEventListener('click', () => document.getElementById('appendRecBtn').click());
    if (easyModeOverdubBtn) easyModeOverdubBtn.addEventListener('click', () => document.getElementById('overdubNowBtn').click());
    if (easyModeClearBtn) easyModeClearBtn.addEventListener('click', () => document.getElementById('clearRecBtn').click());

    // 3. Botones de grabación y reproducción del Master
    if (easyModeRecordMasterBtn) {
        easyModeRecordMasterBtn.addEventListener('click', () => {
             document.getElementById('recordMasterBtn').click();
        });
    }
    if (easyModePlayMasterBtn) {
        easyModePlayMasterBtn.addEventListener('click', () => {
            // El botón original de "Play Grab." ya maneja la lógica de pausa,
            // por lo que podemos llamarlo siempre.
            document.getElementById('playMasterBufferBtn').click();
        });
    }

    const controlDefaults = {};
    function saveDefaults() {
        document.querySelectorAll('.dial').forEach(el => {
            controlDefaults[el.id] = { value: el.getAttribute('data-value'), type: 'dial' };
        });
        document.querySelectorAll('input[type="range"]').forEach(el => {
            controlDefaults[el.id] = { value: el.value, type: 'range' };
        });
        document.querySelectorAll('.toggle-switch-input').forEach(el => {
            controlDefaults[el.id] = { checked: el.checked, type: 'checkbox' };
        });
        console.log("Valores por defecto de controles guardados.");
    }
    saveDefaults();

    document.querySelectorAll('.dial').forEach(dialElement => { 
        try {
            initDial(dialElement);
        } catch(e) {
            console.error(`Failed to initialize dial ${dialElement.id}:`, e);
        }
    });
    
    document.querySelectorAll('input[type="range"]').forEach(rangeEl => {
        const rangeId = rangeEl.id;
        let numberInputEl;
        if (document.getElementById(rangeId + 'ValueInput')) {
            numberInputEl = document.getElementById(rangeId + 'ValueInput');
        } else if (rangeId.startsWith('speedControl')) {
            numberInputEl = document.getElementById(rangeId.replace('Control', 'Value'));
        }
        
        const originalInputHandler = () => {
            if(numberInputEl) {
                const rStep = parseFloat(rangeEl.step);
                const numDecimalsAttr = numberInputEl.dataset.decimals || rangeEl.dataset.decimals;
                const numDecimals = numDecimalsAttr ?
                               parseInt(numDecimalsAttr) :
                               (rStep.toString().includes('.') ? rStep.toString().split('.')[1].length : 0);
                const valNum = parseFloat(rangeEl.value);
                numberInputEl.value = isNaN(valNum) ? '' : valNum.toFixed(numDecimals);
            }
            if(window.recordAutomationEvent) {
                window.recordAutomationEvent(rangeEl.id, parseFloat(rangeEl.value));
            }
        };

        if (numberInputEl) {
            const rMin = parseFloat(rangeEl.min);
            const rMax = parseFloat(rangeEl.max);
            const rStep = parseFloat(rangeEl.step);
            
            numberInputEl.min = rMin;
            numberInputEl.max = rMax;
            numberInputEl.step = rStep;
            originalInputHandler(); 

            rangeEl.addEventListener('input', originalInputHandler);
            
            numberInputEl.addEventListener('change', (e) => {
                let val = parseFloat(e.target.value);
                if (isNaN(val)) {
                    val = parseFloat(rangeEl.value);
                } else {
                    val = Math.min(rMax, Math.max(rMin, val));
                    val = Math.round(val / rStep) * rStep;
                }
                if (parseFloat(rangeEl.value) !== val) {
                    rangeEl.value = val;
                    rangeEl.dispatchEvent(new Event('input', { bubbles: true }));
                }
            });
        } else {
             rangeEl.addEventListener('input', originalInputHandler);
        }
    });

    document.querySelectorAll('button.mappable').forEach(btn => {
        if (!btn.id.startsWith('memBtn')) {
            btn.addEventListener('click', () => {
                if (window.recordAutomationEvent) {
                    window.recordAutomationEvent(btn.id, 'click');
                }
            });
        }
    });

    document.querySelectorAll('.toggle-switch-input').forEach(toggle => {
        toggle.addEventListener('change', () => {
            if (window.recordAutomationEvent) {
                window.recordAutomationEvent(toggle.id, toggle.checked);
            }
        });
    });

    const dropZoneTriggerEl = document.getElementById('dropZoneTrigger');
    const audioFileInputEl = document.getElementById('audioFileInput');
    if (dropZoneTriggerEl && audioFileInputEl) {
        dropZoneTriggerEl.addEventListener('click', () => { audioFileInputEl.click(); });
        dropZoneTriggerEl.addEventListener('dragover', (event) => { event.preventDefault(); event.dataTransfer.dropEffect = 'copy'; });
        dropZoneTriggerEl.addEventListener('drop', (event) => {
            event.preventDefault();
            if (event.dataTransfer.files && event.dataTransfer.files.length > 0) {
                audioFileInputEl.files = event.dataTransfer.files;
                audioFileInputEl.dispatchEvent(new Event('change', { bubbles: true }));
            }
        });
    }
    
    // Sincronización Volumen Master
    const masterVolFader = document.getElementById('masterVolumeFader');
    const easyModeMasterVolFader = document.getElementById('easyModeMasterVolume');
    const masterVolValueDisplaySpan = document.getElementById('masterVolumeValue');
    
    function syncMasterVolume(newValue, sourceElement) {
        const newV = parseFloat(newValue);
        if (window.syncAudioMasterVolume) { // Llama a la función global en el script de audio
            window.syncAudioMasterVolume(newV);
        }

        if (sourceElement !== masterVolFader) masterVolFader.value = newV;
        if (sourceElement !== easyModeMasterVolFader) easyModeMasterVolFader.value = newV;

        if (masterVolValueDisplaySpan) {
            const dB = newV > 0 ? (20 * Math.log10(newV)).toFixed(1) : '-∞';
            masterVolValueDisplaySpan.textContent = `${dB} dB`;
        }
    }
    
    masterVolFader.addEventListener('input', (e) => syncMasterVolume(e.target.value, masterVolFader));
    easyModeMasterVolFader.addEventListener('input', (e) => syncMasterVolume(e.target.value, easyModeMasterVolFader));

    // Inicializar valor
    syncMasterVolume(masterVolFader.value, masterVolFader);


    const togglePatchBayBtn = document.getElementById('togglePatchBayBtn');
    const patchBayCasilla = document.getElementById('patch-bay-casilla');
    const routingPatchBayCasilla = document.getElementById('routing-patch-bay-casilla');
    if (togglePatchBayBtn && patchBayCasilla && routingPatchBayCasilla) {
        togglePatchBayBtn.addEventListener('click', () => {
            patchBayCasilla.classList.toggle('visible');
            routingPatchBayCasilla.classList.toggle('visible');
        });
        
        makeDraggable(patchBayCasilla, patchBayCasilla.querySelector('.drag-handle'));
        makeDraggable(routingPatchBayCasilla, routingPatchBayCasilla.querySelector('.drag-handle'));

        document.querySelectorAll('.close-btn').forEach(button => {
            button.addEventListener('click', () => {
                button.closest('.casilla').classList.remove('visible');
            });
        });
    }

    document.addEventListener('click', (e) => {
        if (!e.altKey) return;

        let target = e.target;
        if (target.classList.contains('dial-indicator')) {
            target = target.closest('.dial');
        }

        const id = target.id;
        if (id && controlDefaults[id]) {
            e.preventDefault();
            e.stopPropagation();

            const defaultConfig = controlDefaults[id];
            console.log(`Reseteando ${id} a su valor por defecto.`);

            if (defaultConfig.type === 'dial' && window.localUpdateDialParamProgrammatic) {
                window.localUpdateDialParamProgrammatic(target, parseFloat(defaultConfig.value));
            } else if (defaultConfig.type === 'range' && window.localUpdateRangeParamProgrammatic) {
                window.localUpdateRangeParamProgrammatic(target, parseFloat(defaultConfig.value));
            } else if (defaultConfig.type === 'checkbox') {
                if (target.checked !== defaultConfig.checked) {
                    target.checked = defaultConfig.checked;
                    target.dispatchEvent(new Event('change', { bubbles: true }));
                }
            }
        }
    }, true);
    
});

(function(){
    console.log("SUSPIRA Audio Logic Initializing...");
    
    let animationWorker;
    let audioWorker; // NUEVO: Worker para Flex Pitch
    let lastParticleData = null;
    let offscreenCanvas = document.createElement('canvas');
    let offscreenCtx = offscreenCanvas.getContext('2d');

    if (window.Worker) {
        animationWorker = new Worker('worker.js');

        animationWorker.onmessage = function(e) {
            lastParticleData = e.data;
        };
        
        animationWorker.postMessage({ type: 'init' });

        // NUEVO: Inicialización y listener para el worker de audio
        audioWorker = new Worker('audio-worker.js');
        audioWorker.onmessage = function(event) {
            const { processedBufferChannels, sampleRate, cacheKey } = event.data;
            if (!processedBufferChannels) return;

            const loopIndex = parseInt(cacheKey.split('_')[0]);
            if (isNaN(loopIndex)) return;

            try {
                const newBuffer = audioContext.createBuffer(processedBufferChannels.length, processedBufferChannels[0].length, sampleRate);
                for(let i = 0; i < processedBufferChannels.length; i++) {
                    newBuffer.getChannelData(i).set(processedBufferChannels[i]);
                }

                if (flexPitchCache[loopIndex]) {
                    flexPitchCache[loopIndex][cacheKey] = newBuffer;
                    console.log(`Flex Pitch para el loop ${loopIndex + 1} procesado por worker y cacheado.`);
                    
                    // Si el loop está sonando, reiniciarlo para usar el nuevo buffer cacheado
                    if (isLoopRealtimePlaying[loopIndex]) {
                        stopLoopRealtimePlayback(loopIndex, true); // true para evitar cambiar el texto del botón
                        startLoopRealtimePlayback(loopIndex);
                    }
                }
            } catch (e) {
                console.error("Error reconstruyendo buffer desde el worker:", e);
            }
        };

    } else {
        console.error("Tu navegador no soporta Web Workers. La animación de partículas y Flex Pitch estarán desactivadas o tendrán bajo rendimiento.");
    }

    let audioContext;
    let gainNode;
    let micGainNode, micBooster;
    let masterGain;
    let finalOutputGain;
    let granulatorVolumeGain, granulatorFilter;
    let granulatorPitchBend = 0;
    
    let dryBus, wetBus;
    let filePlayerDrySend, filePlayerWetSend;
    let micDrySend, micWetSend;
    let granulatorDrySend, granulatorWetSend;
    let spectralSynthDrySend, spectralSynthWetSend;
    let loopDrySends = [], loopWetSends = [];

    let granulatorLFO, granulatorLFOGain;
    let loopVolumeGains = [];
    
    let sourceSidechainSendGain;
    let loopSidechainSendGains = [];
    let sidechainSummingGain, sidechainAnalyserNode, sidechainModulationNode;
    let sidechainEnvelopeDataArray;
    let isSidechainEnvelopeProcessingActive = false;
    let sidechainThresholdValue = -24, sidechainAttackTime = 0.01, sidechainReleaseTime = 0.1, sidechainModulationAmount = 1000;
    let sidechainSmoothedEnvelope = 0, sidechainAnimationRequest = null;
    
    let mediaStream, currentSourceNode;
    let audioBuffer = null;
    let loadedAudioFileName = null; // NUEVO: para guardar el nombre del archivo
    let isMainPlayerPlaying = false;
    let mainPlayerStartOffset = 0, mainPlayerStartTime = 0, mainPlayerDuration = 0;
    let currentMicChannelIndex = 0;

    let mainRecordingStreamDestinationNode, mainAudioRecorder, mainRecordedChunks = [];
    let recordSourceMixer;
    let isRecorderSetup = false;

    let mainRecorderAudioBuffer = null, mainRecorderAudioBufferId = 0;

    // OPTIMIZACIÓN DE LOOPS: Buffers dedicados
    let loopDedicatedBuffers = [null, null, null];
    let loopReversedBuffersCache = [null, null, null]; // Cache para buffers invertidos

    let flexPitchCache = [{}, {}, {}];
    window.currentAudioSourceType = 'file';
    let currentRecordingMode = "";
    
    let granulatorTimeoutId = null;
    let isGranulatorRunning = false;
    
    const SPECTRAL_FILTER_COUNT = 25;
    let spectralFilterBank = [];
    let spectralSynthInputGain, spectralSynthVolumeGain, spectralSynthBoostGain, spectralSynthBooster;
    let isSpectralSynthActive = false;
    let spectralSynthTimeoutId = null;
    let currentSpectralSynthSource = null;
    let lastSpectralCoords = { x: -1, y: -1, active: false };
    const SPECTRAL_MIN_FREQ = 20;
    const SPECTRAL_MAX_FREQ = 20000;
    let isDrawingPath = false;
    let drawnPaths = [[]];
    let pathPlaybackRequestID = null;
    let pathPlaybackIndex = 0;
    let isDrawModeActive = true; 

    let samplerGrainPoints = [
        { x: 0.50, y: 0.5, active: true, isMain: true },
        { x: 0.25, y: 0.5, active: false, isMain: false },
        { x: 0.40, y: 0.5, active: false, isMain: false },
        { x: 0.60, y: 0.5, active: false, isMain: false },
        { x: 0.75, y: 0.5, active: false, isMain: false }
    ];
    let selectedGrainPointIndex = -1;
    let isDraggingGrainPoint = false;

    let masterRecordedAudioBuffer = null, masterBufferSourceNode = null;
    let masterOutputRecorder, masterRecordedChunksForMaster = [];
    let isMasterRecordingPlaying = false, masterRecordingStartTime = 0, masterRecordingStartOffset = 0;
    
    let isMainPlayerLoopEnabled = false;
    let isMicMuted = false;
    let loopZoomLevels = [1, 1, 1], loopPanOffsets = [0, 0, 0], loopIsDraggingForPan = [false, false, false], loopPanLastMouseX = [0, 0, 0];
    let loopPlaybackAnimationIds = [false, false, false];
    let loopPlaybackStartTimes = [0, 0, 0], loopNextStartTimeoutId = [null, null, null];
    
    const PLAY_SYMBOL = "▶", PAUSE_SYMBOL = "⏸", STOP_SYMBOL = "■", LOOP_ACTIVE_COLOR = "green";

    let sampleSelections = [{start: 0, end: 0}, {start: 0, end: 0}, {start: 0, end: 0}];
    let isSelectingSampleFlags = [false, false, false];
    let activeSamplers = [null, null, null];

    let sparklesArray;
    let analyserWet, analyserDry;
    let frequencyDataWet, frequencyDataDry, frequencyHistory;
    let selectedBand = null, selectedBandIndex = -1;
    let isQAdjusting = false;
    const glowColor = 'rgba(255, 0, 150, 0.8)';
    const HISTORY_LENGTH = 25;
    const visualBands = [
        { f_low: 60,   f_high: 300,   name: '60-300Hz' },
        { f_low: 300,  f_high: 800,   name: '300-800Hz' },
        { f_low: 800,  f_high: 1000,  name: '800-1kHz' },
        { f_low: 1000, f_high: 2000,  name: '1-2kHz' },
        { f_low: 2000, f_high: 4000,  name: '2-4kHz' },
        { f_low: 4000, f_high: 8000,  name: '4-8kHz' },
        { f_low: 8000, f_high: 16000, name: '8-16kHz' },
    ];
    let eqBandInstances = [];
    let eqBandDefaults = [];
    
    let masterAnimationFrameId = null;
    let visualizerLastRenderTime = 0;
    const RENDER_FPS = 30;
    const renderInterval = 1000 / RENDER_FPS;
    let isAnimationEnabled = true;

    let convolverNode, dryGainNode_reverb, wetGainNode_reverb, inputGainNode_reverb, reverbBooster;
    let reverbSizeDialEl, reverbDryWetDialEl;
    const NUM_EQ_BANDS = 7;
    
    const spectrumCanvas = document.getElementById('spectrumCanvas');
    let spectrumCanvasCtx;
    const loaderOverlay = document.getElementById('loader-overlay');

    let isMidiMapping = false;
    let elementToMap = null;
    let midiMap = {};
    let lastCCValues = {};

    let automationMemories = [null, null, null, null];
    let automationPlaybackStates = [
        { isPlaying: false, loopId: null, startTime: 0, eventIndex: 0 },
        { isPlaying: false, loopId: null, startTime: 0, eventIndex: 0 },
        { isPlaying: false, loopId: null, startTime: 0, eventIndex: 0 },
        { isPlaying: false, loopId: null, startTime: 0, eventIndex: 0 }
    ];
    let armedAutomationSlot = -1;
    let isRecordingAutomation = false;
    let automationRecordingStartTime = 0;
    let tempAutomationSequence = [];
    let memBtnLastClickTime = [0, 0, 0, 0];
    const memButtons = [
        document.getElementById("memBtn1"), document.getElementById("memBtn2"),
        document.getElementById("memBtn3"), document.getElementById("memBtn4")
    ];

    const sourceToggleButton = document.getElementById('sourceToggleButton');
    const micSelect = document.getElementById('micSelect'), micPanel = document.getElementById('micPanel');
    const filePanel = document.getElementById('filePanel'), channelSelect = document.getElementById('channelSelect');
    const micMuteBtn = document.getElementById('micMuteBtn');
    const micVolumeFader = document.getElementById('micVolumeFader');

    const playPauseBtn = document.getElementById('playPauseBtn'), timeline = document.getElementById('timeline');
    const currentTimeDisplay = document.getElementById('currentTimeDisplay');
    const volumeFader = document.getElementById('volumeFader');

    const recordBtn = document.getElementById('recordBtn'), stopRecBtn = document.getElementById('stopRecBtn');
    const appendRecBtn = document.getElementById('appendRecBtn'), overdubNowBtn = document.getElementById('overdubNowBtn');
    const clearRecBtn = document.getElementById('clearRecBtn'), recordedWaveformCanvas = document.getElementById('recordedWaveform');
    
    const overlapDialEl = document.getElementById('overlapDial');
    const grainLengthDialEl = document.getElementById('grainLengthDial');
    const granulatorFilterFreqEl = document.getElementById('granulatorFilterFreq');
    const pitchBendDialEl = document.getElementById('pitchBendDial');
    
    const granulatorPlayToggleBtn = document.getElementById('granulatorPlayToggleBtn');
    const toggleGranulatorFilterBtn = document.getElementById('toggleGranulatorFilterBtn');
    
    const granulatorLfoSpeedFader = document.getElementById('granulatorLfoSpeed');
    const granulatorLfoDepthFader = document.getElementById('granulatorLfoDepth');
    const lfoPowerSwitch = document.getElementById('lfoPowerSwitch');
    
    const granulatorVolumeFader = document.getElementById('granulatorVolume');
    const audioFileInput = document.getElementById('audioFileInput');
    
    const spectralSynthPowerSwitch = document.getElementById('spectralSynthPowerSwitch');
    const spectralSynthVolumeFader = document.getElementById('spectralSynthVolume');
    const spectralSynthDrawModeSwitch = document.getElementById('spectralSynthDrawModeSwitch');
    const clearDrawingBtn = document.getElementById('clearDrawingBtn');
    const undoDrawingBtn = document.getElementById('undoDrawingBtn');
    const saveSessionBtn = document.getElementById('saveSessionBtn');
    const animationPowerSwitch = document.getElementById('animationPowerSwitch');

    const sidechainEnvelopePowerSwitch = document.getElementById('sidechainEnvelopePowerSwitch');
const sidechainThresholdDialEl = document.getElementById('sidechainThresholdDial');
const sidechainAttackDialEl = document.getElementById('sidechainAttackDial');
const sidechainReleaseDialEl = document.getElementById('sidechainReleaseDial');
const sidechainAmountDialEl = document.getElementById('sidechainAmountDial');

    const sourceSidechainSendSwitches = document.querySelectorAll('.source-sidechain-switch');

    const loopSidechainSendSwitches = [
        document.getElementById('loop1SidechainSendSwitch'),
        document.getElementById('loop2SidechainSendSwitch'),
        document.getElementById('loop3SidechainSendSwitch')
    ];
    
    const loopToggleBtn = document.getElementById('loopToggleBtn');
    const exportToBuffersBtn = document.getElementById('exportToBuffersBtn');
    const loopCanvases = [document.getElementById('loopCanvas1'), document.getElementById('loopCanvas2'), document.getElementById('loopCanvas3')];
    let loopSelections = [{start: 0, end: 1}, {start: 0, end: 1}, {start: 0, end: 1}];
    let loopIsSelectingFlags = [false, false, false];
    
    const loopSpeedControls = [document.getElementById('speedControl1'), document.getElementById('speedControl2'), document.getElementById('speedControl3')];
    
    const loopPlayPauseBtns = [document.getElementById('loopPlayPauseBtn1'), document.getElementById('loopPlayPauseBtn2'), document.getElementById('loopPlayPauseBtn3')];
    const loopVolumeFaders = [document.getElementById('loopVolume1'), document.getElementById('loopVolume2'), document.getElementById('loopVolume3')];

    const loopZoomInBtns = document.querySelectorAll('.zoom-in-btn'), loopZoomOutBtns = document.querySelectorAll('.zoom-out-btn');
    
    const masterVolumeFaderEl = document.getElementById('masterVolumeFader');
    const masterVolumeValueDisplay = document.getElementById('masterVolumeValue');
    
    const recordMasterBtnEl = document.getElementById('recordMasterBtn');
    const playMasterBufferBtnEl = document.getElementById('playMasterBufferBtn');
    const pauseMasterBufferBtnEl = document.getElementById('pauseMasterBufferBtn');
    const downloadMasterBtnEl = document.getElementById('downloadMasterBtn');
    
    const masterTimelineFader = document.getElementById('masterTimeline');
    const masterCurrentTimeDisplay = document.getElementById('masterCurrentTime'), masterDurationDisplay = document.getElementById('masterDuration');
    
    const stateButtons = [document.getElementById("stateBtn1"),document.getElementById("stateBtn2"),document.getElementById("stateBtn3"),document.getElementById("stateBtn4")];
    let savedStates = [null, null, null, null], statePressTimes = [0, 0, 0, 0];

    const patchableParameterIds = ['granulatorLfoSpeed', 'grainPosFader', 'granulatorFilterFreq', 'pitchBendDial', 'reverbSizeDial', 'reverbDryWetDial'];
    let patchParametersInfo = {};
    let patchMappings = {};
    let isPatchBayActive = false;

    // --- NUEVAS FUNCIONES Y LÓGICA PARA GUARDAR/CARGAR SESIÓN ---
    function showSaveModal() {
        const overlay = document.createElement('div');
        overlay.id = 'save-modal-overlay';

        const date = new Date();
        const defaultFilename = `suspira_session_${date.getFullYear()}${(date.getMonth() + 1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}_${date.getHours().toString().padStart(2, '0')}${date.getMinutes().toString().padStart(2, '0')}`;

        overlay.innerHTML = `
            <div id="save-modal-container">
                <label for="session-filename">Nombre del Archivo de Sesión:</label>
                <input type="text" id="session-filename" value="${defaultFilename}">
                <div id="save-modal-buttons">
                    <button id="cancel-save-btn">Cancelar</button>
                    <button id="confirm-save-btn">Descargar</button>
                </div>
            </div>
        `;
        document.body.appendChild(overlay);

        document.getElementById('cancel-save-btn').addEventListener('click', hideSaveModal);
        document.getElementById('confirm-save-btn').addEventListener('click', () => {
            const filename = document.getElementById('session-filename').value;
            saveSession(filename);
        });
        overlay.addEventListener('click', (e) => {
            if (e.target.id === 'save-modal-overlay') {
                hideSaveModal();
            }
        });
    }

    function hideSaveModal() {
        const overlay = document.getElementById('save-modal-overlay');
        if (overlay) {
            document.body.removeChild(overlay);
        }
    }

    async function saveSession(filename = 'session') {
        console.log("Iniciando guardado de sesión...");
        showLoader("Guardando sesión...");

        try {
            const stateBlob = new Blob([JSON.stringify(getCurrentAppState())], { type: 'application/json' });
            
            const audioBlobs = [];
            const toc = {
                parts: [
                    { name: 'appState', type: 'application/json', size: stateBlob.size }
                ]
            };

            if (mainRecorderAudioBuffer) {
                const wavBlob = audioBufferToWavBlob(mainRecorderAudioBuffer);
                audioBlobs.push(wavBlob);
                toc.parts.push({ name: 'mainRecorderAudioBuffer', type: 'audio/wav', size: wavBlob.size });
            }
            if (masterRecordedAudioBuffer) {
                const wavBlob = audioBufferToWavBlob(masterRecordedAudioBuffer);
                audioBlobs.push(wavBlob);
                toc.parts.push({ name: 'masterRecordedAudioBuffer', type: 'audio/wav', size: wavBlob.size });
            }

            const tocString = JSON.stringify(toc);
            const tocBlob = new Blob([tocString], { type: 'application/json' });
            
            // Header: 8 bytes (64-bit unsigned integer) para guardar el tamaño de la TOC
            const header = new ArrayBuffer(8);
            new BigUint64Array(header)[0] = BigInt(tocBlob.size);
            const headerBlob = new Blob([header]);

            // Ensamblar el archivo final
            const finalBlob = new Blob([headerBlob, tocBlob, stateBlob, ...audioBlobs]);
            
            const downloadUrl = URL.createObjectURL(finalBlob);
            const anchor = document.createElement('a');
            anchor.style.display = 'none';
            anchor.href = downloadUrl;
            anchor.download = `${filename.replace(/\.suspira$/, '')}.suspira`;
            document.body.appendChild(anchor);
            anchor.click();

            document.body.removeChild(anchor);
            URL.revokeObjectURL(downloadUrl);
            console.log("Sesión guardada exitosamente.");

        } catch (error) {
            console.error("Error al guardar la sesión:", error);
            alert("Ocurrió un error al guardar la sesión.");
        } finally {
            hideLoader();
            hideSaveModal();
        }
    }
    
    async function loadSessionFromFile(file) {
        console.log("Iniciando carga de sesión...");
        showLoader("Cargando sesión...");

        loadedAudioFileName = file.name; // Guardar nombre de archivo de sesión

        const reader = new FileReader();
        reader.onload = async (event) => {
            try {
                const fullFileBlob = new Blob([event.target.result]);

                // 1. Leer el Header para obtener el tamaño de la Tabla de Contenidos (TOC)
                const headerBuffer = await fullFileBlob.slice(0, 8).arrayBuffer();
                const tocSize = new BigUint64Array(headerBuffer)[0];

                // 2. Leer y parsear la TOC
                const tocBlob = fullFileBlob.slice(8, 8 + Number(tocSize));
                const toc = JSON.parse(await tocBlob.text());

                if (!toc.parts || !toc.parts.find(p => p.name === 'appState')) {
                    throw new Error("El archivo no parece ser una sesión válida de SUSPIRA (TOC inválida).");
                }

                let offset = 8 + Number(tocSize);
                let appState = null;
                const audioBuffers = {};

                // 3. Usar la TOC para "rebanar" el archivo y procesar cada parte
                for (const part of toc.parts) {
                    const partBlob = fullFileBlob.slice(offset, offset + part.size);
                    offset += part.size;

                    if (part.name === 'appState') {
                        appState = JSON.parse(await partBlob.text());
                    } else if (part.type === 'audio/wav') {
                        const arrayBuffer = await partBlob.arrayBuffer();
                        if (arrayBuffer.byteLength > 44) { 
                           audioBuffers[part.name] = await audioContext.decodeAudioData(arrayBuffer);
                        } else {
                           audioBuffers[part.name] = null;
                        }
                    }
                }

                if (!appState) {
                    throw new Error("No se encontró el estado de la aplicación en el archivo de sesión.");
                }
                
                // 4. Asignar los buffers de audio reconstruidos
                mainRecorderAudioBuffer = audioBuffers['mainRecorderAudioBuffer'] || null;
                masterRecordedAudioBuffer = audioBuffers['masterRecordedAudioBuffer'] || null;
                
                // CORRECCIÓN 2: Asignar el audio cargado al reproductor de fuente y actualizar su UI.
                if (mainRecorderAudioBuffer) {
                    audioBuffer = mainRecorderAudioBuffer;
                    mainPlayerDuration = audioBuffer.duration;
                    if (timeline) { timeline.max = mainPlayerDuration; }
                    if (exportToBuffersBtn) exportToBuffersBtn.disabled = false;
                    if (playPauseBtn) playPauseBtn.disabled = false;
                    if (!appState.loadedAudioFileName) { // Si el estado guardado no tenía el nombre, usar el del archivo de sesión
                        loadedAudioFileName = file.name;
                    }
                }


                // 5. Recrear los buffers de loop dedicados a partir del buffer principal y las selecciones guardadas
                 for(let i = 0; i < 3; i++) {
                     const selection = appState.loopRegionSelections[i];
                     if (mainRecorderAudioBuffer && selection && selection.end > selection.start) {
                         loopDedicatedBuffers[i] = extractAudioBufferSegment(
                             mainRecorderAudioBuffer, selection.start, selection.end, audioContext
                         );
                     } else {
                        loopDedicatedBuffers[i] = null;
                     }
                }

                // 6. Aplicar todo el estado de la UI
                applySavedAppState(appState);
                
                // 7. Actualizar visualizaciones y estados finales
                updateAllVisualsFromState(); // <--- CORRECCIÓN 1 y 2
                if (masterRecordedAudioBuffer) {
                    masterDurationDisplay.textContent = formatTime(masterRecordedAudioBuffer.duration);
                    masterTimelineFader.max = masterRecordedAudioBuffer.duration;
                }
                updateMasterRecordingTimelineDisplay(true);
                updateMainPlayerTimelineDisplay(true);


                console.log("Sesión cargada exitosamente.");

            } catch (error) {
                console.error("Error al cargar la sesión:", error);
                alert("Error al cargar el archivo de sesión. Puede estar corrupto o no ser compatible.");
            } finally {
                hideLoader();
            }
        };

        reader.onerror = () => {
             alert("No se pudo leer el archivo.");
             hideLoader();
        };

        reader.readAsArrayBuffer(file);
    }
    
    // Funciones auxiliares para mostrar/ocultar el loader
    function showLoader(message) {
        const loader = document.querySelector('#reverb-eq-visualizer-casilla .loader-overlay');
        if (loader) {
            const p = loader.querySelector('p');
            if (p) p.textContent = message;
            loader.classList.remove('hidden');
        }
    }

    function hideLoader() {
        const loader = document.querySelector('#reverb-eq-visualizer-casilla .loader-overlay');
        if (loader) loader.classList.add('hidden');
    }
    // --- FIN DE LÓGICA PARA GUARDAR/CARGAR SESIÓN ---


    // Función global para sincronizar el volumen master desde la UI
    window.syncAudioMasterVolume = function(value) {
        if (finalOutputGain && audioContext) {
            finalOutputGain.gain.setTargetAtTime(value, audioContext.currentTime, 0.01);
        }
    }

    class EQBand {
        constructor(initialAngle, neutralRadius, centerX, centerY) {
            this.angle = initialAngle;
            this.distance = neutralRadius;
            this.x = centerX + Math.cos(this.angle) * this.distance;
            this.y = centerY + Math.sin(this.angle) * this.distance;
            this.q = 1.41;
            this.drawRadius = 5 + 20 / this.q;
            this.interactionRadius = this.drawRadius;
            this.color = 'rgba(255, 255, 255, 0.08)';
            this.wetLevel = 0;
            this.dryLevel = 0;
            this.filterNode = null; 
        }

        createFilter() {
            if (audioContext && !this.filterNode) {
                this.filterNode = audioContext.createBiquadFilter();
                this.filterNode.type = 'peaking';
                this.filterNode.Q.value = this.q;
            }
        }

        updateFilter(centerX, centerY, neutralRadius) {
            if (!this.filterNode) return;
            const dx = this.x - centerX;
            const dy = this.y - centerY;
            this.distance = Math.sqrt(dx * dx + dy * dy);
            this.angle = Math.atan2(dy, dx);
            let normalizedAngle = (this.angle + Math.PI) / (2 * Math.PI);
            const minFreq = 20, maxFreq = 20000;
            const freqRange = Math.log(maxFreq / minFreq);
            const frequency = minFreq * Math.exp(freqRange * normalizedAngle);
            this.filterNode.frequency.setTargetAtTime(frequency, audioContext.currentTime, 0.01);
            const maxGain = 18.0;
            const gain = ((this.distance - neutralRadius) / (neutralRadius * 0.8)) * maxGain;
            const clampedGain = Math.max(-maxGain, Math.min(maxGain, gain));
            this.filterNode.gain.setTargetAtTime(clampedGain, audioContext.currentTime, 0.01);
            this.filterNode.Q.setTargetAtTime(this.q, audioContext.currentTime, 0.01);
            this.drawRadius = 5 + 20 / this.q;
            this.interactionRadius = this.drawRadius;
        }

        draw() {
            if (!spectrumCanvasCtx) return;
            spectrumCanvasCtx.beginPath();
            spectrumCanvasCtx.arc(this.x, this.y, this.drawRadius, 0, Math.PI * 2);

            if (isMidiMapping) {
                spectrumCanvasCtx.strokeStyle = 'rgba(255, 0, 255, 0.8)';
            } else {
                spectrumCanvasCtx.strokeStyle = this.color;
            }
            
            spectrumCanvasCtx.lineWidth = 2;
            spectrumCanvasCtx.stroke();
            spectrumCanvasCtx.beginPath();
            spectrumCanvasCtx.arc(this.x, this.y, 2, 0, Math.PI * 2);
            spectrumCanvasCtx.fillStyle = this.color;
            spectrumCanvasCtx.fill();
        }
    }

    class Sparkle {
        constructor(angle, brightness) {
            this.angle = angle; this.brightness = brightness;
            this.lifespan = 1.0;
            this.radius = 2 + (brightness * 8 * 0.6); 
            
            const centerX = spectrumCanvas.width / 2;
            const centerY = spectrumCanvas.height / 2;
            const cloudRadius = Math.min(spectrumCanvas.width, spectrumCanvas.height) / 3.0;
            let dist;
            do {
                this.x = Math.random() * spectrumCanvas.width;
                this.y = Math.random() * spectrumCanvas.height;
                const dx = this.x - centerX;
                const dy = this.y - centerY;
                dist = Math.sqrt(dx * dx + dy * dy);
            } while (dist < cloudRadius);
        }
        updateAndDraw() {
            if (!spectrumCanvasCtx) return;
            this.lifespan -= 0.04;
            if (this.lifespan <= 0) return;
            const currentRadius = this.radius * this.lifespan;
            const currentOpacity = this.brightness * this.lifespan;
            spectrumCanvasCtx.beginPath();
            spectrumCanvasCtx.arc(this.x, this.y, currentRadius * 0.5, 0, Math.PI * 2);
            spectrumCanvasCtx.fillStyle = `rgba(255, 255, 255, ${currentOpacity * 0.7})`;
            spectrumCanvasCtx.fill();
            const rayLength = currentRadius * 2.5;
            spectrumCanvasCtx.lineWidth = Math.max(1, currentRadius * 0.3);
            spectrumCanvasCtx.strokeStyle = `rgba(255, 200, 255, ${currentOpacity * 0.5 * 0.7})`;
            spectrumCanvasCtx.beginPath();
            spectrumCanvasCtx.moveTo(this.x - rayLength, this.y); spectrumCanvasCtx.lineTo(this.x + rayLength, this.y);
            spectrumCanvasCtx.moveTo(this.x, this.y - rayLength); spectrumCanvasCtx.lineTo(this.x, this.y + rayLength);
            spectrumCanvasCtx.stroke();
        }
    }
    
    window.localUpdateDialParamProgrammatic = function(dialElement, newValue) {
        if (!dialElement) return;
        const min = parseFloat(dialElement.getAttribute('data-min'));
        const max = parseFloat(dialElement.getAttribute('data-max'));
        const step = parseFloat(dialElement.getAttribute('data-step'));
        
        const dataDecimalsAttr = dialElement.getAttribute('data-decimals');
        const finalDecimals = dataDecimalsAttr ? parseInt(dataDecimalsAttr) : (step.toString().includes('.') ? step.toString().split('.')[1].length : 0);
        
        let clampedValue = Math.min(max, Math.max(min, newValue));
        clampedValue = Math.round(clampedValue / step) * step;

        const indicator = dialElement.querySelector('.dial-indicator');
        const displayInput = dialElement.parentElement.querySelector('input[type="number"].dial-value-input');
        const angleMin = -135, angleMax = 135;
        
        const percent = (max - min === 0) ? 0 : (clampedValue - min) / (max - min);
        const angle = angleMin + percent * (angleMax - angleMin);
        
        if (indicator) indicator.style.transform = `translateX(-50%) rotate(${angle}deg)`;
        if (displayInput) {
            let numericValue = parseFloat(clampedValue.toFixed(finalDecimals));
            displayInput.value = numericValue;
        }
        dialElement.setAttribute('data-value', clampedValue);
        dialElement.setAttribute('aria-valuenow', clampedValue);
        dialElement.dispatchEvent(new CustomEvent('dialChange', { bubbles: true, detail: { value: clampedValue } }));
    }
    
    window.localUpdateRangeParamProgrammatic = function(rangeElement, newValue) {
        if (!rangeElement) return;
        const min = parseFloat(rangeElement.min);
        const max = parseFloat(rangeElement.max);
        const step = parseFloat(rangeElement.step);
        
        const numberInputEl = document.getElementById(rangeElement.id + 'ValueInput') ||
                              (rangeElement.id.startsWith('speedControl') ? document.getElementById(rangeElement.id.replace('Control', 'Value')) : null);

        const dataDecimalsAttr = numberInputEl ? numberInputEl.dataset.decimals : rangeElement.dataset.decimals;
        const finalDecimals = dataDecimalsAttr ? parseInt(dataDecimalsAttr) : (step.toString().includes('.') ? step.toString().split('.')[1].length : 0);

        let clampedValue = Math.min(max, Math.max(min, newValue));
        clampedValue = Math.round(clampedValue / step) * step;

        rangeElement.value = clampedValue;

        if (numberInputEl) {
            numberInputEl.value = parseFloat(clampedValue).toFixed(finalDecimals);
        }
        rangeElement.dispatchEvent(new Event('input', { bubbles: true }));
    }
    
    function updateParameterProgrammatically(paramId, value) {
        if (paramId.startsWith('eq_band_')) {
            const index = parseInt(paramId.split('_')[2]);
            if (eqBandInstances[index] && typeof value === 'object') {
                const band = eqBandInstances[index];
                band.x = value.x;
                band.y = value.y;
                band.q = value.q;
                band.updateFilter(spectrumCanvas.width / 2, spectrumCanvas.height / 2, Math.min(spectrumCanvas.width, spectrumCanvas.height) / 3.5);
            }
            return;
        }

        if (paramId.startsWith('granulator_point_')) {
            const index = parseInt(paramId.split('_')[2]);
            if (samplerGrainPoints[index] && typeof value === 'number') {
                samplerGrainPoints[index].x = value;
                drawMainRecordedWaveform();
            }
            return;
        }
        
        const el = document.getElementById(paramId);
        if(!el) {
            console.warn(`Automation playback: Element with ID "${paramId}" not found.`);
            return;
        }

        if (value === 'click') {
            el.click();
            return;
        }

        if (typeof value === 'boolean' && (el.type === 'checkbox' || el.classList.contains('toggle-switch-input') || el.classList.contains('loop-action-btn'))) {
            const currentState = el.type === 'checkbox' ? el.checked : el.getAttribute('aria-pressed') === 'true';
            if(currentState !== value) {
               el.click();
            }
            return;
        }
        
        if (paramId === 'grainPosFader') {
            if (samplerGrainPoints && samplerGrainPoints.length > 0) {
                const mainPoint = samplerGrainPoints.find(p => p.isMain);
                if (mainPoint) {
                    const min = 0, max = 1;
                    let clampedValue = Math.min(max, Math.max(min, value));
                    mainPoint.x = clampedValue;
                    drawMainRecordedWaveform();
                }
            }
            return;
        }

        if (el.classList.contains('dial')) {
            localUpdateDialParamProgrammatic(el, value);
        } else if (el.type === 'range') {
            localUpdateRangeParamProgrammatic(el, value);
        }
    }
   
    function triggerSpectralSynthFromSparkle(frequency, intensity, duration) {
        if (!audioContext || !mainRecorderAudioBuffer || !spectralSynthPowerSwitch.checked) return;

        if (currentSpectralSynthSource) {
            try { currentSpectralSynthSource.stop(0); } catch(e) {}
        }

        const grainLength = 0.1; 
        const bufferDuration = mainRecorderAudioBuffer.duration;
        let startPosition = Math.random() * (bufferDuration - grainLength);
        
        const source = audioContext.createBufferSource();
        source.buffer = mainRecorderAudioBuffer;

        const envelope = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        
        filter.type = 'bandpass';
        filter.frequency.value = frequency;
        filter.Q.value = 50;

        source.connect(filter);
        filter.connect(envelope);
        envelope.connect(spectralSynthBooster);

        const now = audioContext.currentTime;
        const peakTime = now + (duration * 0.2);
        const endTime = now + duration;
        
        envelope.gain.setValueAtTime(0, now);
        envelope.gain.linearRampToValueAtTime(intensity, peakTime);
        envelope.gain.linearRampToValueAtTime(0, endTime);
        
        source.start(now, startPosition, grainLength);
        currentSpectralSynthSource = source;
        source.onended = () => {
            if (currentSpectralSynthSource === source) currentSpectralSynthSource = null;
            try {
                source.disconnect();
                filter.disconnect();
                envelope.disconnect();
            } catch(e) {}
        };
    }

    function reverb_generateImpulseResponse(aCtx,durS,decR){
        const sR=aCtx.sampleRate,len=sR*durS,imp=aCtx.createBuffer(2,len,sR),iL=imp.getChannelData(0),iR=imp.getChannelData(1);
        for(let i=0;i<len;i++){const e=Math.pow(1-i/len,decR);iL[i]=(Math.random()*2-1)*e;iR[i]=(Math.random()*2-1)*e;} return imp;
    }
    function reverb_updateReverbSize() {
        if (!audioContext || !convolverNode || !reverbSizeDialEl) return;
        const size = parseFloat(reverbSizeDialEl.getAttribute('data-value'));
        const minDecay = 1.5, maxDecay = 3.0, normalizedSize = (size - 0.1) / (6 - 0.1);
        const decayRate = maxDecay - normalizedSize * (maxDecay - minDecay);
        try { convolverNode.buffer = reverb_generateImpulseResponse(audioContext, size, decayRate); }
        catch (e) { console.error("Error generating impulse response:", e); }
    }
    function reverb_updateDryWetMix() {
        if (!dryGainNode_reverb || !wetGainNode_reverb || !audioContext || !reverbDryWetDialEl) return;
        const mixValue = parseFloat(reverbDryWetDialEl.getAttribute('data-value'));
        dryGainNode_reverb.gain.setTargetAtTime(Math.cos(mixValue * 0.5 * Math.PI), audioContext.currentTime, 0.01);
        wetGainNode_reverb.gain.setTargetAtTime(Math.sin(mixValue * 0.5 * Math.PI), audioContext.currentTime, 0.01);
    }
    function reverb_setupReverbControls() {
        reverbSizeDialEl = document.getElementById('reverbSizeDial');
        reverbDryWetDialEl = document.getElementById('reverbDryWetDial');
        if(reverbSizeDialEl) reverbSizeDialEl.addEventListener('dialChange', reverb_updateReverbSize);
        if(reverbDryWetDialEl) reverbDryWetDialEl.addEventListener('dialChange', reverb_updateDryWetMix);
    }
    
    function drawInitialMessage(msg="Carga un archivo de audio para ver el espectro."){
        if(!spectrumCanvasCtx)return;
        spectrumCanvasCtx.fillStyle='rgb(0,0,0)'; // CAMBIO: Fondo negro
        spectrumCanvasCtx.fillRect(0,0,spectrumCanvas.width,spectrumCanvas.height);
        spectrumCanvasCtx.fillStyle="white";
        spectrumCanvasCtx.textAlign="center";
        spectrumCanvasCtx.font="1rem Arial";
        spectrumCanvasCtx.fillText(msg,spectrumCanvas.width/2,spectrumCanvas.height/2);
    }
    function drawDrawnPaths(ctx, width, height) {
        if (drawnPaths.length === 0 || drawnPaths.flat().length === 0) return;
        
        const radius = height * 0.035;

        for (const path of drawnPaths) {
            if (path.length === 0) continue;
            for (const point of path) {
                const x = point.x * width;
                const y = point.y * height;
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, 'rgba(255, 0, 255, 0.9)');
                gradient.addColorStop(1, 'rgba(255, 0, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    function drawSpectralSynthVisuals() {
        if (!spectrumCanvasCtx || !spectralSynthPowerSwitch.checked) return;

        if (lastSpectralCoords.active && isDrawModeActive) {
            const x = lastSpectralCoords.x * spectrumCanvas.width;
            const y = lastSpectralCoords.y * spectrumCanvas.height;
            const radius = spectrumCanvas.height * 0.035;
            const gradient = spectrumCanvasCtx.createRadialGradient(x, y, 0, x, y, radius);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            spectrumCanvasCtx.fillStyle = gradient;
            spectrumCanvasCtx.beginPath();
            spectrumCanvasCtx.arc(x, y, radius, 0, Math.PI * 2);
            spectrumCanvasCtx.fill();
        }
    }

    function initParticleSystem() {
        sparklesArray = [];
    }

    function initEQBands() {
        if (!spectrumCanvas) return;
        const centerX = spectrumCanvas.width/2, centerY = spectrumCanvas.height/2;
        const neutralRadius = Math.min(spectrumCanvas.width, spectrumCanvas.height) / 3.5;
        eqBandInstances = [];
        eqBandDefaults = [];
        for (let i = 0; i < NUM_EQ_BANDS; i++) {
            const angle = (i / NUM_EQ_BANDS) * Math.PI * 2 - Math.PI / 2;
            const newBandInstance = new EQBand(angle, neutralRadius, centerX, centerY);
            eqBandInstances.push(newBandInstance);
            eqBandDefaults.push({ x: newBandInstance.x, y: newBandInstance.y, q: newBandInstance.q });
        }
    }

    function getResonanceData(freq) {
        const totalHours = 12, totalAngle = Math.PI * 2;
        let hour = 0, sectorIndex = -1;
        for (let i = 0; i < visualBands.length; i++) {
            if (freq >= visualBands[i].f_low && freq < visualBands[i].f_high) {
                sectorIndex = i; break;
            }
        }
        if (sectorIndex === -1) return null;
        
        if (freq <= 300)   hour = (freq - 60) / 240 * 2;
        else if (freq <= 800)  hour = 2 + (freq - 300) / 500 * 2;
        else if (freq <= 1000) hour = 4 + (freq - 800) / 200 * 2;
        else if (freq <= 2000) hour = 6 + (freq - 1000) / 1000 * 2;
        else if (freq <= 8000) hour = 8 + (freq - 2000) / 6000 * 3;
        else if (freq <= 16000)hour = 11 + (freq - 8000) / 8000 * 1;
        else return null;

        const angle = ((hour - 3) / totalHours) * totalAngle;
        return { angle, sectorIndex };
    }

    function analyzeFrequencies() {
        if (!analyserWet || !analyserDry) return 0;
        
        analyserWet.getByteFrequencyData(frequencyDataWet);
        analyserDry.getByteFrequencyData(frequencyDataDry);
        
        if (frequencyHistory.length >= HISTORY_LENGTH) {
            const averages = frequencyHistory[0].map((_, i) => 
                frequencyHistory.reduce((sum, frame) => sum + frame[i], 0) / HISTORY_LENGTH
            );
            const binToFreq = audioContext.sampleRate / analyserWet.fftSize;
            let sparklesScheduledThisFrame = 0;
            const SPARKLE_LIMIT = 15;

            for (let i = 0; i < frequencyDataWet.length; i++) {
                const currentVal = frequencyDataWet[i], avgVal = averages[i];
                if (currentVal > avgVal * 2.8 && currentVal > 80) {
                    const freq = i * binToFreq;
                    const resonanceData = getResonanceData(freq);
                    if (resonanceData) {
                        if ((sparklesArray.length + sparklesScheduledThisFrame) < SPARKLE_LIMIT) {
                            const brightness = Math.min((currentVal - avgVal) / 100, 1.0);
                            setTimeout(() => {
                                sparklesArray.push(new Sparkle(resonanceData.angle, brightness));
                            }, Math.random() * 200);
                            sparklesScheduledThisFrame++;
                            triggerSpectralSynthFromSparkle(freq, brightness, 1.0);
                        }
                    }
                }
            }
            frequencyHistory.shift(); 
        }
        frequencyHistory.push(new Uint8Array(frequencyDataWet));

        const binToFreq = audioContext.sampleRate / analyserWet.fftSize;
        const bandsLevelsWet = new Array(NUM_EQ_BANDS).fill(0).map(() => ({ total: 0, count: 0 }));
        const bandsLevelsDry = new Array(NUM_EQ_BANDS).fill(0).map(() => ({ total: 0, count: 0 }));

        for (let i = 0; i < frequencyDataWet.length; i++) {
            const freq = i * binToFreq;
            for (let j = 0; j < visualBands.length; j++) {
                 if (freq >= visualBands[j].f_low && freq < visualBands[j].f_high) {
                    bandsLevelsWet[j].total += frequencyDataWet[i]; bandsLevelsWet[j].count++;
                    bandsLevelsDry[j].total += frequencyDataDry[i]; bandsLevelsDry[j].count++;
                    break;
                }
            }
        }

        eqBandInstances.forEach((band, index) => {
             const levelDataWet = bandsLevelsWet[index];
             const levelDataDry = bandsLevelsDry[index];
             band.wetLevel = levelDataWet.count > 0 ? (levelDataWet.total/levelDataWet.count)/255 : 0;
             band.dryLevel = levelDataDry.count > 0 ? (levelDataDry.total/levelDataDry.count)/255 : 0;
        });

        eqBandInstances.forEach((band, index) => { 
            band.wetLevel *= 2;
            if (index >= eqBandInstances.length - 2) {
                band.wetLevel *= 1.20;
            }
            band.dryLevel *= 2;
            if (band.wetLevel > 1.0) band.wetLevel = 1.0;
            if (band.dryLevel > 1.0) band.dryLevel = 1.0;
        });
    }
    
    function animateVisualizer() {
        if (!isAnimationEnabled) {
             if (masterAnimationFrameId) {
                cancelAnimationFrame(masterAnimationFrameId);
                masterAnimationFrameId = null;
            }
            spectrumCanvasCtx.clearRect(0, 0, spectrumCanvas.width, spectrumCanvas.height);
            return;
        }

        spectrumCanvasCtx.fillStyle = 'rgba(0, 0, 0, 0.4)'; // CAMBIO: Fondo negro con un poco de alpha para estela
        spectrumCanvasCtx.fillRect(0, 0, spectrumCanvas.width, spectrumCanvas.height);

        analyzeFrequencies();

        if (animationWorker && eqBandInstances.length > 0) {
            const bandsData = eqBandInstances.map(b => ({
                x: b.x, y: b.y, wetLevel: b.wetLevel, dryLevel: b.dryLevel
            }));
            animationWorker.postMessage({ type: 'update', payload: { eqBands: bandsData } });
        }
        
        drawDrawnPaths(spectrumCanvasCtx, spectrumCanvas.width, spectrumCanvas.height);
        
        if (lastParticleData) {
            spectrumCanvasCtx.globalCompositeOperation = 'destination-out';
            
            spectrumCanvasCtx.lineWidth = 2.5; // A bit thicker for a better erase effect
            spectrumCanvasCtx.beginPath();
            for (let i = 0; i < lastParticleData.lines.length; i += 5) {
                const opacity = Math.min(lastParticleData.lines[i+4], 1.0);
                if (opacity > 0.05) {
                    spectrumCanvasCtx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                    spectrumCanvasCtx.moveTo(lastParticleData.lines[i], lastParticleData.lines[i+1]);
                    spectrumCanvasCtx.lineTo(lastParticleData.lines[i+2], lastParticleData.lines[i+3]);
                }
            }
            spectrumCanvasCtx.stroke();
            
            spectrumCanvasCtx.globalCompositeOperation = 'source-over';
        }

        if (lastParticleData) {
            spectrumCanvasCtx.strokeStyle = 'rgba(100, 100, 100, 0.65)';
            spectrumCanvasCtx.lineWidth = 1;
            spectrumCanvasCtx.shadowBlur = 0;
            spectrumCanvasCtx.beginPath();
            for (let i = 0; i < lastParticleData.shadowLines.length; i += 5) {
                spectrumCanvasCtx.moveTo(lastParticleData.shadowLines[i], lastParticleData.shadowLines[i+1]);
                spectrumCanvasCtx.lineTo(lastParticleData.shadowLines[i+2], lastParticleData.shadowLines[i+3]);
            }
            spectrumCanvasCtx.stroke();

            spectrumCanvasCtx.lineWidth = 1.5;
            spectrumCanvasCtx.shadowBlur = 15;
            spectrumCanvasCtx.shadowColor = glowColor;
            spectrumCanvasCtx.beginPath();
            for (let i = 0; i < lastParticleData.lines.length; i += 5) {
                let opacity = lastParticleData.lines[i+4];
                opacity = Math.pow(opacity, 0.75) * 1.5;
                opacity = Math.min(opacity, 1.0);

                if (opacity > 0.05) {
                    spectrumCanvasCtx.strokeStyle = `rgba(255,0,150,${opacity})`;
                    spectrumCanvasCtx.moveTo(lastParticleData.lines[i], lastParticleData.lines[i+1]);
                    spectrumCanvasCtx.lineTo(lastParticleData.lines[i+2], lastParticleData.lines[i+3]);
                }
            }
            spectrumCanvasCtx.stroke();
            spectrumCanvasCtx.shadowBlur = 0;
        }
        
        for (let i = sparklesArray.length - 1; i >= 0; i--) {
            const s = sparklesArray[i];
            s.updateAndDraw();
            if (s.lifespan <= 0) { sparklesArray.splice(i, 1); }
        }

        if(eqBandInstances) eqBandInstances.forEach(b => b.draw());
        drawSpectralSynthVisuals();
    }
    
    window.handleEasyModeEnter = function() {
        if (spectralSynthPowerSwitch && spectralSynthPowerSwitch.checked && mainRecorderAudioBuffer && isDrawModeActive && !isSpectralSynthActive) {
            if (spectrumCanvas && spectrumCanvas.matches(':hover')) {
                startSpectralSynth();
            }
        }
    };

    function setupCanvasEventListeners() {
        if (!spectrumCanvas) return;

        if(saveSessionBtn) {
            saveSessionBtn.addEventListener('click', showSaveModal);
        }

        // --- Lógica de carga por Drag & Drop para sesiones ---
        spectrumCanvas.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        });

        spectrumCanvas.addEventListener('drop', (e) => {
            e.preventDefault();
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (file.name.endsWith('.suspira')) {
                    loadSessionFromFile(file);
                } else if (file.type.startsWith('audio/')) {
                    audioFileInput.files = files;
                    audioFileInput.dispatchEvent(new Event('change', { bubbles: true }));
                }
            }
        });
        // --- Fin de la lógica de carga ---

        if(animationPowerSwitch) {
            animationPowerSwitch.addEventListener('change', (e) => {
                isAnimationEnabled = e.target.checked;
                 if (isAnimationEnabled && !masterAnimationFrameId) {
                    masterRenderLoop();
                }
            });
        }
        
        spectrumCanvas.addEventListener('mousedown', (e) => {
            if (!audioContext || e.button !== 0) return;

            const rect = spectrumCanvas.getBoundingClientRect();
            const scaleX = spectrumCanvas.width / rect.width;
            const scaleY = spectrumCanvas.height / rect.height;
            const clientX = (e.clientX - rect.left) * scaleX;
            const clientY = (e.clientY - rect.top) * scaleY;
            
            if (!eqBandInstances) return;

            for (let i = 0; i < eqBandInstances.length; i++) {
                const band = eqBandInstances[i];
                const dx = band.x - clientX;
                const dy = band.y - clientY;
                if (Math.sqrt(dx * dx + dy * dy) < band.interactionRadius) {
                    
                    if (e.altKey) {
                        const defaultState = eqBandDefaults[i];
                        if (defaultState) {
                            band.x = defaultState.x;
                            band.y = defaultState.y;
                            band.q = defaultState.q;
                            band.updateFilter(spectrumCanvas.width / 2, spectrumCanvas.height / 2, Math.min(spectrumCanvas.width, spectrumCanvas.height) / 3.5);
                        }
                        e.preventDefault();
                        e.stopPropagation();
                        return;
                    }

                    if (isMidiMapping) {
                        if (elementToMap && elementToMap.element) elementToMap.element.classList.remove('control-listening');
                        elementToMap = { id: `eq_band_${i}`, element: band }; 
                        console.log(`Escuchando MIDI para la Banda de EQ ${i}`);
                        
                        return;
                    }

                    selectedBand = band;
                    selectedBandIndex = i;
                    isQAdjusting = e.metaKey || e.ctrlKey;
                    return;
                }
            }
            
            if (spectralSynthPowerSwitch && spectralSynthPowerSwitch.checked && mainRecorderAudioBuffer && isDrawModeActive) {
                stopPathPlayback();
                isDrawingPath = true;
                if(drawnPaths.length > 0 && drawnPaths[drawnPaths.length-1].length > 0 && drawnPaths[drawnPaths.length-1].some(p => p.x)) {
                   drawnPaths.push([]);
                } else if (drawnPaths.length === 0 || (drawnPaths.length === 1 && drawnPaths[0].length === 0)) {
                   drawnPaths = [[]];
                }
                console.log("[SYNTH-MODE] Modo de Dibujo: Iniciado.");
                return;
            }
        });

        window.addEventListener('mousemove', (e) => {
            const rect = spectrumCanvas.getBoundingClientRect();
            const scaleX = spectrumCanvas.width / rect.width;
            const scaleY = spectrumCanvas.height / rect.height;
            const clientX = (e.clientX - rect.left) * scaleX;
            const clientY = (e.clientY - rect.top) * scaleY;

            if (selectedBand) {
                const centerX = spectrumCanvas.width / 2;
                const centerY = spectrumCanvas.height / 2;
                const neutralRadius = Math.min(spectrumCanvas.width, spectrumCanvas.height) / 3.5;
                if (isQAdjusting) {
                    const deltaY = e.movementY;
                    selectedBand.q -= deltaY * 0.1;
                    selectedBand.q = Math.max(0.1, Math.min(30, selectedBand.q));
                } else {
                    selectedBand.x = clientX;
                    selectedBand.y = clientY;
                }
                selectedBand.updateFilter(centerX, centerY, neutralRadius);
                
                if (window.recordAutomationEvent && armedAutomationSlot !== -1) {
                    const bandState = { x: selectedBand.x, y: selectedBand.y, q: selectedBand.q };
                    window.recordAutomationEvent(`eq_band_${selectedBandIndex}`, bandState);
                }
                return;
            }

            if (!spectralSynthPowerSwitch.checked) return;
            
            lastSpectralCoords = { x: clientX / spectrumCanvas.width, y: clientY / spectrumCanvas.height, active: true }; 
            
            if (isDrawingPath) {
                 const time = performance.now();
                 const lastPath = drawnPaths[drawnPaths.length - 1];
                 if(lastPath) lastPath.push({ x: lastSpectralCoords.x, y: lastSpectralCoords.y, time });
                 updateSpectralSynthFilters();
                 if (!isSpectralSynthActive) {
                    startSpectralSynth();
                 }
            }
             
            if (isSpectralSynthActive && !isDrawingPath && pathPlaybackRequestID === null && isDrawModeActive) {
                updateSpectralSynthFilters();
            }
        });

        window.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                 if (isDrawingPath) {
                    isDrawingPath = false;
                    const lastPath = drawnPaths[drawnPaths.length - 1];
                    console.log(`[SYNTH-MODE] Modo de Dibujo: Finalizado. Grabados ${lastPath ? lastPath.length : 0} puntos en el último trazo.`);
                    if (lastPath && lastPath.length > 1) {
                        startPathPlayback();
                    } else {
                        if (!spectrumCanvas.matches(':hover')) {
                            stopSpectralSynth();
                        }
                    }
                }
                if (selectedBand) {
                    selectedBand = null;
                    selectedBandIndex = -1;
                }
                isQAdjusting = false;
            }
        });
        
        spectrumCanvas.addEventListener('mouseleave', () => {
             if (isSpectralSynthActive) {
                stopSpectralSynth();
                lastSpectralCoords.active = false;
                console.log("[SYNTH-MODE] Modo Flotante: Detenido (ratón fuera del lienzo).");
            }
        });

        spectrumCanvas.addEventListener('contextmenu', e => e.preventDefault());
    }

    async function tryGetDeviceSampleRate(devId){try{const c={audio:{video:false}};if(devId&&devId!=="default")c.audio.deviceId={exact:devId};const s=await navigator.mediaDevices.getUserMedia(c),t=s.getAudioTracks()[0];let sR=t?.getSettings()?.sampleRate;s.getTracks().forEach(tr=>tr.stop());if(sR)return sR;}catch(err){}return undefined;}

    function masterRenderLoop(currentTime) {
        masterAnimationFrameId = requestAnimationFrame(masterRenderLoop);

        if (currentTime - visualizerLastRenderTime < renderInterval) {
            return;
        }
        visualizerLastRenderTime = currentTime;

        animateVisualizer();
        updateMainPlayerTimelineDisplay();
        updateMasterRecordingTimelineDisplay();
        
        for (let i = 0; i < 3; i++) {
            updateLoopCanvasPlayhead(i);
        }
    }
    
    function updateLoopCanvasPlayhead(loopIndex) {
        if (!isLoopRealtimePlaying[loopIndex] || !loopDedicatedBuffers[loopIndex]) { // Usa el buffer dedicado para saber si hay algo que reproducir
            if (loopPlaybackAnimationIds[loopIndex]) {
                loopPlaybackAnimationIds[loopIndex] = false; 
                drawLoopWaveformVisuals(loopIndex, -1);
            }
            return;
        }
        loopPlaybackAnimationIds[loopIndex] = true;

        const selection = loopSelections[loopIndex];
        const speed = parseFloat(loopSpeedControls[loopIndex].value);
        const isReversed = loopReverseBtns[loopIndex].getAttribute('aria-pressed') === 'true';
        
        // La duración del loop ahora es la del buffer dedicado
        let loopDuration = loopDedicatedBuffers[loopIndex].duration;
        if (loopDuration <= 0) loopDuration = 1;

        const elapsedTime = audioContext.currentTime - loopPlaybackStartTimes[loopIndex];
        const scaledElapsedTime = elapsedTime * speed;
        const currentPosInLoop = (scaledElapsedTime % loopDuration) / loopDuration;
        
        let finalProgress = currentPosInLoop;
        if(isReversed) {
            finalProgress = 1.0 - currentPosInLoop;
        }
        
        // La posición de la cabeza lectora se calcula sobre el buffer principal para el dibujado
        const playheadPositionInBuffer = selection.start + finalProgress * (selection.end - selection.start);
        
        drawLoopWaveformVisuals(loopIndex, playheadPositionInBuffer);
    }

    function initializeAudioOnFirstInteraction() {
        const startButton = document.getElementById('startButton');
        const loadingOverlay = document.getElementById('loading-overlay');

        function resumeContext() {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log("AudioContext resumed successfully by user interaction.");
                    if(loadingOverlay) {
                        loadingOverlay.style.opacity = '0';
                        setTimeout(() => loadingOverlay.style.display = 'none', 500);
                    }
                });
            } else if (audioContext) {
                 if(loadingOverlay) {
                    loadingOverlay.style.opacity = '0';
                    setTimeout(() => loadingOverlay.style.display = 'none', 500);
                }
            }
        }
        
        startButton.addEventListener('click', resumeContext);
    }


    window.addEventListener('load', async () => {
        if(typeof SoundTouch==='undefined'||typeof SimpleFilter==='undefined')console.warn("SoundTouchJS no parece estar cargado. Flex Pitch no funcionará correctamente sin el worker.");
        
        let targetSampleRate; 
        await initAudioDevicesList();
        
        if(micSelect.options.length > 0 && micSelect.options[0].value && micSelect.options[0].value !== "" && micSelect.options[0].value !== "No hay micrófonos" && micSelect.options[0].value !== "Error al listar"){
            const firstMicId = micSelect.options[0].value;
            targetSampleRate = await tryGetDeviceSampleRate(firstMicId);
        } else {
            targetSampleRate = await tryGetDeviceSampleRate("default");
        }
        
        try{
            let contextOptions={};
            if(targetSampleRate) contextOptions.sampleRate = targetSampleRate;
            audioContext = new(window.AudioContext || window.webkitAudioContext)(contextOptions);
            if(targetSampleRate && audioContext.sampleRate !== targetSampleRate) console.warn(`ADVERTENCIA: Tasa de muestreo solicitada ${targetSampleRate}Hz, pero AudioContext usa ${audioContext.sampleRate}Hz.`);
            console.log("AudioContext creado con sampleRate:", audioContext.sampleRate);
        } catch(e) {
            console.error("Error crítico al crear AudioContext:",e);
            alert("Error al inicializar el motor de audio. Intentando con config por defecto.");
            try {
                audioContext=new(window.AudioContext||window.webkitAudioContext)();
                console.log("AudioContext creado con sampleRate (fallback):", audioContext.sampleRate);
            } catch(e2) {
                console.error("Error crítico al crear AudioContext (fallback):",e2);
                alert("No se pudo inicializar el motor de audio. La aplicación no funcionará.");
                return;
            }
        }
        
        initializeAudioOnFirstInteraction();

        if(spectrumCanvas){
            spectrumCanvasCtx=spectrumCanvas.getContext('2d');
            offscreenCanvas.width = spectrumCanvas.width;
            offscreenCanvas.height = spectrumCanvas.height;
            offscreenCtx = offscreenCanvas.getContext('2d');

            function resizeCanvas() {
                const oldWidth = spectrumCanvas.width;
                const oldHeight = spectrumCanvas.height;
                const oldCenterX = oldWidth / 2;
                const oldCenterY = oldHeight / 2;
                const oldNeutralRadius = Math.min(oldWidth, oldHeight) / 3.5 || 1;

                let bandStates = [];
                if (eqBandInstances && eqBandInstances.length > 0) {
                    bandStates = eqBandInstances.map(band => ({
                        angle: Math.atan2(band.y - oldCenterY, band.x - oldCenterX),
                        distanceRatio: Math.sqrt(Math.pow(band.x - oldCenterX, 2) + Math.pow(band.y - oldCenterY, 2)) / oldNeutralRadius,
                        q: band.q
                    }));
                }

                const dpr = window.devicePixelRatio || 1;
                const rect = spectrumCanvas.getBoundingClientRect();
                
                let renderScale = 1.0;
                if (document.body.classList.contains('easy-mode-active')) {
                    renderScale = 0.75; 
                }

                spectrumCanvas.width = rect.width * dpr * renderScale;
                spectrumCanvas.height = rect.height * dpr * renderScale;
                
                offscreenCanvas.width = spectrumCanvas.width;
                offscreenCanvas.height = spectrumCanvas.height;

                if (animationWorker) {
                    animationWorker.postMessage({
                        type: 'resize',
                        payload: {
                            width: spectrumCanvas.width,
                            height: spectrumCanvas.height
                        }
                    });
                }

                const newCenterX = spectrumCanvas.width / 2;
                const newCenterY = spectrumCanvas.height / 2;
                const newNeutralRadius = Math.min(spectrumCanvas.width, spectrumCanvas.height) / 3.5;

                initEQBands();
                initParticleSystem();

                if (audioContext && eqBandInstances) {
                    eqBandInstances.forEach(band => band.createFilter());
                }
                
                if (bandStates.length > 0) {
                    eqBandInstances.forEach((band, i) => {
                        const state = bandStates[i];
                        if (state) {
                            const newDistance = state.distanceRatio * newNeutralRadius;
                            band.x = newCenterX + Math.cos(state.angle) * newDistance;
                            band.y = newCenterY + Math.sin(state.angle) * newDistance;
                            band.q = state.q;
                        }
                    });
                }
                
                createMainAudioChain();

                if(eqBandInstances) {
                    eqBandInstances.forEach(b => b.updateFilter(newCenterX, newCenterY, newNeutralRadius));
                }
                if (!masterAnimationFrameId) { drawInitialMessage(); }
            }
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        } else console.error("Spectrum canvas no encontrado!");

        gainNode = audioContext.createGain();
        micGainNode = audioContext.createGain();
        micBooster = audioContext.createGain();
        micBooster.gain.value = 1.15;
        masterGain = audioContext.createGain();
        finalOutputGain = audioContext.createGain();
        finalOutputGain.gain.value = 1.0;
        recordSourceMixer = audioContext.createGain();
        recordSourceMixer.gain.value = 1.0;
        dryBus = audioContext.createGain();
        dryBus.gain.value = 1.0; // El dry bus ahora está a volumen completo
        wetBus = audioContext.createGain();
        filePlayerDrySend = audioContext.createGain();
        filePlayerWetSend = audioContext.createGain();
        micDrySend = audioContext.createGain();
        micWetSend = audioContext.createGain();
        granulatorDrySend = audioContext.createGain();
        granulatorWetSend = audioContext.createGain();
        spectralSynthDrySend = audioContext.createGain();
        spectralSynthWetSend = audioContext.createGain();
        for (let i = 0; i < 3; i++) {
            loopDrySends.push(audioContext.createGain());
            loopWetSends.push(audioContext.createGain());
        }
        sourceSidechainSendGain = audioContext.createGain();
        sourceSidechainSendGain.gain.value = 0.0;
        loopVolumeGains=loopVolumeFaders.map((f,i)=>{const g=audioContext.createGain();g.gain.value=f?parseFloat(f.value):1;return g;});
        for(let i=0;i<3;i++){
            const sG=audioContext.createGain();
            sG.gain.value = loopSidechainSendSwitches[i].checked ? 1.0 : 0.0;
            loopSidechainSendGains.push(sG);
        }
        sidechainSummingGain = audioContext.createGain();
        sidechainAnalyserNode = audioContext.createAnalyser();
        sidechainAnalyserNode.fftSize = 256;
        sidechainAnalyserNode.smoothingTimeConstant = 0.1;
        sidechainEnvelopeDataArray = new Uint8Array(sidechainAnalyserNode.frequencyBinCount);
        sidechainModulationSource = audioContext.createConstantSource();
        sidechainModulationSource.offset.value = 1.0;
        sidechainModulationSource.start();
        sidechainModulationGain = audioContext.createGain();
        sidechainModulationGain.gain.value = 0;
        granulatorVolumeGain=audioContext.createGain();
        if(granulatorVolumeFader) granulatorVolumeGain.gain.value=parseFloat(granulatorVolumeFader.value); else granulatorVolumeGain.gain.value = 1;
        spectralSynthVolumeGain = audioContext.createGain();
        if(spectralSynthVolumeFader) spectralSynthVolumeGain.gain.value = parseFloat(spectralSynthVolumeFader.value); else spectralSynthVolumeGain.gain.value = 1;
        spectralSynthBooster = audioContext.createGain();
        spectralSynthBooster.gain.value = 1.35;
        spectralSynthBoostGain = audioContext.createGain();
        spectralSynthBoostGain.gain.value = 8.1; // Aumento del 35% (6.0 * 1.35)
        granulatorFilter=audioContext.createBiquadFilter();
        granulatorFilter.type="lowpass";
        granulatorFilter.Q.value=1;
        if(granulatorFilterFreqEl) {
             granulatorFilter.frequency.value = parseFloat(granulatorFilterFreqEl.getAttribute('data-value'));
        }
        inputGainNode_reverb=audioContext.createGain();
        dryGainNode_reverb=audioContext.createGain();
        wetGainNode_reverb=audioContext.createGain();
        reverbBooster = audioContext.createGain();
        reverbBooster.gain.value = 1.35;
        convolverNode=audioContext.createConvolver();
        analyserWet = audioContext.createAnalyser();
        analyserWet.fftSize = 2048;
        analyserWet.smoothingTimeConstant = 0.6;
        frequencyDataWet = new Uint8Array(analyserWet.frequencyBinCount);
        analyserDry = audioContext.createAnalyser();
        analyserDry.fftSize = 2048;
        analyserDry.smoothingTimeConstant = 0.6;
        frequencyDataDry = new Uint8Array(analyserDry.frequencyBinCount);
        frequencyHistory = [];
        
        eqBandInstances.forEach(band => band.createFilter());
        
        if (micMuteBtn) {
            micMuteBtn.addEventListener('click', () => {
                isMicMuted = !isMicMuted;
                micMuteBtn.setAttribute('aria-pressed', String(isMicMuted));
                if (micGainNode && audioContext) {
                    const newGain = isMicMuted ? 0 : parseFloat(micVolumeFader.value);
                    micGainNode.gain.setTargetAtTime(newGain, audioContext.currentTime, 0.01);
                }
            });
        }
        
        const setupAndStartRecording = (mode) => {
            if (!audioContext) return;
            if (audioContext.state === 'suspended') audioContext.resume();

            if (!isRecorderSetup) {
                setupMainAudioRecorder();
                isRecorderSetup = true;
            }

            if (!mainAudioRecorder) {
                console.error("MediaRecorder no está inicializado.");
                return;
            }

            mainRecordedChunks = [];
            currentRecordingMode = mode;
            try {
                mainAudioRecorder.start();
                enableRecordingButtons();
            } catch (e) {
                console.error(`Error al iniciar grabación en modo ${mode}:`, e);
                enableRecordingButtons();
            }
        };

        if (recordBtn) recordBtn.addEventListener('click', () => setupAndStartRecording("record"));
        if (appendRecBtn) appendRecBtn.addEventListener('click', () => { if(mainRecorderAudioBuffer) setupAndStartRecording("append"); });
        if (overdubNowBtn) overdubNowBtn.addEventListener('click', () => { if(mainRecorderAudioBuffer) setupAndStartRecording("overdub"); });
        
        if (playPauseBtn) playPauseBtn.addEventListener('click', togglePlayPauseFilePlayer);
        const maxChannels = 8;
        splitter = audioContext.createChannelSplitter(maxChannels);
        if (micVolumeFader) micVolumeFader.addEventListener('input', () => { if (micGainNode && audioContext) micGainNode.gain.setTargetAtTime(isMicMuted ? 0 : parseFloat(micVolumeFader.value), audioContext.currentTime, 0.01); });
        if (volumeFader) volumeFader.addEventListener('input', () => { if (gainNode && audioContext) gainNode.gain.setTargetAtTime(parseFloat(volumeFader.value), audioContext.currentTime, 0.01); });
        if (spectralSynthVolumeFader) spectralSynthVolumeFader.addEventListener('input', () => { if(spectralSynthVolumeGain) spectralSynthVolumeGain.gain.value = parseFloat(spectralSynthVolumeFader.value); });
        
        const easyModeGranulatorVolume = document.getElementById('easyModeGranulatorVolume');
        function syncGranulatorVolume(newValue) {
            if (granulatorVolumeGain && audioContext) {
                granulatorVolumeGain.gain.setTargetAtTime(newValue, audioContext.currentTime, 0.01);
            }
            if (granulatorVolumeFader.value !== newValue) granulatorVolumeFader.value = newValue;
            if (easyModeGranulatorVolume.value !== newValue) easyModeGranulatorVolume.value = newValue;
            document.getElementById('granulatorVolumeValueInput').value = parseFloat(newValue).toFixed(2);
        }
        granulatorVolumeFader.addEventListener('input', (e) => syncGranulatorVolume(e.target.value));
        easyModeGranulatorVolume.addEventListener('input', (e) => syncGranulatorVolume(e.target.value));


        const masterVolumeFader = document.getElementById('masterVolumeFader');
        if (masterVolumeFader) {
            masterVolumeFader.addEventListener('input', () => {
                // Esta lógica ahora está en el manejador `syncMasterVolume` en el script de UI.
            });
        }
        reverb_setupReverbControls();
        reverb_updateReverbSize();
        reverb_updateDryWetMix();
        setupCanvasEventListeners();
        setupSpectralSynthEventListeners();
        createSpectralSynthFilterBank();
        createMainAudioChain();
        setupAudioFileLoader();
        setupMasterRecorder();
        setupMidi();
        setupAutomationMemories();
        if (pitchBendDialEl) pitchBendDialEl.addEventListener('dialChange', (e) => { granulatorPitchBend = parseFloat(e.detail.value); });
        if (granulatorFilterFreqEl) granulatorFilterFreqEl.addEventListener('dialChange', (e) => { if (granulatorFilter) granulatorFilter.frequency.setTargetAtTime(parseFloat(e.detail.value), audioContext.currentTime, 0.01); });
        if (toggleGranulatorFilterBtn) toggleGranulatorFilterBtn.addEventListener('click', () => { if (granulatorFilter) { const newType = granulatorFilter.type === 'lowpass' ? 'highpass' : 'lowpass'; granulatorFilter.type = newType; toggleGranulatorFilterBtn.textContent = `Filtro: ${newType === 'lowpass' ? 'Lowpass' : 'Highpass'}`; } });
        patchableParameterIds.forEach(id => {
            const el = document.getElementById(id);
            if (id === 'grainPosFader') {
                patchParametersInfo[id] = { id, type: 'virtual', element: null, min: 0, max: 1, step: 0.01 };
                patchMappings[id] = { mouseX: false, mouseY: false };
                return;
            }
            if (el) {
                let type, min, max, step;
                if (el.classList.contains('dial')) { type = 'dial'; min = parseFloat(el.getAttribute('data-min')); max = parseFloat(el.getAttribute('data-max')); step = parseFloat(el.getAttribute('data-step')); }
                else if (el.type === 'range') { type = 'range'; min = parseFloat(el.min); max = parseFloat(el.max); step = parseFloat(el.step); }
                else { return; }
                patchParametersInfo[id] = { id, type, element: el, min, max, step };
                patchMappings[id] = { mouseX: false, mouseY: false };
            }
        });
        document.querySelectorAll('#patchBayGrid input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                const paramId = checkbox.dataset.paramId;
                const mouseAxis = checkbox.closest('tr').dataset.mouseAxis;
                if (patchMappings[paramId] && (mouseAxis === 'mouseX' || mouseAxis === 'mouseY')) patchMappings[paramId][mouseAxis] = checkbox.checked;
                isPatchBayActive = document.querySelectorAll('#patchBayGrid input[type="checkbox"]:checked').length > 0;
            });
        });
        document.addEventListener('mousemove', (event) => {
            if (isDrawingPath || !isPatchBayActive) return;
            const targetEl = event.target;
            const isUIElement = targetEl.tagName === 'INPUT' || targetEl.tagName === 'SELECT' || targetEl.tagName === 'BUTTON' || targetEl.closest('.dial');
            if (isUIElement && !targetEl.closest('#patchBayGrid')) return;
            const normalizedMouseX = event.clientX / window.innerWidth;
            const normalizedMouseY = 1.0 - (event.clientY / window.innerHeight);
            for (const paramId in patchMappings) {
                const mapping = patchMappings[paramId];
                const paramInfo = patchParametersInfo[paramId];
                if (!paramInfo || (!mapping.mouseX && !mapping.mouseY)) continue;
                let valueFromX = mapping.mouseX ? paramInfo.min + normalizedMouseX * (paramInfo.max - paramInfo.min) : null;
                let valueFromY = mapping.mouseY ? paramInfo.min + normalizedMouseY * (paramInfo.max - paramInfo.min) : null;
                let finalValue = (valueFromX !== null && valueFromY !== null) ? (valueFromX + valueFromY) / 2 : (valueFromX !== null ? valueFromX : valueFromY);
                if (finalValue !== null) {
                    if (paramId === 'grainPosFader') {
                        const mainPoint = samplerGrainPoints.find(p => p.isMain);
                        if (mainPoint) { mainPoint.x = finalValue; drawMainRecordedWaveform(); }
                    } else {
                        updateParameterProgrammatically(paramId, finalValue);
                    }
                }
            }
        });
        
        attachLoopCanvasEventsAll();
        setupGlobalKeyListeners();
        setupSidechainEventListeners();
        updateSourceButtonUIAfterDOMChange();
        toggleSourcePanels();
        const routingPatchBayGrid = document.getElementById('routingPatchBayGrid');
        if (routingPatchBayGrid) {
            const checkboxes = routingPatchBayGrid.querySelectorAll('input[type="checkbox"]');
            const nodeMap = { filePlayer: { dry: filePlayerDrySend, wet: filePlayerWetSend }, mic: { dry: micDrySend, wet: micWetSend }, granulator: { dry: granulatorDrySend, wet: granulatorWetSend }, spectralSynth: { dry: spectralSynthDrySend, wet: spectralSynthWetSend }, loop1: { dry: loopDrySends[0], wet: loopWetSends[0] }, loop2: { dry: loopDrySends[1], wet: loopWetSends[1] }, loop3: { dry: loopDrySends[2], wet: loopWetSends[2] } };
            checkboxes.forEach(checkbox => {
                const source = checkbox.dataset.source;
                const dest = checkbox.dataset.dest;
                const targetNode = nodeMap[source] ? nodeMap[source][dest] : null;
                if (targetNode) targetNode.gain.value = checkbox.checked ? 1.0 : 0.0;
                checkbox.addEventListener('change', (e) => { if (targetNode && audioContext) targetNode.gain.setTargetAtTime(e.target.checked ? 1.0 : 0.0, audioContext.currentTime, 0.01); });
            });
        }
        
        masterRenderLoop();
        console.log("SUSPIRA inicialización de UI y Audio completada.");
        loadInitialAudio('Output 1-2.wav');
    });
    function createSpectralSynthFilterBank() {
        if (!audioContext) return;
        spectralFilterBank = [];
        spectralSynthInputGain = audioContext.createGain();
        for (let i = 0; i < SPECTRAL_FILTER_COUNT; i++) {
            const filter = audioContext.createBiquadFilter();
            filter.type = 'bandpass';
            const logIndex = i / (SPECTRAL_FILTER_COUNT - 1);
            const freq = SPECTRAL_MIN_FREQ * Math.pow(SPECTRAL_MAX_FREQ / SPECTRAL_MIN_FREQ, logIndex);
            filter.frequency.value = freq;
            filter.Q.value = 50;
            const gainNode = audioContext.createGain();
            gainNode.gain.value = 0;
            spectralSynthInputGain.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(spectralSynthBoostGain);
            spectralFilterBank.push({ filter: filter, gainNode: gainNode });
        }
    }
    function createMainAudioChain() {
        if (!audioContext || !finalOutputGain) { console.error("Nodos de audio críticos no inicializados en createMainAudioChain"); return; }
        const nodesToClean = [ gainNode, micGainNode, micBooster, granulatorVolumeGain, spectralSynthVolumeGain, spectralSynthBooster, recordSourceMixer, inputGainNode_reverb, dryGainNode_reverb, wetGainNode_reverb, reverbBooster, convolverNode, finalOutputGain, sourceSidechainSendGain, sidechainSummingGain, sidechainAnalyserNode, sidechainModulationSource, sidechainModulationGain, analyserDry, analyserWet, dryBus, wetBus, filePlayerDrySend, filePlayerWetSend, micDrySend, micWetSend, granulatorDrySend, granulatorWetSend, spectralSynthDrySend, spectralSynthWetSend, granulatorFilter, ...loopVolumeGains, ...loopSidechainSendGains, ...loopDrySends, ...loopWetSends ];
        if (masterGain) nodesToClean.push(masterGain);
        eqBandInstances.forEach(band => { if (band && band.filterNode) nodesToClean.push(band.filterNode); });
        nodesToClean.forEach(node => { if (node && typeof node.disconnect === 'function') try { node.disconnect(); } catch (e) {} });
        
        if (spectralSynthBoostGain && spectralSynthVolumeGain) spectralSynthBoostGain.connect(spectralSynthVolumeGain);
        spectralSynthVolumeGain.connect(spectralSynthBooster);
        gainNode.connect(filePlayerDrySend);
        gainNode.connect(filePlayerWetSend);
        micGainNode.connect(micBooster);
        micBooster.connect(micDrySend);
        micBooster.connect(micWetSend);
        granulatorVolumeGain.connect(granulatorDrySend);
        granulatorVolumeGain.connect(granulatorWetSend);
        spectralSynthBooster.connect(spectralSynthDrySend);
        spectralSynthBooster.connect(spectralSynthWetSend);
        loopVolumeGains.forEach((loopVolGain, i) => { if (loopVolGain && loopDrySends[i] && loopWetSends[i]) { loopVolGain.connect(loopDrySends[i]); loopVolGain.connect(loopWetSends[i]); } });
        filePlayerDrySend.connect(dryBus); micDrySend.connect(dryBus); granulatorDrySend.connect(dryBus); spectralSynthDrySend.connect(dryBus); loopDrySends.forEach(send => send.connect(dryBus));
        filePlayerWetSend.connect(wetBus); micWetSend.connect(wetBus); granulatorWetSend.connect(wetBus); spectralSynthWetSend.connect(wetBus); loopWetSends.forEach(send => send.connect(wetBus));
        dryBus.connect(analyserDry);
        analyserDry.connect(finalOutputGain);
        wetBus.connect(inputGainNode_reverb);
        inputGainNode_reverb.connect(dryGainNode_reverb);
        inputGainNode_reverb.connect(convolverNode);
        let lastEqNode = convolverNode;
        if (eqBandInstances && eqBandInstances.length > 0) { eqBandInstances.forEach(bandInstance => { if (bandInstance.filterNode) { lastEqNode.connect(bandInstance.filterNode); lastEqNode = bandInstance.filterNode; } }); }
        lastEqNode.connect(granulatorFilter);
        if (granulatorLFOGain) granulatorLFOGain.connect(granulatorFilter.frequency);
        if (sidechainModulationSource && sidechainModulationGain) { sidechainModulationSource.connect(sidechainModulationGain); sidechainModulationGain.connect(granulatorFilter.frequency); }
        granulatorFilter.connect(wetGainNode_reverb);
        dryGainNode_reverb.connect(reverbBooster);
        wetGainNode_reverb.connect(reverbBooster);
        reverbBooster.connect(analyserWet);
        analyserWet.connect(finalOutputGain);
        
        gainNode.connect(recordSourceMixer);
        micBooster.connect(recordSourceMixer);

        gainNode.connect(sourceSidechainSendGain);
        micBooster.connect(sourceSidechainSendGain);
        sourceSidechainSendGain.connect(sidechainSummingGain);
        loopVolumeGains.forEach((loopVolGain, i) => { if (loopVolGain && loopSidechainSendGains[i]) loopVolGain.connect(loopSidechainSendGains[i]); });
        loopSidechainSendGains.forEach(scSendGain => { if (scSendGain && sidechainSummingGain) scSendGain.connect(sidechainSummingGain); });
        if (sidechainSummingGain && sidechainAnalyserNode) sidechainSummingGain.connect(sidechainAnalyserNode);
        if (window.masterAudioStreamDestinationNode) finalOutputGain.connect(window.masterAudioStreamDestinationNode);
        finalOutputGain.connect(audioContext.destination);
        console.log("Cadena de audio principal re-configurada.");
    }
    function setupAudioFileLoader() {
        if (audioFileInput) audioFileInput.addEventListener('change', handleAudioFileSelected);
    }
    function handleAudioFileSelected(event) {
        if (!audioContext) { console.error("AudioContext no inicializado."); alert("Error: El motor de audio no está listo."); return; }
        const file = event.target.files[0];
        if (!file) return;
        loadedAudioFileName = file.name; // Guardar el nombre del archivo
        const reader = new FileReader();
        reader.onload = function(e_reader) { processArrayBuffer(e_reader.target.result, false); };
        reader.onerror = function() { if (loaderOverlay) loaderOverlay.classList.add('hidden'); alert("Error al leer archivo."); drawInitialMessage("Error al leer archivo."); };
        reader.readAsArrayBuffer(file);
    }
    function processArrayBuffer(arrayBuffer, isInitial = false) { 
        if (!arrayBuffer || arrayBuffer.byteLength === 0) { if (loaderOverlay) loaderOverlay.classList.add('hidden'); alert("Error al leer el archivo."); return; }
        if (isMainPlayerPlaying && currentSourceNode) { try { currentSourceNode.stop(); } catch (e) {} isMainPlayerPlaying = false; if (playPauseBtn) playPauseBtn.textContent = PLAY_SYMBOL; }
        mainPlayerStartOffset = 0; audioBuffer = null; if (exportToBuffersBtn) exportToBuffersBtn.disabled = true;
        if (loaderOverlay) loaderOverlay.classList.remove('hidden');
        drawInitialMessage("Procesando audio...");
        audioContext.decodeAudioData(arrayBuffer, function(decodedBuffer) {
            audioBuffer = decodedBuffer; mainPlayerDuration = audioBuffer.duration;
            if (timeline) { timeline.max = mainPlayerDuration; }
            updateMainPlayerTimelineDisplay(true); // Force UI update
            if (playPauseBtn) { playPauseBtn.disabled = false; playPauseBtn.textContent = PLAY_SYMBOL; }
            if (exportToBuffersBtn) exportToBuffersBtn.disabled = false;
            isMainPlayerPlaying = false; mainPlayerStartOffset = 0;
            startReverbSystemWithBuffer(audioBuffer);
            if (loaderOverlay) loaderOverlay.classList.add('hidden');

            if (document.body.classList.contains('easy-mode-active') || isInitial) {
                updateLoopAndGranulatorWithNewBuffer(decodedBuffer);
                drawMainRecordedWaveform();
            }
            
            if (isInitial) {
                loadedAudioFileName = 'Output 1-2.wav'; // Nombre del archivo inicial
                const spectralSynthPowerSwitchEl = document.getElementById('spectralSynthPowerSwitch');
                if (spectralSynthPowerSwitchEl && !spectralSynthPowerSwitchEl.checked) {
                    spectralSynthPowerSwitchEl.checked = true;
                    spectralSynthPowerSwitchEl.dispatchEvent(new Event('change', { bubbles: true }));
                    console.log("Sintetizador Espectral activado por defecto al cargar audio inicial.");
                }
                const loadingText = document.getElementById('loading-text');
                const loadingButtonsContainer = document.getElementById('loading-buttons-container');
                
                if (loadingText) loadingText.style.display = 'none';
                if (loadingButtonsContainer) {
                    loadingButtonsContainer.style.display = 'flex';
                    loadingButtonsContainer.style.opacity = '0';
                    setTimeout(() => {
                        loadingButtonsContainer.style.opacity = '1';
                       
                    }, 100);
                }
            }

            if (spectralSynthPowerSwitch && spectralSynthPowerSwitch.checked && mainRecorderAudioBuffer && isDrawModeActive && !isSpectralSynthActive) {
                if (spectrumCanvas && spectrumCanvas.matches(':hover')) {
                    startSpectralSynth();
                }
            }
            
        }, function(error) {
            console.error("Error decodificando audio:", error); alert("Error al decodificar. Formato no compatible?");
            audioBuffer = null;
            loadedAudioFileName = null;
            if (playPauseBtn) playPauseBtn.disabled = true;
            if (exportToBuffersBtn) exportToBuffersBtn.disabled = true;
            drawInitialMessage("Error al decodificar audio.");
            if (loaderOverlay) loaderOverlay.classList.add('hidden');
        });
    }
    async function loadInitialAudio(url) {
        try {
            const response = await fetch(url);
            if (!response.ok) {
                 throw new Error(`No se pudo cargar el audio inicial: ${response.statusText}`);
            }
            const arrayBuffer = await response.arrayBuffer();
            processArrayBuffer(arrayBuffer, true); 
        } catch (error) {
            console.error("Error al cargar el audio inicial:", error);
            const loadingOverlay = document.getElementById('loading-overlay');
            if(loadingOverlay) loadingOverlay.style.display = 'none';
            drawInitialMessage("No se encontró audio. Carga un archivo.");
        }
    }
    function togglePlayPauseFilePlayer() {
        if (!audioContext) return;
        if (audioContext.state === 'suspended') { audioContext.resume(); }
        if (isMainPlayerPlaying) pauseAudioFilePlayer(); else playAudioFilePlayer();
    }
    function playAudioFilePlayer() {
        if (!audioBuffer || isMainPlayerPlaying || !audioContext) return;
        if (currentSourceNode) { try { currentSourceNode.disconnect(); } catch (e) {} }
        currentSourceNode = audioContext.createBufferSource();
        currentSourceNode.buffer = audioBuffer;
        currentSourceNode.loop = isMainPlayerLoopEnabled;
        currentSourceNode.connect(gainNode);
        currentSourceNode.onended = () => { if (currentSourceNode && !currentSourceNode.loop && isMainPlayerPlaying) { isMainPlayerPlaying = false; mainPlayerStartOffset = 0; if (playPauseBtn) playPauseBtn.textContent = PLAY_SYMBOL; } };
        try {
            if (mainPlayerStartOffset >= mainPlayerDuration) mainPlayerStartOffset = 0;
            currentSourceNode.start(0, mainPlayerStartOffset);
            mainPlayerStartTime = audioContext.currentTime;
            isMainPlayerPlaying = true;
            if (playPauseBtn) playPauseBtn.textContent = PAUSE_SYMBOL;
        } catch (e) {
            console.error("Error al iniciar sourceNode:", e);
            isMainPlayerPlaying = false;
            if (playPauseBtn) playPauseBtn.textContent = PLAY_SYMBOL;
        }
    }
    function pauseAudioFilePlayer() {
        if (!isMainPlayerPlaying || !currentSourceNode || !audioContext) return;
        try { currentSourceNode.stop(); } catch (e) {}
        mainPlayerStartOffset += (audioContext.currentTime - mainPlayerStartTime);
        if (mainPlayerStartOffset >= mainPlayerDuration && !isMainPlayerLoopEnabled) { mainPlayerStartOffset = 0; }
        else if (isMainPlayerLoopEnabled && mainPlayerDuration > 0) { mainPlayerStartOffset %= mainPlayerDuration; }
        mainPlayerStartOffset = Math.max(0, mainPlayerStartOffset);
        isMainPlayerPlaying = false;
        if (playPauseBtn) playPauseBtn.textContent = PLAY_SYMBOL;
        currentSourceNode = null;
    }
    function updateMainPlayerTimelineDisplay(forceUpdate = false) {
        if (!isMainPlayerPlaying && !forceUpdate) return;
        
        let currentTimeInTrack = mainPlayerStartOffset;
        if (isMainPlayerPlaying && audioBuffer && audioContext && currentSourceNode) {
            currentTimeInTrack = mainPlayerStartOffset + (audioContext.currentTime - mainPlayerStartTime);
            if (isMainPlayerLoopEnabled && audioBuffer.duration > 0) {
                currentTimeInTrack %= audioBuffer.duration;
            } else {
                currentTimeInTrack = Math.max(0, Math.min(currentTimeInTrack, mainPlayerDuration));
            }
        }
        
        if (timeline) { 
            timeline.value = currentTimeInTrack; 
            const numInput = document.getElementById('timelineValueInput'); 
            if (numInput) numInput.value = parseFloat(currentTimeInTrack).toFixed(1); 
        }
        if (currentTimeDisplay) { 
            currentTimeDisplay.textContent = formatTime(currentTimeInTrack); 
        }
    }
    if (exportToBuffersBtn) {
        exportToBuffersBtn.addEventListener('click', () => {
            if (audioBuffer) { updateLoopAndGranulatorWithNewBuffer(audioBuffer); drawMainRecordedWaveform(); }
            else { alert("Primero carga un archivo de audio para poder exportarlo."); }
        });
    }
    if (timeline) {
        timeline.addEventListener('input', () => { if (!audioBuffer || !audioContext) return; const newTime = parseFloat(timeline.value); if (!isMainPlayerPlaying) { mainPlayerStartOffset = newTime; if (currentTimeDisplay) currentTimeDisplay.textContent = formatTime(newTime); } });
        timeline.addEventListener('change', () => { if (!audioBuffer || !audioContext) return; const newTime = parseFloat(timeline.value); mainPlayerStartOffset = newTime; if (currentTimeDisplay) currentTimeDisplay.textContent = formatTime(newTime); if (isMainPlayerPlaying) { if (currentSourceNode) try { currentSourceNode.stop(); } catch (e) {} playAudioFilePlayer(); } });
    }
    async function initAudioDevicesList() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) { if (micSelect) { micSelect.innerHTML = '<option value="">API no soportada</option>'; micSelect.disabled = true; } return; }
        try {
            // Se necesita un permiso temporal para poder enumerar los dispositivos con sus nombres reales.
            const tempStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
            tempStream.getTracks().forEach(track => track.stop()); // Se detiene el stream temporal inmediatamente.

            const devices = await navigator.mediaDevices.enumerateDevices();
            const audioInputDevices = devices.filter(device => device.kind === 'audioinput');
            
            const mainMicSelect = document.getElementById('micSelect');
            const easyModeMicSelect = document.getElementById('easyModeMicSelect');
            
            // Guardar el dispositivo seleccionado actualmente, si hay alguno
            const previouslySelectedDeviceId = mainMicSelect ? mainMicSelect.value : null;

            if (mainMicSelect) mainMicSelect.innerHTML = '';
            if (easyModeMicSelect) easyModeMicSelect.innerHTML = '';

            if (audioInputDevices.length === 0) {
                 const noMicOption = new Option("No hay micrófonos", "");
                 if(mainMicSelect) { mainMicSelect.appendChild(noMicOption.cloneNode(true)); mainMicSelect.disabled = true; }
                 if(easyModeMicSelect) { easyModeMicSelect.appendChild(noMicOption); easyModeMicSelect.disabled = true; }
                 return;
            }
            
            if (mainMicSelect) mainMicSelect.disabled = false;
            if (easyModeMicSelect) easyModeMicSelect.disabled = false;

            audioInputDevices.forEach((device, index) => {
                const option = new Option(device.label || `Micrófono ${index + 1}`, device.deviceId);
                if (mainMicSelect) mainMicSelect.appendChild(option.cloneNode(true));
                if (easyModeMicSelect) easyModeMicSelect.appendChild(option);
            });

            // Intentar re-seleccionar el dispositivo que estaba activo
            if (previouslySelectedDeviceId) {
                const stillExists = audioInputDevices.some(d => d.deviceId === previouslySelectedDeviceId);
                if (stillExists) {
                    if(mainMicSelect) mainMicSelect.value = previouslySelectedDeviceId;
                    if(easyModeMicSelect) easyModeMicSelect.value = previouslySelectedDeviceId;
                }
            }

        } catch (err) {
            const errorOption = new Option("Error al listar / Sin permiso", "");
            if(micSelect) { micSelect.innerHTML = ''; micSelect.appendChild(errorOption.cloneNode(true)); micSelect.disabled = true; }
            if(document.getElementById('easyModeMicSelect')) { document.getElementById('easyModeMicSelect').innerHTML = ''; document.getElementById('easyModeMicSelect').appendChild(errorOption); document.getElementById('easyModeMicSelect').disabled = true; }

            if (err.name === "NotAllowedError" || err.name === "PermissionDeniedError") { alert("Permiso para acceder al micrófono denegado."); }
            console.error("Error al inicializar lista de dispositivos de audio:", err);
        }
    }
    function stopCurrentAudioSourceLogic() {
        if (mediaStream) { mediaStream.getTracks().forEach(track => track.stop()); mediaStream = null; }
        if (currentSourceNode) { try { if (typeof currentSourceNode.stop === 'function') currentSourceNode.stop(); currentSourceNode.disconnect(); } catch (e) {} currentSourceNode = null; }
        isMainPlayerPlaying = false;
        if (playPauseBtn) playPauseBtn.textContent = PLAY_SYMBOL;
    }
    async function startMicAudio(deviceId) {
        if (!audioContext) return false;
        if (audioContext.state === 'suspended') { try { await audioContext.resume(); } catch (e) { return false; } }
        stopCurrentAudioSourceLogic();
        const maxChannelsToRequest = 8;
        const constraints = { audio: { deviceId: deviceId ? { exact: deviceId } : undefined, channelCount: { ideal: maxChannelsToRequest }, echoCancellation: false, noiseSuppression: false, autoGainControl: false }, video: false };
        try {
            mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
            currentSourceNode = audioContext.createMediaStreamSource(mediaStream);
            const sourceChannelCount = currentSourceNode.channelCount;
            if (channelSelect) {
                const currentChannelValue = channelSelect.value;
                channelSelect.innerHTML = '';
                for (let i = 0; i < sourceChannelCount; i++) { const option = new Option(`Canal ${i + 1}`, i); channelSelect.appendChild(option); }
                channelSelect.value = (currentChannelValue < sourceChannelCount) ? currentChannelValue : 0;
                channelSelect.disabled = (sourceChannelCount < 2);
            }
            currentMicChannelIndex = channelSelect ? parseInt(channelSelect.value, 10) : 0;
            if (isNaN(currentMicChannelIndex) || currentMicChannelIndex >= sourceChannelCount) { currentMicChannelIndex = 0; if (channelSelect) channelSelect.value = "0"; }
            if (!micGainNode) micGainNode = audioContext.createGain();
            micGainNode.gain.value = isMicMuted ? 0 : parseFloat(micVolumeFader.value);
            currentSourceNode.connect(splitter);
            splitter.disconnect();
            splitter.connect(micGainNode, currentMicChannelIndex, 0);
            if (convolverNode && !convolverNode.buffer) reverb_updateReverbSize();
            reverb_updateDryWetMix();
            return true;
        } catch (err) {
            alert(`Error al iniciar micrófono: ${err.message}.`);
            window.currentAudioSourceType = 'file';
            toggleSourcePanels();
            return false;
        }
    }
    function updateSourceButtonUIAfterDOMChange() { 
        if (sourceToggleButton) { sourceToggleButton.setAttribute('aria-label', window.currentAudioSourceType === 'file' ? 'Fuente: Archivo, cambiar a Micrófono' : 'Fuente: Micrófono, cambiar a Archivo'); } 
        const easyModeAudioFileBtn = document.getElementById('easyModeAudioFileBtn');
        const easyModeMicSelect = document.getElementById('easyModeMicSelect');
        const easyModeSourceToggleBtn = document.getElementById('easyModeSourceToggleBtn');
        if(easyModeAudioFileBtn && easyModeMicSelect && easyModeSourceToggleBtn) {
            if (window.currentAudioSourceType === 'mic') {
                easyModeAudioFileBtn.classList.add('hidden');
                easyModeMicSelect.classList.remove('hidden');
                easyModeSourceToggleBtn.title = "Cambiar a Archivo";
            } else {
                easyModeAudioFileBtn.classList.remove('hidden');
                easyModeMicSelect.classList.add('hidden');
                easyModeSourceToggleBtn.title = "Cambiar a Micrófono";
            }
        }
    }
    function toggleSourcePanels() { if (micPanel) micPanel.style.display = window.currentAudioSourceType === 'mic' ? 'block' : 'none'; if (filePanel) filePanel.style.display = window.currentAudioSourceType === 'file' ? 'block' : 'none'; updateSourceButtonUIAfterDOMChange(); }
    async function handleSourceChange() {
        stopCurrentAudioSourceLogic();
        toggleSourcePanels();
        if (window.currentAudioSourceType === 'mic') {
            let micStarted = false;
            if (micSelect.value && micSelect.value !== "") { micStarted = await startMicAudio(micSelect.value); }
            else if (micSelect.options.length > 0 && micSelect.options[0].value !== "" && micSelect.options[0].value !== "No hay micrófonos" && micSelect.options[0].value !== "Error al listar") { micStarted = await startMicAudio(micSelect.options[0].value); }
            if (!micStarted) { window.currentAudioSourceType = 'file'; toggleSourcePanels(); if (audioBuffer) { startReverbSystemWithBuffer(audioBuffer); } else { drawInitialMessage("Carga un archivo de audio para ver el espectro."); } }
        } else {
            if (audioBuffer) { startReverbSystemWithBuffer(audioBuffer); }
            else { drawInitialMessage("Carga un archivo de audio para ver el espectro."); }
        }
    }
    if (sourceToggleButton) { sourceToggleButton.addEventListener('click', () => { window.currentAudioSourceType = window.currentAudioSourceType === 'file' ? 'mic' : 'file'; handleSourceChange(); }); }
    if (micSelect) { micSelect.addEventListener('change', async () => { if (window.currentAudioSourceType === 'mic') { await handleSourceChange(); } }); }
    if (channelSelect) { channelSelect.addEventListener('change', () => { if (window.currentAudioSourceType !== 'mic' || !splitter || !micGainNode || !currentSourceNode) return; const newChannelIdx = Number(channelSelect.value); if (isNaN(newChannelIdx) || newChannelIdx >= currentSourceNode.channelCount) return; try { splitter.disconnect(); splitter.connect(micGainNode, newChannelIdx, 0); currentMicChannelIndex = newChannelIdx; } catch (err) { console.error("Error al cambiar canal de micrófono:", err); } }); }
    function startReverbSystemWithBuffer(loadedAudioBuffer) { if (convolverNode && !convolverNode.buffer) reverb_updateReverbSize(); reverb_updateDryWetMix(); }
    
    function setupMainAudioRecorder() {
        if (!audioContext || !recordSourceMixer) { return; }
        mainRecordingStreamDestinationNode = audioContext.createMediaStreamDestination();
        try { recordSourceMixer.connect(mainRecordingStreamDestinationNode); } catch (e) { console.error("Error al conectar recordSourceMixer a mainRecordingStreamDestinationNode:", e); return; }
        const options = { mimeType: 'audio/webm;codecs=opus' };
        try { mainAudioRecorder = new MediaRecorder(mainRecordingStreamDestinationNode.stream, (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(options.mimeType)) ? options : undefined); }
        catch (e) { mainAudioRecorder = new MediaRecorder(mainRecordingStreamDestinationNode.stream); }
        mainAudioRecorder.ondataavailable = (event) => { if (event.data && event.data.size > 0) mainRecordedChunks.push(event.data); };
        mainAudioRecorder.onstop = async () => {
            if (mainRecordedChunks.length === 0 && currentRecordingMode !== "clear_for_empty_record" && currentRecordingMode !== "clear_direct") {
                if (currentRecordingMode === "record") { updateLoopAndGranulatorWithNewBuffer(null); if (recordedWaveformCanvas) drawMainRecordedWaveform(true); if (granulatorPlayToggleBtn) granulatorPlayToggleBtn.disabled = true; }
                enableRecordingButtons(); currentRecordingMode = ""; return;
            }
            if (currentRecordingMode === "clear_for_empty_record" || currentRecordingMode === "clear_direct") {
                updateLoopAndGranulatorWithNewBuffer(null); mainRecordedChunks = []; if (recordedWaveformCanvas) drawMainRecordedWaveform(true); enableRecordingButtons(); if (granulatorPlayToggleBtn) granulatorPlayToggleBtn.disabled = true; currentRecordingMode = ""; return;
            }
            const blob = new Blob(mainRecordedChunks, { type: mainAudioRecorder.mimeType || 'audio/webm' });
            mainRecordedChunks = [];
            if (blob.size === 0 && currentRecordingMode !== "record") { enableRecordingButtons(); currentRecordingMode = ""; return; }
            try {
                const arrayBuffer = await blob.arrayBuffer();
                if (arrayBuffer.byteLength === 0) { if (currentRecordingMode === "record") { updateLoopAndGranulatorWithNewBuffer(null); if (recordedWaveformCanvas) drawMainRecordedWaveform(true); if (granulatorPlayToggleBtn) granulatorPlayToggleBtn.disabled = true; } enableRecordingButtons(); currentRecordingMode = ""; return; }
                const decodedAudioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                let resultingBuffer = null;
                if (currentRecordingMode === "record") { 
                    resultingBuffer = decodedAudioBuffer;
                    loadedAudioFileName = "Grabación en vivo";
                }
                else if (currentRecordingMode === "append") {
                    const oldDuration = mainRecorderAudioBuffer ? mainRecorderAudioBuffer.duration : 0;
                    const absoluteLoopSelections = loopSelections.map(sel => ({ start: sel.start * oldDuration, end: sel.end * oldDuration }));
                    resultingBuffer = mainRecorderAudioBuffer ? appendAudioBuffers(mainRecorderAudioBuffer, decodedAudioBuffer, audioContext) : decodedAudioBuffer;
                    const newDuration = resultingBuffer.duration;
                    if (newDuration > 0) { loopSelections = absoluteLoopSelections.map(absSel => ({ start: absSel.start / newDuration, end: absSel.end / newDuration })); }
                    loadedAudioFileName = "Grabación (Append)";
                } else if (currentRecordingMode === "overdub") { 
                    resultingBuffer = mainRecorderAudioBuffer ? mixAudioBuffers(mainRecorderAudioBuffer, decodedAudioBuffer, audioContext) : decodedAudioBuffer; 
                    loadedAudioFileName = "Grabación (Overdub)";
                }
                updateLoopAndGranulatorWithNewBuffer(resultingBuffer);
                if (recordedWaveformCanvas) drawMainRecordedWaveform();
                if (granulatorPlayToggleBtn) granulatorPlayToggleBtn.disabled = !mainRecorderAudioBuffer;
            } catch (decodeError) {
                console.error("Error decodificando audio grabado principal:", decodeError);
                if (currentRecordingMode === "record") { updateLoopAndGranulatorWithNewBuffer(null); if (recordedWaveformCanvas) drawMainRecordedWaveform(true); }
            }
            currentRecordingMode = "";
            enableRecordingButtons();
        };
    }
    function enableRecordingButtons() { 
        if (!recordBtn || !stopRecBtn || !appendRecBtn || !overdubNowBtn) return; 
        const isRecorderActive = mainAudioRecorder && mainAudioRecorder.state === "recording"; 
        recordBtn.disabled = isRecorderActive; 
        stopRecBtn.disabled = !isRecorderActive; 
        const hasRecording = !!mainRecorderAudioBuffer; 
        appendRecBtn.disabled = isRecorderActive || !hasRecording; 
        overdubNowBtn.disabled = isRecorderActive || !hasRecording;
        
        const easyModeRecBtn = document.getElementById('easyModeRecordBtn');
        if (easyModeRecBtn) {
            easyModeRecBtn.innerHTML = isRecorderActive ? '■' : '●';
            easyModeRecBtn.classList.toggle('is-recording', isRecorderActive);
        }
    }
    function appendAudioBuffers(buffer1, buffer2, context) {
        if (!buffer1) return buffer2; if (!buffer2) return buffer1;
        const numberOfChannels = Math.min(buffer1.numberOfChannels, buffer2.numberOfChannels);
        const combinedLength = buffer1.length + buffer2.length;
        const newBuffer = context.createBuffer(numberOfChannels, combinedLength, buffer1.sampleRate);
        for (let i = 0; i < numberOfChannels; i++) { const channelData = newBuffer.getChannelData(i); channelData.set(buffer1.getChannelData(i), 0); channelData.set(buffer2.getChannelData(i), buffer1.length); }
        return newBuffer;
    }
    function mixAudioBuffers(buffer1, buffer2, context) {
        if (!buffer1) return buffer2; if (!buffer1) return buffer2;
        const numberOfChannels = Math.min(buffer1.numberOfChannels, buffer2.numberOfChannels);
        if (buffer1.sampleRate !== buffer2.sampleRate) { console.error("No se pueden mezclar buffers con diferentes sample rates."); return buffer1; }
        const length = Math.max(buffer1.length, buffer2.length);
        const mixedBuffer = context.createBuffer(numberOfChannels, length, buffer1.sampleRate);
        for (let channel = 0; channel < numberOfChannels; channel++) {
            const outputData = mixedBuffer.getChannelData(channel);
            const buffer1Data = buffer1.numberOfChannels > channel ? buffer1.getChannelData(channel) : null;
            const buffer2Data = buffer2.numberOfChannels > channel ? buffer2.getChannelData(channel) : null;
            for (let i = 0; i < length; i++) { let sample1 = buffer1Data && i < buffer1.length ? buffer1Data[i] : 0; let sample2 = buffer2Data && i < buffer2.length ? buffer2Data[i] : 0; outputData[i] = Math.max(-1.0, Math.min(1.0, sample1 + sample2)); }
        }
        return mixedBuffer;
    }
    if (stopRecBtn) stopRecBtn.addEventListener('click', () => { if (mainAudioRecorder && mainAudioRecorder.state === "recording") { mainAudioRecorder.stop(); if (stopRecBtn) stopRecBtn.disabled = true; } else { enableRecordingButtons(); } });
    if (clearRecBtn) clearRecBtn.addEventListener('click', () => {
        if (mainAudioRecorder && mainAudioRecorder.state === "recording") { currentRecordingMode = "clear_for_empty_record"; mainAudioRecorder.stop(); }
        else { updateLoopAndGranulatorWithNewBuffer(null); mainRecordedChunks = []; if (recordedWaveformCanvas) drawMainRecordedWaveform(true); currentRecordingMode = "clear_direct"; }
        loopSelections.forEach((s, i) => { loopSelections[i] = { start: 0, end: 1 }; sampleSelections[i] = { start: 0, end: 0 }; if (loopCanvases[i]) drawLoopWaveformVisuals(i, true); });
        isLoopRealtimePlaying.forEach((isPlaying, i) => { if (isPlaying) stopLoopRealtimePlayback(i); });
        loadedAudioFileName = null; // Limpiar nombre de archivo
        enableRecordingButtons();
        if (granulatorPlayToggleBtn) granulatorPlayToggleBtn.disabled = true;
        if (currentRecordingMode === "clear_direct") currentRecordingMode = "";
    });
    function drawMainRecordedWaveform(clearCanvasOnly = false) {
        if (!recordedWaveformCanvas) return;
        const canvasCtx = recordedWaveformCanvas.getContext('2d');
        const width = recordedWaveformCanvas.width;
        const height = recordedWaveformCanvas.height;
        canvasCtx.fillStyle = getComputedStyle(recordedWaveformCanvas).backgroundColor || 'var(--primary-bg-color)';
        canvasCtx.fillRect(0, 0, width, height);
        if (!clearCanvasOnly && mainRecorderAudioBuffer && mainRecorderAudioBuffer.duration > 0) {
            const channelData = mainRecorderAudioBuffer.getChannelData(0);
            if (channelData && channelData.length > 0) {
                let step = Math.max(1, Math.floor(channelData.length / width));
                canvasCtx.lineWidth = 1;
                canvasCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                canvasCtx.beginPath();

                for (let x = 0; x < width; x++) {
                    let sliceStart = Math.floor(x * step);
                    if (sliceStart >= channelData.length) break;
                    
                    let minPeak = 0, maxPeak = 0;
                    for (let j = 0; j < step; j++) {
                        if (sliceStart + j < channelData.length) {
                            const val = channelData[sliceStart + j];
                            if (val < minPeak) minPeak = val;
                            if (val > maxPeak) maxPeak = val;
                        }
                    }
                    let yMax = (0.5 * (-maxPeak + 1.0)) * height;
                    let yMin = (0.5 * (-minPeak + 1.0)) * height;
                    
                    canvasCtx.moveTo(x, yMin);
                    canvasCtx.lineTo(x, yMax);
                }
                canvasCtx.stroke();
            }
        }
        
        samplerGrainPoints.forEach(point => {
            const x = point.x * width;
            
            canvasCtx.beginPath();
            canvasCtx.moveTo(x, 0);
            canvasCtx.lineTo(x, height);

            if (point.active) {
                canvasCtx.strokeStyle = 'yellow';
                canvasCtx.lineWidth = 1.5;
            } else {
                canvasCtx.strokeStyle = 'black';
                canvasCtx.lineWidth = 1;
            }
            canvasCtx.stroke();
        });
    }

    if (recordedWaveformCanvas) {
        recordedWaveformCanvas.addEventListener('contextmenu', e => e.preventDefault());

        recordedWaveformCanvas.addEventListener('mousedown', e => {
            if (!mainRecorderAudioBuffer) return;
            const rect = recordedWaveformCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            
            const pointHitRadius = 10; 
            let pointClickedIndex = -1;

            for (let i = samplerGrainPoints.length - 1; i >= 0; i--) {
                const point = samplerGrainPoints[i];
                const pointCanvasX = point.x * rect.width;
                const distance = Math.abs(x - pointCanvasX);

                if (distance < pointHitRadius) {
                    pointClickedIndex = i;
                    break;
                }
            }

            if (pointClickedIndex !== -1) {
                 if (isMidiMapping) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (elementToMap) {
                        if (elementToMap.classList) elementToMap.classList.remove('control-listening');
                        if (elementToMap.element && elementToMap.element.classList) elementToMap.element.classList.remove('control-listening');
                    }
                    elementToMap = { 
                        id: `granulator_point_${pointClickedIndex}`,
                        element: recordedWaveformCanvas, // Referencia al canvas para quitar la clase
                        type: 'virtual'
                    };
                    recordedWaveformCanvas.classList.add('control-listening');
                    console.log(`Escuchando MIDI para el punto del granulador ${pointClickedIndex}`);
                    return; 
                }


                if (e.button === 2) {
                    samplerGrainPoints[pointClickedIndex].active = !samplerGrainPoints[pointClickedIndex].active;
                    if(samplerGrainPoints[pointClickedIndex].isMain) samplerGrainPoints[pointClickedIndex].active = true;
                    drawMainRecordedWaveform();
                    e.preventDefault();
                }
                else if (e.button === 0) {
                    isDraggingGrainPoint = true;
                    selectedGrainPointIndex = pointClickedIndex;
                }
            }
        });

        window.addEventListener('mousemove', e => {
            if (!isDraggingGrainPoint || selectedGrainPointIndex === -1) return;
            
            const rect = recordedWaveformCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const normalizedX = Math.max(0, Math.min(x / rect.width, 1));

            samplerGrainPoints[selectedGrainPointIndex].x = normalizedX;
            drawMainRecordedWaveform();
        });

        window.addEventListener('mouseup', e => {
            if (e.button === 0) {
                isDraggingGrainPoint = false;
                selectedGrainPointIndex = -1;
            }
        });

        recordedWaveformCanvas.addEventListener('mouseleave', () => {
            isDraggingGrainPoint = false;
            selectedGrainPointIndex = -1;
        });
    }

    function formatTime(totalSeconds){
        if(isNaN(totalSeconds) || totalSeconds < 0) totalSeconds = 0;
        let minutes = Math.floor(totalSeconds / 60);
        let seconds = Math.floor(totalSeconds % 60);
        return `${minutes}:${seconds.toString().padStart(2,'0')}`;
    }

    function scheduleNextGrainPlayback() {
        const activePoints = samplerGrainPoints.filter(p => p.active);

        if (!isGranulatorRunning || !mainRecorderAudioBuffer || mainRecorderAudioBuffer.duration === 0 || activePoints.length === 0) {
            isGranulatorRunning = false;
            if (granulatorTimeoutId) clearTimeout(granulatorTimeoutId);
            granulatorTimeoutId = null;
            if(granulatorPlayToggleBtn) {
                 granulatorPlayToggleBtn.disabled = !mainRecorderAudioBuffer;
                 granulatorPlayToggleBtn.textContent = PLAY_SYMBOL;
            }
            return;
        }
        
        const randomPoint = activePoints[Math.floor(Math.random() * activePoints.length)];
        let grainPosition = randomPoint.x;

        let bufferDuration = mainRecorderAudioBuffer.duration;
        const currentGrainLength = parseFloat(grainLengthDialEl.getAttribute('data-value'));
        let effectiveGrainLength = Math.min(currentGrainLength, bufferDuration * 0.99);
        if (effectiveGrainLength <= 0.001) effectiveGrainLength = 0.001;

        let grainStartPositionInBuffer = grainPosition * (bufferDuration - effectiveGrainLength);
        grainStartPositionInBuffer = Math.max(0, Math.min(grainStartPositionInBuffer, bufferDuration - effectiveGrainLength));

        let grainSource = audioContext.createBufferSource();
        grainSource.buffer = mainRecorderAudioBuffer;
        
        let actualPlaybackRate = 1.0;
        const currentPitchBend = parseFloat(pitchBendDialEl.getAttribute('data-value'));
        if (currentPitchBend !== 0) {
            actualPlaybackRate = Math.pow(2, currentPitchBend / 12);
            grainSource.playbackRate.value = actualPlaybackRate;
        }

        let grainEnvelope = audioContext.createGain();
        grainSource.connect(grainEnvelope);
        grainEnvelope.connect(granulatorVolumeGain);

        let now = audioContext.currentTime;
        const grainDuration = effectiveGrainLength / actualPlaybackRate;
        let fadeInDuration = grainDuration * 0.5;
        let fadeOutDuration = grainDuration * 0.5;

        grainEnvelope.gain.setValueAtTime(0, now);
        grainEnvelope.gain.linearRampToValueAtTime(1, now + fadeInDuration);
        grainEnvelope.gain.linearRampToValueAtTime(0, now + grainDuration);

        try {
            grainSource.start(now, grainStartPositionInBuffer, grainDuration);
        } catch (e) {
            console.error("Error al iniciar grano:", e);
            isGranulatorRunning = false;
            if (granulatorTimeoutId) clearTimeout(granulatorTimeoutId);
            granulatorTimeoutId = null;
            if(granulatorPlayToggleBtn) {
                granulatorPlayToggleBtn.disabled = false;
                granulatorPlayToggleBtn.textContent = PLAY_SYMBOL;
            }
            return;
        }
        
        grainSource.onended = () => {
            try {
                grainSource.disconnect();
                grainEnvelope.disconnect();
            } catch (e) { }
        };

        const currentOverlap = parseFloat(overlapDialEl.getAttribute('data-value'));
        const delay = effectiveGrainLength * 1000 * (1 - currentOverlap);
        const finalDelay = Math.max(10, delay / actualPlaybackRate);

        granulatorTimeoutId = setTimeout(scheduleNextGrainPlayback, finalDelay);
    }

    function toggleGranulator() {
        if (isGranulatorRunning) {
            isGranulatorRunning = false;
            if (granulatorTimeoutId) {
                clearTimeout(granulatorTimeoutId);
                granulatorTimeoutId = null;
            }
            if(granulatorPlayToggleBtn) {
                granulatorPlayToggleBtn.disabled = !mainRecorderAudioBuffer;
                granulatorPlayToggleBtn.textContent = PLAY_SYMBOL;
            }
        } else {
            if (!mainRecorderAudioBuffer || mainRecorderAudioBuffer.duration === 0) return;
            if (audioContext.state === 'suspended') audioContext.resume();
            
            isGranulatorRunning = true;
            if(granulatorPlayToggleBtn) {
                granulatorPlayToggleBtn.disabled = false;
                granulatorPlayToggleBtn.textContent = STOP_SYMBOL;
            }
            scheduleNextGrainPlayback();
        }
    }

    if(granulatorPlayToggleBtn) granulatorPlayToggleBtn.addEventListener('click', toggleGranulator);
    
    if(lfoPowerSwitch) {
        lfoPowerSwitch.addEventListener('change', (e) => {
            if (!audioContext || !granulatorFilter) return;
            const lfoEnabled = e.target.checked;
            
            if (lfoEnabled) {
                if (!granulatorLFO) {
                    granulatorLFO = audioContext.createOscillator();
                    granulatorLFO.type = "sine";
                    granulatorLFO.frequency.value = granulatorLfoSpeedFader ? parseFloat(granulatorLfoSpeedFader.value) : 1;
                    
                    granulatorLFOGain = audioContext.createGain();
                    granulatorLFOGain.gain.value = granulatorLfoDepthFader ? parseFloat(granulatorLfoDepthFader.value) : 500;
                    
                    granulatorLFO.connect(granulatorLFOGain);
                    granulatorLFOGain.connect(granulatorFilter.frequency);
                    try {
                        granulatorLFO.start();
                    } catch (startError) {
                        try { granulatorLFO.stop(); granulatorLFO.start(); } catch (restartError) {}
                    }
                }
            } else {
                if (granulatorLFO) {
                    try { granulatorLFO.stop(); } catch (stopError) {}
                    granulatorLFO.disconnect();
                    if (granulatorLFOGain) granulatorLFOGain.disconnect(granulatorFilter.frequency);
                    granulatorLFO = null;
                    granulatorLFOGain = null;
                }
            }
        });
    }

    if(granulatorLfoSpeedFader) granulatorLfoSpeedFader.addEventListener('input', (e) => {
        if (granulatorLFO) granulatorLFO.frequency.setTargetAtTime(parseFloat(e.target.value), audioContext.currentTime, 0.01);
    });
    if(granulatorLfoDepthFader) granulatorLfoDepthFader.addEventListener('input', (e) => {
        if (granulatorLFOGain) granulatorLFOGain.gain.setTargetAtTime(parseFloat(e.target.value), audioContext.currentTime, 0.01);
    });
    
   function setupSidechainEventListeners() {
    if (sidechainEnvelopePowerSwitch) {
        sidechainEnvelopePowerSwitch.addEventListener('change', () => {
            isSidechainEnvelopeProcessingActive = sidechainEnvelopePowerSwitch.checked;
            if (isSidechainEnvelopeProcessingActive) {
                if (audioContext.state === 'suspended') audioContext.resume();
                startSidechainEnvelopeProcessing();
            } else {
                stopSidechainEnvelopeProcessing();
            }
        });
    }

    if (sourceSidechainSendSwitches) {
        sourceSidechainSendSwitches.forEach(switchEl => {
            switchEl.addEventListener('change', e => {
                const isChecked = e.target.checked;
                if(sourceSidechainSendGain && audioContext) {
                    const gainValue = isChecked ? 1.0 : 0.0;
                    sourceSidechainSendGain.gain.setTargetAtTime(gainValue, audioContext.currentTime, 0.01);
                }
                sourceSidechainSendSwitches.forEach(otherSwitch => {
                    if (otherSwitch !== e.target) {
                        otherSwitch.checked = isChecked;
                    }
                });
            });
        });
    }

    loopSidechainSendSwitches.forEach((switchEl, idx) => {
        if(switchEl) switchEl.addEventListener('change', (e) => {
            const gainValue = e.target.checked ? 1.0 : 0.0;
            if(loopSidechainSendGains[idx] && audioContext) {
                loopSidechainSendGains[idx].gain.setTargetAtTime(gainValue, audioContext.currentTime, 0.01);
            }
        });
    });

    sidechainThresholdDialEl?.addEventListener('dialChange', e => { sidechainThresholdValue = parseFloat(e.detail.value); });
    sidechainAttackDialEl?.addEventListener('dialChange', e => { sidechainAttackTime = parseFloat(e.detail.value); });
    sidechainReleaseDialEl?.addEventListener('dialChange', e => { sidechainReleaseTime = parseFloat(e.detail.value); });
    sidechainAmountDialEl?.addEventListener('dialChange', e => {
        sidechainModulationAmount = parseFloat(e.detail.value);
    });
}

function startSidechainEnvelopeProcessing() {
    if (!isSidechainEnvelopeProcessingActive || sidechainAnimationRequest !== null) return;
    if (sidechainSummingGain && sidechainAnalyserNode) {
         try { sidechainSummingGain.disconnect(sidechainAnalyserNode); } catch(e){}
         try { sidechainSummingGain.connect(sidechainAnalyserNode); } catch(e){ console.error("Error conectando sidechainSummingGain a sidechainAnalyserNode", e); }
    }
    processEnvelope();
}

function processEnvelope() {
    if (!isSidechainEnvelopeProcessingActive || !audioContext || audioContext.state === 'closed') {
        stopSidechainEnvelopeProcessing();
        return;
    }
    sidechainAnalyserNode.getByteTimeDomainData(sidechainEnvelopeDataArray);
    let sumOfSquares = 0;
    for (let i = 0; i < sidechainEnvelopeDataArray.length; i++) {
        const normalizedSample = (sidechainEnvelopeDataArray[i] / 128.0) - 1.0;
        sumOfSquares += normalizedSample * normalizedSample;
    }
    const rms = Math.sqrt(sumOfSquares / sidechainEnvelopeDataArray.length);
    const rmsDb = 20 * Math.log10(rms || 0.00001);

    let targetEnvelope = 0;
    if (rmsDb > sidechainThresholdValue) {
        const dynamicRangeDb = 24;
        targetEnvelope = Math.min(1, Math.max(0, (rmsDb - sidechainThresholdValue) / dynamicRangeDb));
    }

    const updateIntervalSeconds = 1/60;
    if (targetEnvelope > sidechainSmoothedEnvelope) {
        const attackConstant = 1 - Math.exp(-updateIntervalSeconds / Math.max(0.001, sidechainAttackTime));
        sidechainSmoothedEnvelope += (targetEnvelope - sidechainSmoothedEnvelope) * attackConstant;
    } else {
        const releaseConstant = 1 - Math.exp(-updateIntervalSeconds / Math.max(0.001, sidechainReleaseTime));
        sidechainSmoothedEnvelope += (targetEnvelope - sidechainSmoothedEnvelope) * releaseConstant;
    }
    sidechainSmoothedEnvelope = Math.max(0, Math.min(1, sidechainSmoothedEnvelope));

    const finalModulationValue = sidechainSmoothedEnvelope * -sidechainModulationAmount;
    if (sidechainModulationGain) {
        sidechainModulationGain.gain.setTargetAtTime(finalModulationValue, audioContext.currentTime, 0.01);
    }

    sidechainAnimationRequest = requestAnimationFrame(processEnvelope);
}

function stopSidechainEnvelopeProcessing() {
    if (sidechainAnimationRequest) {
        cancelAnimationFrame(sidechainAnimationRequest);
        sidechainAnimationRequest = null;
    }
    if (sidechainModulationGain) {
        sidechainModulationGain.gain.setTargetAtTime(0, audioContext.currentTime, 0.01);
    }
    sidechainSmoothedEnvelope = 0;
}

    let isLoopRealtimePlaying = [false, false, false];
    let realtimeLoopSourceNodes = [null, null, null];
    let loopFades = [
        { fadeIn: 0.0, fadeOut: 0.0, dragging: null },
        { fadeIn: 0.0, fadeOut: 0.0, dragging: null },
        { fadeIn: 0.0, fadeOut: 0.0, dragging: null }
    ];
    
    const loopReverseBtns = [document.getElementById('reverseBtn1'), document.getElementById('reverseBtn2'), document.getElementById('reverseBtn3')];
    const loopFlexPitchBtns = [document.getElementById('flexPitchBtn1'), document.getElementById('flexPitchBtn2'), document.getElementById('flexPitchBtn3')];

    function drawLoopWaveformVisuals(loopIndex, playheadPosition = -1) {
        const canvas = loopCanvases[loopIndex];
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const loopSelection = loopSelections[loopIndex];
        const sampleSelection = sampleSelections[loopIndex];
        
        const width = canvas.width;
        const height = canvas.height;
        const styles = getComputedStyle(canvas);

        ctx.fillStyle = styles.backgroundColor || 'var(--casilla-bg-color)';
        ctx.fillRect(0, 0, width, height);

        if (mainRecorderAudioBuffer && mainRecorderAudioBuffer.duration > 0) {
            const channelData = mainRecorderAudioBuffer.getChannelData(0);
            const zoom = loopZoomLevels[loopIndex];
            const panOffsetNormalized = loopPanOffsets[loopIndex];
            const totalBufferFrames = channelData.length;
            const visiblePortionNormalized = 1 / zoom;
            const startFrameInFullBuffer = Math.floor(panOffsetNormalized * totalBufferFrames);
            const framesToDisplayInView = Math.floor(visiblePortionNormalized * totalBufferFrames);
            
            if (framesToDisplayInView > 0) {
                ctx.strokeStyle = styles.getPropertyValue('--highlight-color').trim() || "magenta";
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                const step = Math.max(1, Math.floor(framesToDisplayInView / width));

                for (let i = 0; i < width; i++) {
                    let minVal = 1.0, maxVal = -1.0;
                    const frameIndexInViewStart = Math.floor(i * step);
                    
                    for (let j = 0; j < step; j++) {
                        const currentFrameInView = frameIndexInViewStart + j;
                        if (currentFrameInView >= framesToDisplayInView) break;
                        const actualFrameInBuffer = startFrameInFullBuffer + currentFrameInView;
                        if (actualFrameInBuffer < totalBufferFrames) {
                            let data = channelData[actualFrameInBuffer];
                            if (data < minVal) minVal = data;
                            if (data > maxVal) maxVal = data;
                        }
                    }
                    if (minVal > maxVal) { minVal = 0; maxVal = 0; }

                    let yMin = (0.5 * (-minVal + 1.0)) * height;
                    let yMax = (0.5 * (-maxVal + 1.0)) * height;
                    ctx.moveTo(i, yMin);
                    ctx.lineTo(i, yMax);
                }
                ctx.stroke();
            }
        }
        
        if (loopSelection && loopSelection.end > loopSelection.start) {
            const visiblePortion = 1 / loopZoomLevels[loopIndex];
            const viewStart = loopPanOffsets[loopIndex];
            const viewEnd = viewStart + visiblePortion;
            
            if(loopSelection.end > viewStart && loopSelection.start < viewEnd) {
                ctx.fillStyle = styles.getPropertyValue('--loop-selection-bg').trim() || 'rgba(255, 255, 0, 0.3)';
                let selectionStartX = ((loopSelection.start - viewStart) / visiblePortion) * width;
                let selectionEndX = ((loopSelection.end - viewStart) / visiblePortion) * width;
                
                selectionStartX = Math.max(0, selectionStartX);
                selectionEndX = Math.min(width, selectionEndX);

                if (selectionEndX > selectionStartX) {
                    ctx.fillRect(selectionStartX, 0, selectionEndX - selectionStartX, height);
                    
                    const fades = loopFades[loopIndex];
                    const selectionWidthPx = selectionEndX - selectionStartX;
                    const fadeInPx = fades.fadeIn * selectionWidthPx;
                    const fadeOutPx = fades.fadeOut * selectionWidthPx;

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.lineWidth = 1;

                    if (fadeInPx > 0) {
                        ctx.beginPath();
                        ctx.moveTo(selectionStartX, height);
                        ctx.lineTo(selectionStartX + fadeInPx, 0);
                        ctx.lineTo(selectionStartX, 0);
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.moveTo(selectionStartX, height);
                        ctx.lineTo(selectionStartX + fadeInPx, 0);
                        ctx.stroke();
                    }

                    if (fadeOutPx > 0) {
                        ctx.beginPath();
                        ctx.moveTo(selectionEndX - fadeOutPx, 0);
                        ctx.lineTo(selectionEndX, height);
                        ctx.lineTo(selectionEndX, 0);
                        ctx.closePath();
                        ctx.fill();

                        ctx.beginPath();
                        ctx.moveTo(selectionEndX - fadeOutPx, 0);
                        ctx.lineTo(selectionEndX, height);
                        ctx.stroke();
                    }
                }
            }
        }

        if (sampleSelection && sampleSelection.end > sampleSelection.start) {
            ctx.fillStyle = styles.getPropertyValue('--sample-selection-bg').trim() || 'rgba(0, 150, 255, 0.3)';
            let selectionStartX = (sampleSelection.start - loopPanOffsets[loopIndex]) / (1 / loopZoomLevels[loopIndex]) * width;
            let selectionEndX = (sampleSelection.end - loopPanOffsets[loopIndex]) / (1 / loopZoomLevels[loopIndex]) * width;

            selectionStartX = Math.max(0, Math.min(width, selectionStartX));
            selectionEndX = Math.max(0, Math.min(width, selectionEndX));

            if (selectionEndX > selectionStartX) {
                ctx.fillRect(selectionStartX, 0, selectionEndX - selectionStartX, height);
            }
        }

        if (playheadPosition >= 0) {
            const playheadX = (playheadPosition - loopPanOffsets[loopIndex]) / (1 / loopZoomLevels[loopIndex]) * width;
            if (playheadX >= 0 && playheadX <= width) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(playheadX, 0);
                ctx.lineTo(playheadX, height);
                ctx.stroke();
            }
        }
    }

    function attachLoopCanvasEvents(loopIndex) {
        const canvas = loopCanvases[loopIndex];
        if (!canvas) return;

        function getMousePosInfo(e) {
            const rect = canvas.getBoundingClientRect();
            const xOnCanvas = e.clientX - rect.left;
            const xInViewNormalized = Math.min(Math.max(xOnCanvas / rect.width, 0), 1);
            const zoom = loopZoomLevels[loopIndex];
            const panOffsetCurrentView = loopPanOffsets[loopIndex];
            const visiblePortion = 1 / zoom;
            let posInBufferNormalized = panOffsetCurrentView + (xInViewNormalized * visiblePortion);
            posInBufferNormalized = Math.min(Math.max(posInBufferNormalized, 0), 1);
            return { xOnCanvas, xInViewNormalized, posInBufferNormalized, rect };
        }

        canvas.addEventListener('contextmenu', e => {
            e.preventDefault();
            if (!mainRecorderAudioBuffer || isMidiMapping) return;

            const { xOnCanvas, rect } = getMousePosInfo(e);
            const selection = loopSelections[loopIndex];
            if (selection.end <= selection.start) return;

            const visiblePortion = 1 / loopZoomLevels[loopIndex];
            const viewStart = loopPanOffsets[loopIndex];
            let selectionStartX = ((selection.start - viewStart) / visiblePortion) * rect.width;
            let selectionEndX = ((selection.end - viewStart) / visiblePortion) * rect.width;

            const FADE_HANDLE_WIDTH = 25; 
            if (xOnCanvas >= selectionStartX && xOnCanvas <= selectionStartX + FADE_HANDLE_WIDTH) {
                loopFades[loopIndex].dragging = 'in';
            } else if (xOnCanvas <= selectionEndX && xOnCanvas >= selectionEndX - FADE_HANDLE_WIDTH) {
                loopFades[loopIndex].dragging = 'out';
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            if (!mainRecorderAudioBuffer || e.button !== 0 || isMidiMapping) return;

            const { posInBufferNormalized } = getMousePosInfo(e);
            
            if (e.altKey) {
                isSelectingSampleFlags[loopIndex] = true;
                loopIsSelectingFlags[loopIndex] = false;
                sampleSelections[loopIndex] = { start: posInBufferNormalized, end: posInBufferNormalized };
            } else if (loopZoomLevels[loopIndex] > 1 && (e.metaKey || e.ctrlKey)) {
                loopIsDraggingForPan[loopIndex] = true;
                loopPanLastMouseX[loopIndex] = e.clientX;
                canvas.style.cursor = 'grabbing';
            } else {
                loopIsSelectingFlags[loopIndex] = true;
                isSelectingSampleFlags[loopIndex] = false;
                loopSelections[loopIndex] = { start: posInBufferNormalized, end: posInBufferNormalized };
            }
            drawLoopWaveformVisuals(loopIndex);
        });

        canvas.addEventListener('mousemove', (e) => {
            const { posInBufferNormalized } = getMousePosInfo(e);

            if (loopFades[loopIndex].dragging) {
                const selection = loopSelections[loopIndex];
                const selectionDuration = selection.end - selection.start;
                if(selectionDuration <= 0) return;
                
                if (loopFades[loopIndex].dragging === 'in') {
                    const newFadeInEndPos = Math.max(selection.start, Math.min(selection.end, posInBufferNormalized));
                    const newFadeInDuration = newFadeInEndPos - selection.start;
                    loopFades[loopIndex].fadeIn = Math.min(newFadeInDuration / selectionDuration, 0.5);
                } else { // dragging out
                    const newFadeOutStartPos = Math.min(selection.end, Math.max(selection.start, posInBufferNormalized));
                    const newFadeOutDuration = selection.end - newFadeOutStartPos;
                    loopFades[loopIndex].fadeOut = Math.min(newFadeOutDuration / selectionDuration, 0.5);
                }
            } else if (loopIsDraggingForPan[loopIndex]) {
                const deltaX = e.clientX - loopPanLastMouseX[loopIndex];
                loopPanLastMouseX[loopIndex] = e.clientX;
                handleLoopPan(loopIndex, loopPanOffsets[loopIndex] + (-deltaX / canvas.width) * (1 / loopZoomLevels[loopIndex]));
            } else if (isSelectingSampleFlags[loopIndex]) {
                sampleSelections[loopIndex].end = posInBufferNormalized;
            } else if (loopIsSelectingFlags[loopIndex]) {
                loopSelections[loopIndex].end = posInBufferNormalized;
            }
            
            drawLoopWaveformVisuals(loopIndex);
        });

        const finalizeLoopAction = (e) => {
             if (e.button === 2) { 
                if (loopFades[loopIndex].dragging) {
                    if (isLoopRealtimePlaying[loopIndex]) { stopLoopRealtimePlayback(loopIndex); startLoopRealtimePlayback(loopIndex); }
                    loopFades[loopIndex].dragging = null;
                }
             }

            if (e.button === 0) { 
                if (loopIsDraggingForPan[loopIndex]) {
                    loopIsDraggingForPan[loopIndex] = false;
                    canvas.style.cursor = loopZoomLevels[loopIndex] > 1 ? 'grab' : 'crosshair';
                }
                if (isSelectingSampleFlags[loopIndex]) {
                    if (sampleSelections[loopIndex].start > sampleSelections[loopIndex].end) {
                        [sampleSelections[loopIndex].start, sampleSelections[loopIndex].end] = [sampleSelections[loopIndex].end, sampleSelections[loopIndex].start];
                    }
                    isSelectingSampleFlags[loopIndex] = false;
                }
                if (loopIsSelectingFlags[loopIndex]) {
                    if (loopSelections[loopIndex].start > loopSelections[loopIndex].end) {
                        [loopSelections[loopIndex].start, loopSelections[loopIndex].end] = [loopSelections[loopIndex].end, loopSelections[loopIndex].start];
                    }
                    if (loopSelections[loopIndex].end - loopSelections[loopIndex].start < 0.001) {
                        loopSelections[loopIndex].end = loopSelections[loopIndex].start + 0.001;
                    }
                    
                    const selection = loopSelections[loopIndex];
                    if (mainRecorderAudioBuffer) {
                        loopDedicatedBuffers[loopIndex] = extractAudioBufferSegment(
                            mainRecorderAudioBuffer,
                            selection.start,
                            selection.end,
                            audioContext
                        );
                        flexPitchCache[loopIndex] = {};
                        loopReversedBuffersCache[loopIndex] = null;
                        console.log(`Buffer dedicado creado para el loop ${loopIndex + 1}.`);
                    }

                    if (isLoopRealtimePlaying[loopIndex]) {
                        stopLoopRealtimePlayback(loopIndex);
                        startLoopRealtimePlayback(loopIndex);
                    }
                    loopIsSelectingFlags[loopIndex] = false;
                }
            }
            drawLoopWaveformVisuals(loopIndex);
        };

        window.addEventListener('mouseup', finalizeLoopAction);
        canvas.addEventListener('mouseleave', () => {
            if(loopIsDraggingForPan[loopIndex] || isSelectingSampleFlags[loopIndex] || loopIsSelectingFlags[loopIndex] || loopFades[loopIndex].dragging) {
                finalizeLoopAction({ button: loopFades[loopIndex].dragging ? 2 : 0 });
            }
        });
        
        canvas.addEventListener('wheel', (e) => {
            if (!mainRecorderAudioBuffer) return;
            e.preventDefault();
            const zoomFactor = 1.2;
            const { xInViewNormalized } = getMousePosInfo(e);
            
            if (e.deltaY < 0) {
                handleLoopZoom(loopIndex, loopZoomLevels[loopIndex] * zoomFactor, xInViewNormalized);
            } else {
                handleLoopZoom(loopIndex, loopZoomLevels[loopIndex] / zoomFactor, xInViewNormalized);
            }
        });
        canvas.style.cursor = 'crosshair';
    }

    function handleLoopZoom(loopIndex, newZoom, zoomOriginInViewNormalized = 0.5) {
        if (!mainRecorderAudioBuffer) return;
        const oldZoom = loopZoomLevels[loopIndex];
        newZoom = Math.max(1, Math.min(newZoom, 100));
        loopZoomLevels[loopIndex] = newZoom;

        const currentPanOffset = loopPanOffsets[loopIndex];
        const visiblePortionOld = 1 / oldZoom;
        const visiblePortionNew = 1 / newZoom;

        const focalPointInBuffer = currentPanOffset + (zoomOriginInViewNormalized * visiblePortionOld);
        
        let newPanOffset = focalPointInBuffer - (zoomOriginInViewNormalized * visiblePortionNew);
        
        const maxPanOffset = 1 - visiblePortionNew;
        newPanOffset = Math.max(0, Math.min(newPanOffset, maxPanOffset));
        
        loopPanOffsets[loopIndex] = newPanOffset;
        loopCanvases[loopIndex].style.cursor = newZoom > 1 ? 'grab' : 'crosshair';
        drawLoopWaveformVisuals(loopIndex);
    }

    function handleLoopPan(loopIndex, newPanAttempt) {
        if (!mainRecorderAudioBuffer || loopZoomLevels[loopIndex] <= 1) return;
        const zoom = loopZoomLevels[loopIndex];
        const visiblePortion = 1 / zoom;
        const maxPan = 1 - visiblePortion;
        
        newPanAttempt = Math.max(0, Math.min(newPanAttempt, maxPan));
        loopPanOffsets[loopIndex] = newPanAttempt;
        drawLoopWaveformVisuals(loopIndex);
    }

    loopZoomInBtns.forEach(btn => btn.addEventListener('click', () => {
        const loopIdx = parseInt(btn.dataset.loopindex);
        handleLoopZoom(loopIdx, loopZoomLevels[loopIdx] * 1.5, 0.5);
    }));
    loopZoomOutBtns.forEach(btn => btn.addEventListener('click', () => {
        const loopIdx = parseInt(btn.dataset.loopindex);
        handleLoopZoom(loopIdx, loopZoomLevels[loopIdx] / 1.5, 0.5);
    }));

    function attachLoopCanvasEventsAll() {
        for (let i = 0; i < loopCanvases.length; i++) {
            if (loopCanvases[i]) attachLoopCanvasEvents(i);
        }
    }
    
    function updateLoopAndGranulatorWithNewBuffer(audioBuf) {
        mainRecorderAudioBuffer = audioBuf;
        mainRecorderAudioBufferId++;
        
        loopDedicatedBuffers = [null, null, null];
        loopReversedBuffersCache = [null, null, null];
        flexPitchCache = [{}, {}, {}];
        
        for (let i = 0; i < loopSelections.length; i++) {
            loopZoomLevels[i] = 1;
            loopPanOffsets[i] = 0;
            sampleSelections[i] = { start: 0, end: 0 };
            loopFades[i] = { fadeIn: 0.0, fadeOut: 0.0, dragging: null };
            if (loopCanvases[i]) {
                loopCanvases[i].style.cursor = 'crosshair';
                drawLoopWaveformVisuals(i);
            }
        }
        loopPlayPauseBtns.forEach(btn => { if(btn) btn.disabled = !mainRecorderAudioBuffer; });
        if (granulatorPlayToggleBtn) granulatorPlayToggleBtn.disabled = !mainRecorderAudioBuffer;
        if (spectralSynthPowerSwitch) spectralSynthPowerSwitch.disabled = !mainRecorderAudioBuffer;
    }

    function extractAudioBufferSegment(originalBuffer, startNormalized, endNormalized, ctx) {
        if (!originalBuffer || originalBuffer.duration === 0) return null;
        let startTimeSeconds = startNormalized * originalBuffer.duration;
        let endTimeSeconds = endNormalized * originalBuffer.duration;
        let durationSeconds = endTimeSeconds - startTimeSeconds;

        if (durationSeconds <= 0.001) return null;

        const startFrame = Math.floor(startTimeSeconds * originalBuffer.sampleRate);
        const frameCount = Math.max(1, Math.floor(durationSeconds * originalBuffer.sampleRate));
        const endFrame = startFrame + frameCount;

        if (startFrame < 0 || endFrame > originalBuffer.length || frameCount <= 0) {
             return null;
        }

        try {
            const segmentBuffer = ctx.createBuffer(originalBuffer.numberOfChannels, frameCount, originalBuffer.sampleRate);
            for (let i = 0; i < originalBuffer.numberOfChannels; i++) {
                const sourceChannelData = originalBuffer.getChannelData(i);
                const segmentChannelData = segmentBuffer.getChannelData(i);
                const subArray = sourceChannelData.subarray(startFrame, Math.min(endFrame, sourceChannelData.length));
                segmentChannelData.set(subArray);
            }
            return segmentBuffer;
        } catch (err) {
            console.error("Error extrayendo segmento de audio:", err);
            return null;
        }
    }
    
    function playLoopSegmentRealtimePlayback(loopIndex, scheduledTime) {
        const dedicatedBuffer = loopDedicatedBuffers[loopIndex];
        if (!dedicatedBuffer || dedicatedBuffer.duration <= 0.001 || !isLoopRealtimePlaying[loopIndex]) {
            stopLoopRealtimePlayback(loopIndex);
            return;
        }

        const isReversed = loopReverseBtns[loopIndex] ? loopReverseBtns[loopIndex].getAttribute('aria-pressed') === 'true' : false;
        const currentSpeed = loopSpeedControls[loopIndex] ? parseFloat(loopSpeedControls[loopIndex].value) : 1;
        const useFlexPitch = loopFlexPitchBtns[loopIndex] ? loopFlexPitchBtns[loopIndex].getAttribute('aria-pressed') === 'true' : false;

        let originalSegmentForPlayback = dedicatedBuffer;
        if (isReversed) {
            if(loopReversedBuffersCache[loopIndex]) {
                originalSegmentForPlayback = loopReversedBuffersCache[loopIndex];
            } else {
                console.warn(`Buffer invertido para loop ${loopIndex+1} no estaba en caché. Generando ahora.`);
                loopReversedBuffersCache[loopIndex] = createReversedAudioBuffer(dedicatedBuffer);
                originalSegmentForPlayback = loopReversedBuffersCache[loopIndex] || dedicatedBuffer;
            }
        }
        
        let bufferToPlay = originalSegmentForPlayback;
        let finalPlaybackRate = currentSpeed;
        let segmentDuration = bufferToPlay.duration;

        if (useFlexPitch && currentSpeed !== 1.0 && audioWorker) {
            const cacheKey = `${loopIndex}_${mainRecorderAudioBufferId}_s${loopSelections[loopIndex].start.toFixed(4)}_e${loopSelections[loopIndex].end.toFixed(4)}_r${isReversed}_v${currentSpeed.toFixed(2)}`;
            if (flexPitchCache[loopIndex] && flexPitchCache[loopIndex][cacheKey]) {
                bufferToPlay = flexPitchCache[loopIndex][cacheKey];
                finalPlaybackRate = 1.0; 
                segmentDuration = bufferToPlay.duration;
            } else {
                finalPlaybackRate = currentSpeed; 
                
                const transferableChannels = [];
                for(let i=0; i < originalSegmentForPlayback.numberOfChannels; i++) {
                    transferableChannels.push(originalSegmentForPlayback.getChannelData(i).slice(0));
                }

                audioWorker.postMessage({
                    audioBufferChannels: transferableChannels,
                    sampleRate: originalSegmentForPlayback.sampleRate,
                    rateFactor: currentSpeed,
                    cacheKey: cacheKey
                }, transferableChannels.map(ch => ch.buffer));
            }
        }
        
        const sourceNode = audioContext.createBufferSource();
        sourceNode.buffer = bufferToPlay;
        sourceNode.playbackRate.value = finalPlaybackRate;
        
        const fadeGain = audioContext.createGain();
        sourceNode.connect(fadeGain);
        if (loopVolumeGains[loopIndex]) fadeGain.connect(loopVolumeGains[loopIndex]);

        const startTime = scheduledTime || audioContext.currentTime;
        
        const fades = loopFades[loopIndex];
        const loopDurationSeconds = segmentDuration / finalPlaybackRate;
        const fadeInDuration = fades.fadeIn * loopDurationSeconds;
        const fadeOutDuration = fades.fadeOut * loopDurationSeconds;

        fadeGain.gain.setValueAtTime(0, startTime);
        if (fadeInDuration > 0.001) {
            fadeGain.gain.linearRampToValueAtTime(1, startTime + fadeInDuration);
        } else {
            fadeGain.gain.setValueAtTime(1, startTime);
        }
        if (fadeOutDuration > 0.001 && loopDurationSeconds > fadeInDuration) {
            const fadeOutStartTime = startTime + loopDurationSeconds - fadeOutDuration;
            fadeGain.gain.setValueAtTime(1, Math.max(startTime + fadeInDuration, fadeOutStartTime));
            fadeGain.gain.linearRampToValueAtTime(0, fadeOutStartTime + fadeOutDuration);
        }
        
        sourceNode.start(startTime);
        realtimeLoopSourceNodes[loopIndex] = sourceNode;
        
        const nextLoopTime = startTime + loopDurationSeconds;

        if (isLoopRealtimePlaying[loopIndex]) {
            loopNextStartTimeoutId[loopIndex] = setTimeout(() => {
                if (isLoopRealtimePlaying[loopIndex]) {
                    playLoopSegmentRealtimePlayback(loopIndex, nextLoopTime);
                }
            }, (nextLoopTime - audioContext.currentTime - 0.05) * 1000);
        }
    }
    
    function startLoopRealtimePlayback(loopIndex) {
        if (isLoopRealtimePlaying[loopIndex] || !loopDedicatedBuffers[loopIndex]) return;
        
        if (audioContext.state === 'suspended') {
            audioContext.resume().then(() => actuallyStartLoopPlayback(loopIndex));
        } else {
            actuallyStartLoopPlayback(loopIndex);
        }
    }

    function actuallyStartLoopPlayback(loopIndex) {
        isLoopRealtimePlaying[loopIndex] = true;
        if(loopPlayPauseBtns[loopIndex]) loopPlayPauseBtns[loopIndex].textContent = "Pause";
        
        loopPlaybackStartTimes[loopIndex] = audioContext.currentTime;
        playLoopSegmentRealtimePlayback(loopIndex, loopPlaybackStartTimes[loopIndex]);
    }

    function stopLoopRealtimePlayback(loopIndex, silent = false) {
        isLoopRealtimePlaying[loopIndex] = false;

        if (loopNextStartTimeoutId[loopIndex]) {
            clearTimeout(loopNextStartTimeoutId[loopIndex]);
            loopNextStartTimeoutId[loopIndex] = null;
        }
        if (realtimeLoopSourceNodes[loopIndex]) {
            try {
                realtimeLoopSourceNodes[loopIndex].stop();
            } catch (e) {}
            realtimeLoopSourceNodes[loopIndex] = null;
        }
        
        if(!silent && loopPlayPauseBtns[loopIndex]) loopPlayPauseBtns[loopIndex].textContent = "Play";
    }

    loopSpeedControls.forEach((control, i) => {
        if(!control) return;
        control.addEventListener('input', function() {
            if (isLoopRealtimePlaying[i]) {
                stopLoopRealtimePlayback(i, true); 
                startLoopRealtimePlayback(i);
            }
        });
    });

    loopReverseBtns.forEach((btn, i) => {
        if (!btn) return;
        btn.addEventListener('click', function() {
            const isPressed = this.getAttribute('aria-pressed') === 'true';
            this.setAttribute('aria-pressed', String(!isPressed));

            if (!isPressed && loopDedicatedBuffers[i] && !loopReversedBuffersCache[i]) {
                console.log(`Generando y cacheando buffer invertido para el loop ${i+1}...`);
                loopReversedBuffersCache[i] = createReversedAudioBuffer(loopDedicatedBuffers[i]);
            }

            if (flexPitchCache[i]) flexPitchCache[i] = {};
            if (isLoopRealtimePlaying[i]) {
                stopLoopRealtimePlayback(i);
                startLoopRealtimePlayback(i);
            }
        });
    });

    loopFlexPitchBtns.forEach((btn, i) => {
        if (!btn) return;
        btn.addEventListener('click', function() {
            const isPressed = this.getAttribute('aria-pressed') === 'true';
            this.setAttribute('aria-pressed', String(!isPressed));

            if (isLoopRealtimePlaying[i]) {
                stopLoopRealtimePlayback(i, true);
                startLoopRealtimePlayback(i);
            }
        });
    });
    
    loopPlayPauseBtns.forEach((btn, i) => {
        if(!btn) return;
        btn.disabled = !mainRecorderAudioBuffer;
        btn.addEventListener('click', () => {
            if (!loopDedicatedBuffers[i]) {
                alert(`Primero debes seleccionar una región para el loop ${i+1}.`);
                return;
            };
            if (!isLoopRealtimePlaying[i]) {
                startLoopRealtimePlayback(i);
            } else {
                stopLoopRealtimePlayback(i);
            }
        });
    });
    loopVolumeFaders.forEach((volCtrl, i) => {
        if(!volCtrl) return;
        volCtrl.addEventListener('input', function() {
            if (loopVolumeGains[i] && audioContext) {
                loopVolumeGains[i].gain.setTargetAtTime(parseFloat(this.value), audioContext.currentTime, 0.01);
            }
        });
    });
    
    function processAudioWithSoundTouch(audioBufferInput, rateFactor) {
        console.warn("processAudioWithSoundTouch fue llamada desde el hilo principal, debería usar el worker.");
        return audioBufferInput;
    }

    function createReversedAudioBuffer(inputAudioBuffer) {
        if (!inputAudioBuffer || !audioContext) return null;
        const numChannels = inputAudioBuffer.numberOfChannels;
        const frameLength = inputAudioBuffer.length;
        const sampleRate = inputAudioBuffer.sampleRate;

        try {
            const reversedBuffer = audioContext.createBuffer(numChannels, frameLength, sampleRate);
            for (let channel = 0; channel < numChannels; channel++) {
                const originalChannelData = inputAudioBuffer.getChannelData(channel);
                const reversedChannelData = reversedBuffer.getChannelData(channel);
                reversedChannelData.set(originalChannelData);
                reversedChannelData.reverse();
            }
            return reversedBuffer;
        } catch (err) {
            console.error("Error creando buffer revertido:", err);
            return null;
        }
    }
    
    function getCurrentAppState() {
        if (!eqBandInstances || eqBandInstances.length === 0) {
            return {};
        }
        
        const routingStates = {};
        document.querySelectorAll('#routingPatchBayGrid input[type="checkbox"]').forEach(cb => {
            const key = `${cb.dataset.source}_to_${cb.dataset.dest}`;
            routingStates[key] = cb.checked;
        });

        const cleanSavedStates = savedStates.map(state => {
            if (!state) return null;
            const cleanState = { ...state };
            delete cleanState.savedStates;
            return cleanState;
        });

        return {
            version: 1.4,
            loadedAudioFileName: loadedAudioFileName,
            selectedSource: window.currentAudioSourceType,
            selectedMicId: micSelect ? micSelect.value : (micSelect?.options.length > 0 ? micSelect.options[0].value : ""),
            micVolumeLevel: micVolumeFader?.value ?? "1",
            isMicCurrentlyMuted: isMicMuted,
            selectedMicChannel: channelSelect?.value ?? "0",
            
            mainPlayerVolume: volumeFader?.value ?? "1",
            mainPlayerTimelineValue: timeline?.value ?? "0",
            
            samplerGrainPoints: JSON.parse(JSON.stringify(samplerGrainPoints)),
            granulatorOverlap: overlapDialEl?.getAttribute('data-value') ?? "0.8",
            granulatorCurrentGrainLength: grainLengthDialEl?.getAttribute('data-value') ?? "0.6",
            granulatorFilterCutoff: granulatorFilterFreqEl?.getAttribute('data-value') ?? "10000",
            granulatorPitchBend: pitchBendDialEl?.getAttribute('data-value') ?? "0",
            currentGranulatorFilterType: granulatorFilter?.type ?? "highpass",
            granulatorOutputVolume: granulatorVolumeFader?.value ?? "0.2",
            isGranulatorCurrentlyRunning: isGranulatorRunning,

            isSpectralSynthOn: spectralSynthPowerSwitch?.checked ?? false,
            spectralSynthVolume: spectralSynthVolumeFader?.value ?? "0.9",
            isDrawModeActive: isDrawModeActive,
            drawnPaths: JSON.parse(JSON.stringify(drawnPaths)),

            granulatorLfoRate: granulatorLfoSpeedFader?.value ?? "1",
            granulatorLfoFilterDepth: granulatorLfoDepthFader?.value ?? "500",
            isGranulatorLfoOn: lfoPowerSwitch?.checked ?? false,
            
            isSidechainFromSourceOn: sourceSidechainSendSwitches.length > 0 ? sourceSidechainSendSwitches[0].checked : false,
            isSidechainEnvelopeActive: sidechainEnvelopePowerSwitch?.checked ?? false,
            sidechainThreshold: sidechainThresholdDialEl?.getAttribute('data-value') ?? "-24",
            sidechainAttack: sidechainAttackDialEl?.getAttribute('data-value') ?? "0.01",
            sidechainRelease: sidechainReleaseDialEl?.getAttribute('data-value') ?? "0.1",
            sidechainAmount: sidechainAmountDialEl?.getAttribute('data-value') ?? "1000",
            
            loopSidechainSendStates: loopSidechainSendSwitches.map(s => s?.checked ?? false),
            loopRegionSelections: JSON.parse(JSON.stringify(loopSelections)),
            sampleRegionSelections: JSON.parse(JSON.stringify(sampleSelections)),
            loopSpeedSettings: loopSpeedControls.map(c => c?.value ?? "1"),
            loopFlexPitchStates: loopFlexPitchBtns.map(b => b.getAttribute('aria-pressed') === 'true'),
            loopReverseStates: loopReverseBtns.map(b => b.getAttribute('aria-pressed') === 'true'),
            loopVolumeLevels: loopVolumeFaders.map(c => c?.value ?? "1"),
            loopPlaybackStates: isLoopRealtimePlaying.map(s => s),
            loopZoomLevels: loopZoomLevels.map(z => z),
            loopPanOffsets: loopPanOffsets.map(p => p),
            
            masterVolume: masterVolumeFaderEl?.value ?? "1",
            
            reverbSize: reverbSizeDialEl?.getAttribute('data-value') ?? "5.0",
            reverbDryWet: reverbDryWetDialEl?.getAttribute('data-value') ?? "0.85",
            eqBandSettings: eqBandInstances.map((b) => ({ x: b.x, y: b.y, q: b.q })),
            
            patchBayMappings: JSON.parse(JSON.stringify(patchMappings)),
            routingPatchBayStates: routingStates,
            
            midiMap: JSON.parse(JSON.stringify(midiMap)),
            automationMemories: JSON.parse(JSON.stringify(automationMemories)),
            savedStates: cleanSavedStates
        };
    }

    function updateAllVisualsFromState() {
        drawMainRecordedWaveform();
        for (let i = 0; i < 3; i++) {
            drawLoopWaveformVisuals(i);
        }
        updateAutomationBtnUI();
        updateStateBtnUI();
    }
    
    function applySavedAppState(state){
        console.log("Aplicando estado guardado...");
        
        const deepCopy = (data) => data ? JSON.parse(JSON.stringify(data)) : data;

        loadedAudioFileName = state.loadedAudioFileName || null;

        window.currentAudioSourceType = state.selectedSource || 'file';
        toggleSourcePanels();
        if (state.selectedSource === 'mic') {
            if (micSelect) micSelect.value = state.selectedMicId;
            if (channelSelect) channelSelect.value = state.selectedMicChannel;
            handleSourceChange();
        }
        if (micMuteBtn) micMuteBtn.setAttribute('aria-pressed', String(state.isMicCurrentlyMuted));
        isMicMuted = state.isMicCurrentlyMuted;
        if(micVolumeFader) localUpdateRangeParamProgrammatic(micVolumeFader, parseFloat(state.micVolumeLevel));

        if(volumeFader) localUpdateRangeParamProgrammatic(volumeFader, parseFloat(state.mainPlayerVolume));
        if(timeline) {
            mainPlayerStartOffset = parseFloat(state.mainPlayerTimelineValue);
            localUpdateRangeParamProgrammatic(timeline, mainPlayerStartOffset);
        }

        if (state.samplerGrainPoints) samplerGrainPoints = deepCopy(state.samplerGrainPoints);
        if(overlapDialEl) localUpdateDialParamProgrammatic(overlapDialEl, parseFloat(state.granulatorOverlap));
        if(grainLengthDialEl) localUpdateDialParamProgrammatic(grainLengthDialEl, parseFloat(state.granulatorCurrentGrainLength));
        if(pitchBendDialEl) localUpdateDialParamProgrammatic(pitchBendDialEl, parseFloat(state.granulatorPitchBend));
        if(granulatorFilterFreqEl) localUpdateDialParamProgrammatic(granulatorFilterFreqEl, parseFloat(state.granulatorFilterCutoff));
        if(granulatorFilter) granulatorFilter.type = state.currentGranulatorFilterType;
        if(toggleGranulatorFilterBtn) toggleGranulatorFilterBtn.textContent = `Filtro: ${state.currentGranulatorFilterType === 'lowpass' ? 'Lowpass' : 'Highpass'}`;
        if(granulatorVolumeFader) localUpdateRangeParamProgrammatic(granulatorVolumeFader, parseFloat(state.granulatorOutputVolume));
        if (state.isGranulatorCurrentlyRunning && !isGranulatorRunning) toggleGranulator();
        else if (!state.isGranulatorCurrentlyRunning && isGranulatorRunning) toggleGranulator();
        
        if(granulatorLfoSpeedFader) localUpdateRangeParamProgrammatic(granulatorLfoSpeedFader, parseFloat(state.granulatorLfoRate));
        if(granulatorLfoDepthFader) localUpdateRangeParamProgrammatic(granulatorLfoDepthFader, parseFloat(state.granulatorLfoFilterDepth));
        if(lfoPowerSwitch && lfoPowerSwitch.checked !== state.isGranulatorLfoOn) lfoPowerSwitch.click();

        if(sourceSidechainSendSwitches.length > 0 && sourceSidechainSendSwitches[0].checked !== state.isSidechainFromSourceOn) sourceSidechainSendSwitches[0].click();
        if(sidechainEnvelopePowerSwitch && sidechainEnvelopePowerSwitch.checked !== state.isSidechainEnvelopeActive) sidechainEnvelopePowerSwitch.click();
        if(sidechainThresholdDialEl) localUpdateDialParamProgrammatic(sidechainThresholdDialEl, parseFloat(state.sidechainThreshold));
        if(sidechainAttackDialEl) localUpdateDialParamProgrammatic(sidechainAttackDialEl, parseFloat(state.sidechainAttack));
        if(sidechainReleaseDialEl) localUpdateDialParamProgrammatic(sidechainReleaseDialEl, parseFloat(state.sidechainRelease));
        if(sidechainAmountDialEl) localUpdateDialParamProgrammatic(sidechainAmountDialEl, parseFloat(state.sidechainAmount));
        state.loopSidechainSendStates?.forEach((isChecked, i) => { if(loopSidechainSendSwitches[i] && loopSidechainSendSwitches[i].checked !== isChecked) loopSidechainSendSwitches[i].click(); });
        
        if (state.loopRegionSelections) loopSelections = deepCopy(state.loopRegionSelections);
        if (state.sampleRegionSelections) sampleSelections = deepCopy(state.sampleRegionSelections);
        if (state.loopZoomLevels) loopZoomLevels = deepCopy(state.loopZoomLevels);
        if (state.loopPanOffsets) loopPanOffsets = deepCopy(state.loopPanOffsets);
        state.loopSpeedSettings?.forEach((val, i) => { if(loopSpeedControls[i]) localUpdateRangeParamProgrammatic(loopSpeedControls[i], parseFloat(val)); });
        state.loopVolumeLevels?.forEach((val, i) => { if(loopVolumeFaders[i]) localUpdateRangeParamProgrammatic(loopVolumeFaders[i], parseFloat(val)); });
        state.loopFlexPitchStates?.forEach((isPressed, i) => { if(loopFlexPitchBtns[i] && (loopFlexPitchBtns[i].getAttribute('aria-pressed') === 'true') !== isPressed) loopFlexPitchBtns[i].click(); });
        state.loopReverseStates?.forEach((isPressed, i) => { if(loopReverseBtns[i] && (loopReverseBtns[i].getAttribute('aria-pressed') === 'true') !== isPressed) loopReverseBtns[i].click(); });

        if(masterVolumeFaderEl) localUpdateRangeParamProgrammatic(masterVolumeFaderEl, parseFloat(state.masterVolume));
        if(reverbSizeDialEl) localUpdateDialParamProgrammatic(reverbSizeDialEl, parseFloat(state.reverbSize));
        if(reverbDryWetDialEl) localUpdateDialParamProgrammatic(reverbDryWetDialEl, parseFloat(state.reverbDryWet));
        
        if (state.eqBandSettings) {
            const centerX = spectrumCanvas.width / 2;
            const centerY = spectrumCanvas.height / 2;
            const neutralRadius = Math.min(spectrumCanvas.width, spectrumCanvas.height) / 3.5;
            state.eqBandSettings.forEach((bandState, i) => {
                if (eqBandInstances[i]) {
                    eqBandInstances[i].x = bandState.x;
                    eqBandInstances[i].y = bandState.y;
                    eqBandInstances[i].q = bandState.q;
                    eqBandInstances[i].updateFilter(centerX, centerY, neutralRadius);
                }
            });
        }
        
        if (state.drawnPaths) drawnPaths = deepCopy(state.drawnPaths);
        if(spectralSynthVolumeFader) localUpdateRangeParamProgrammatic(spectralSynthVolumeFader, parseFloat(state.spectralSynthVolume));
        if(spectralSynthDrawModeSwitch) spectralSynthDrawModeSwitch.checked = state.isDrawModeActive;
        isDrawModeActive = state.isDrawModeActive;

        if(spectralSynthPowerSwitch && spectralSynthPowerSwitch.checked !== state.isSpectralSynthOn) {
          spectralSynthPowerSwitch.click();
        }
        
        if (state.isSpectralSynthOn) {
            if (state.drawnPaths && state.drawnPaths.flat().length > 0) {
                setTimeout(() => startPathPlayback(), 100);
            }
        }
        
        if (state.patchBayMappings) patchMappings = deepCopy(state.patchBayMappings);
        document.querySelectorAll('#patchBayGrid input[type="checkbox"]').forEach(cb => {
            const paramId = cb.dataset.paramId;
            const axis = cb.closest('tr').dataset.mouseAxis;
            cb.checked = patchMappings[paramId]?.[axis] || false;
        });
        isPatchBayActive = document.querySelectorAll('#patchBayGrid input[type="checkbox"]:checked').length > 0;

        if (state.routingPatchBayStates) {
            document.querySelectorAll('#routingPatchBayGrid input[type="checkbox"]').forEach(cb => {
                const key = `${cb.dataset.source}_to_${cb.dataset.dest}`;
                if (cb.checked !== state.routingPatchBayStates[key]) cb.click();
            });
        }
        
        if (state.midiMap) midiMap = deepCopy(state.midiMap);
        if (state.automationMemories) automationMemories = deepCopy(state.automationMemories);
        if (state.savedStates) savedStates = deepCopy(state.savedStates);

        updateAllVisualsFromState();

        console.log("Estado de la aplicación restaurado.");
    }
    
    function updateStateBtnUI() {
        stateButtons.forEach((btn, i) => {
            if (!btn) return;
            btn.classList.remove('state-has-data');
            if (savedStates[i]) {
                btn.classList.add('state-has-data');
            }
        });
    }

    if(stateButtons) stateButtons.forEach((btn,i)=>{
        if(!btn)return;
        btn.addEventListener("mousedown",(e)=>{ if(e.button===0) statePressTimes[i]=Date.now(); });
        btn.addEventListener("mouseup",(e)=>{
            if(e.button===0 && statePressTimes[i]!==0){
                const pressDuration = Date.now() - statePressTimes[i];
                if(pressDuration >= 700){
                    const currentState = getCurrentAppState();
                    delete currentState.savedStates;
                    savedStates[i] = currentState;

                    btn.style.backgroundColor="var(--highlight-color)";
                    setTimeout(()=>{btn.style.backgroundColor=""; updateStateBtnUI();},600);
                } else {
                    if(savedStates[i]){
                        setTimeout(() => { 
                          applySavedAppState(savedStates[i]);
                        }, 0);
                        btn.style.backgroundColor="green";
                        setTimeout(()=>{btn.style.backgroundColor="";},600);
                    } else {
                        btn.style.backgroundColor="lightcoral";
                        setTimeout(()=>{btn.style.backgroundColor="";},600);
                    }
                }
                statePressTimes[i]=0;
            }
        });
        btn.addEventListener("mouseleave",()=>{ statePressTimes[i]=0; });
        btn.addEventListener("touchstart",(e)=>{ statePressTimes[i]=Date.now(); e.preventDefault(); },{passive:false});
        btn.addEventListener("touchend",(e)=>{
             if(statePressTimes[i]!==0){
                const pressDuration = Date.now() - statePressTimes[i];
                if(pressDuration >= 700){
                    const currentState = getCurrentAppState();
                    delete currentState.savedStates;
                    savedStates[i] = currentState;
                    btn.style.backgroundColor="var(--highlight-color)";
                    setTimeout(()=>{btn.style.backgroundColor=""; updateStateBtnUI();},600);
                } else {
                    if(savedStates[i]){
                        setTimeout(() => { 
                          applySavedAppState(savedStates[i]);
                        }, 0);
                        btn.style.backgroundColor="green";
                        setTimeout(()=>{btn.style.backgroundColor="";},600);
                    } else {
                        btn.style.backgroundColor="lightcoral";
                        setTimeout(()=>{btn.style.backgroundColor="";},600);
                    }
                }
                statePressTimes[i]=0;
            }
        });
        btn.addEventListener("touchcancel",()=>{ statePressTimes[i]=0; });
    });
    
    if(recordMasterBtnEl) recordMasterBtnEl.addEventListener('click', function(){
        if(!masterOutputRecorder) { return; }
        if(audioContext.state === 'suspended') audioContext.resume();

        if(masterOutputRecorder.state === 'inactive'){
            masterRecordedChunksForMaster = [];
            try {
                masterOutputRecorder.start();
                this.textContent="Detener Grab. Master";
                this.style.backgroundColor="red";
                if(playMasterBufferBtnEl) playMasterBufferBtnEl.disabled = true;
                if(pauseMasterBufferBtnEl) pauseMasterBufferBtnEl.disabled = true;
                if(downloadMasterBtnEl) downloadMasterBtnEl.disabled = true;
            } catch (recErr) {
                console.error("Error al iniciar grabación del master:", recErr);
            }
        } else if (masterOutputRecorder.state === 'recording'){
            masterOutputRecorder.stop();
            this.textContent="Grabar Master";
            this.style.backgroundColor="";
        }
    });
    
    function setupMasterRecorder() {
        if(!audioContext || !finalOutputGain) { return; }
        if(audioContext.createMediaStreamDestination){
            const mediaStreamDestNode = audioContext.createMediaStreamDestination();
            window.masterAudioStreamDestinationNode = mediaStreamDestNode;
            try {
                finalOutputGain.connect(mediaStreamDestNode);
            } catch (e) {
                console.error("Error conectando finalOutputGain a masterAudioStreamDestinationNode en setupMasterRecorder:", e);
                return;
            }

            masterOutputRecorder = new MediaRecorder(mediaStreamDestNode.stream);
            masterRecordedChunksForMaster = [];
            masterOutputRecorder.ondataavailable = (event) => {
                if (event.data && event.data.size > 0) masterRecordedChunksForMaster.push(event.data);
            };
            masterOutputRecorder.onstop = async () => {
              if (masterRecordedChunksForMaster.length === 0) {
                if(playMasterBufferBtnEl) playMasterBufferBtnEl.disabled = true;
                if(downloadMasterBtnEl) downloadMasterBtnEl.disabled = true;
                return;
              }
              const blob = new Blob(masterRecordedChunksForMaster, {type: 'audio/webm;codecs=opus'});
              masterRecordedChunksForMaster = [];
              
              const reader = new FileReader();
              reader.onload = async (fileReaderEvent) => {
                try {
                    if(fileReaderEvent.target.result instanceof ArrayBuffer){
                        masterRecordedAudioBuffer = await audioContext.decodeAudioData(fileReaderEvent.target.result);
                        masterRecordingStartOffset = 0;
                        if(masterDurationDisplay) masterDurationDisplay.textContent = formatTime(masterRecordedAudioBuffer.duration);
                        if(masterTimelineFader) {
                            localUpdateRangeParamProgrammatic(masterTimelineFader, 0);
                            masterTimelineFader.max = masterRecordedAudioBuffer.duration;
                        }
                        if(playMasterBufferBtnEl) playMasterBufferBtnEl.disabled = false;
                        if(pauseMasterBufferBtnEl) pauseMasterBufferBtnEl.disabled = true;
                        if(downloadMasterBtnEl) downloadMasterBtnEl.disabled = false;
                        updateMasterRecordingTimelineDisplay(true);
                    }
                } catch(decodeErr) { console.error("Error al decodificar audio del master grabado:", decodeErr); }
              };
              reader.onerror = (err) => { console.error("Error de FileReader en grabación del master:",err); };
              reader.readAsArrayBuffer(blob);
            };
        } else {
            console.warn("MediaStreamDestination API no soportada. Grabación de Master deshabilitada.");
            if(recordMasterBtnEl) recordMasterBtnEl.disabled = true;
            if(downloadMasterBtnEl) downloadMasterBtnEl.disabled = true;
        }
    }

    function playMasterRecordedAudio(){
        if(!masterRecordedAudioBuffer) return;
        if(audioContext.state === 'suspended') audioContext.resume();

        if(masterBufferSourceNode) {
            try { masterBufferSourceNode.onended = null; masterBufferSourceNode.stop(); masterBufferSourceNode.disconnect(); } catch(e){}
        }
        masterBufferSourceNode = audioContext.createBufferSource();
        masterBufferSourceNode.buffer = masterRecordedAudioBuffer;
        masterBufferSourceNode.connect(audioContext.destination);

        const validOffset = Math.max(0, Math.min(masterRecordingStartOffset, masterRecordedAudioBuffer.duration));
        masterBufferSourceNode.start(0, validOffset);
        masterRecordingStartTime = audioContext.currentTime - validOffset;
        isMasterRecordingPlaying = true;

        if(playMasterBufferBtnEl) playMasterBufferBtnEl.textContent="Pause Grab.";
        if(pauseMasterBufferBtnEl) pauseMasterBufferBtnEl.disabled = false;

        masterBufferSourceNode.onended = () => {
            if (masterBufferSourceNode && isMasterRecordingPlaying && !masterBufferSourceNode.loop) {
                const expectedEndTime = masterRecordingStartTime + masterRecordedAudioBuffer.duration;
                if (audioContext.currentTime >= expectedEndTime - 0.1 || masterRecordingStartOffset >= masterRecordedAudioBuffer.duration) {
                    isMasterRecordingPlaying = false;
                    masterRecordingStartOffset = 0;
                    if(playMasterBufferBtnEl) playMasterBufferBtnEl.textContent="Play Grab.";
                    if(pauseMasterBufferBtnEl) pauseMasterBufferBtnEl.disabled = true;
                }
            }
            if(masterBufferSourceNode && masterBufferSourceNode.onended === arguments.callee) {
                masterBufferSourceNode = null;
            }
        };
    }

    function pauseMasterRecordedAudio(){
        if(isMasterRecordingPlaying && masterBufferSourceNode){
            try { masterBufferSourceNode.stop(); } catch(e){}
            masterRecordingStartOffset = (audioContext.currentTime - masterRecordingStartTime);
            masterRecordingStartOffset = Math.max(0, Math.min(masterRecordingStartOffset, masterRecordedAudioBuffer.duration));
            
            isMasterRecordingPlaying = false;
            if(playMasterBufferBtnEl) playMasterBufferBtnEl.textContent="Play Grab.";
            if(pauseMasterBufferBtnEl) pauseMasterBufferBtnEl.disabled = true;
        }
    }
    
    if(playMasterBufferBtnEl){
        playMasterBufferBtnEl.disabled = true;
        playMasterBufferBtnEl.addEventListener('click', () => {
            if(!masterRecordedAudioBuffer) return;
            if(!isMasterRecordingPlaying) playMasterRecordedAudio();
            else pauseMasterRecordedAudio();
        });
    }
    if(pauseMasterBufferBtnEl){
        pauseMasterBufferBtnEl.disabled = true;
        pauseMasterBufferBtnEl.addEventListener('click', () => {
            if(isMasterRecordingPlaying) pauseMasterRecordedAudio();
        });
    }

    if(masterTimelineFader) masterTimelineFader.addEventListener('input', () => {
        if(masterRecordedAudioBuffer){
            const newTime = parseFloat(masterTimelineFader.value);
            if(!isMasterRecordingPlaying) {
                 masterRecordingStartOffset = newTime;
                 if(masterCurrentTimeDisplay) masterCurrentTimeDisplay.textContent = formatTime(masterRecordingStartOffset);
            }
        }
    });
    if(masterTimelineFader) masterTimelineFader.addEventListener('change', () => {
        if(masterRecordedAudioBuffer){
            const newTime = parseFloat(masterTimelineFader.value);
            masterRecordingStartOffset = newTime;
            if(masterCurrentTimeDisplay) masterCurrentTimeDisplay.textContent = formatTime(masterRecordingStartOffset);
            if(isMasterRecordingPlaying){
                if(masterBufferSourceNode) try { masterBufferSourceNode.stop(); } catch(e){}
                playMasterRecordedAudio();
            }
        }
    });

    function updateMasterRecordingTimelineDisplay(forceUpdate = false){
       if (!isMasterRecordingPlaying && !forceUpdate) return;
        
        let currentTimePoint = masterRecordingStartOffset;
        if (isMasterRecordingPlaying && masterRecordedAudioBuffer && audioContext) {
            currentTimePoint = audioContext.currentTime - masterRecordingStartTime;
            if (currentTimePoint < 0) currentTimePoint = 0;
            if (currentTimePoint >= masterRecordedAudioBuffer.duration) {
                currentTimePoint = masterRecordedAudioBuffer.duration;
            }
        }
        
        if (masterTimelineFader) {
            masterTimelineFader.value = currentTimePoint;
            const numInput = document.getElementById('masterTimelineValueInput');
            if (numInput) numInput.value = parseFloat(currentTimePoint).toFixed(1);
        }
        if (masterCurrentTimeDisplay) masterCurrentTimeDisplay.textContent = formatTime(currentTimePoint);
    }

    function audioBufferToWavBlob(audioBuff, opt = {}) {
        const numChannels = audioBuff.numberOfChannels;
        const sampleRate = audioBuff.sampleRate;
        const format = opt.float32 ? 3 : 1;
        const bitDepth = format === 3 ? 32 : 16;

        let channels = [];
        for (let i = 0; i < numChannels; i++) channels.push(audioBuff.getChannelData(i));
        
        const totalFrames = audioBuff.length;
        const interleavedResult = new Float32Array(totalFrames * numChannels);
        for (let frame = 0; frame < totalFrames; frame++) {
            for (let ch = 0; ch < numChannels; ch++) {
                interleavedResult[frame * numChannels + ch] = channels[ch][frame];
            }
        }

        const dataLengthBytes = interleavedResult.length * (bitDepth / 8);
        const wavHeaderLength = 44;
        const totalFileLength = wavHeaderLength + dataLengthBytes;

        const wavArrayBuffer = new ArrayBuffer(totalFileLength);
        const view = new DataView(wavArrayBuffer);

        function writeStringToArrayView(dataView, offset, str) {
            for (let i = 0; i < str.length; i++) dataView.setUint8(offset + i, str.charCodeAt(i));
        }

        writeStringToArrayView(view, 0, 'RIFF');
        view.setUint32(4, wavHeaderLength - 8 + dataLengthBytes, true);
        writeStringToArrayView(view, 8, 'WAVE');
        writeStringToArrayView(view, 12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, format, true);
        view.setUint16(22, numChannels, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * numChannels * (bitDepth / 8), true);
        view.setUint16(32, numChannels * (bitDepth / 8), true);
        view.setUint16(34, bitDepth, true);
        writeStringToArrayView(view, 36, 'data');
        view.setUint32(40, dataLengthBytes, true);

        let byteOffset = wavHeaderLength;
        if (format === 1) {
            for (let i = 0; i < interleavedResult.length; i++, byteOffset += 2) {
                let s = Math.max(-1, Math.min(1, interleavedResult[i]));
                view.setInt16(byteOffset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
            }
        } else {
            for (let i = 0; i < interleavedResult.length; i++, byteOffset += 4) {
                view.setFloat32(byteOffset, interleavedResult[i], true);
            }
        }
        return new Blob([view], { type: 'audio/wav' });
    }

    if(downloadMasterBtnEl){
        downloadMasterBtnEl.disabled = true;
        downloadMasterBtnEl.addEventListener('click', () => {
            if(masterRecordedAudioBuffer){
                const wavBlob = audioBufferToWavBlob(masterRecordedAudioBuffer, { float32: false });
                const downloadUrl = URL.createObjectURL(wavBlob);
                const anchor = document.createElement('a');
                anchor.style.display = 'none';
                anchor.href = downloadUrl;
                const dateString = new Date().toISOString().slice(0,19).replace(/-/g,'').replace(/:/g,'').replace('T','_');
                anchor.download = `SUSPIRA_Master_${dateString}.wav`;
                document.body.appendChild(anchor);
                anchor.click();
                document.body.removeChild(anchor);
                URL.revokeObjectURL(downloadUrl);
            } else {
                alert("Graba algo en el Master para descargarlo.");
            }
        });
    }
    
    function triggerSampleOn(loopIndex) {
        if (!mainRecorderAudioBuffer || activeSamplers[loopIndex]) return;

        const selection = sampleSelections[loopIndex];
        if (selection.start >= selection.end) return;
        
        const isReversed = loopReverseBtns[loopIndex] ? loopReverseBtns[loopIndex].getAttribute('aria-pressed') === 'true' : false;
        const currentSpeed = loopSpeedControls[loopIndex] ? parseFloat(loopSpeedControls[loopIndex].value) : 1;
        const useFlexPitch = loopFlexPitchBtns[loopIndex] ? loopFlexPitchBtns[loopIndex].getAttribute('aria-pressed') === 'true' : false;

        let segment = extractAudioBufferSegment(mainRecorderAudioBuffer, selection.start, selection.end, audioContext);
        if (!segment) return;

        if (isReversed) {
            segment = createReversedAudioBuffer(segment);
            if (!segment) return;
        }

        let bufferToPlay = segment;
        let finalPlaybackRate = currentSpeed;

        if (useFlexPitch && currentSpeed !== 1.0 && audioWorker) {
            const cacheKey = `${loopIndex}_${mainRecorderAudioBufferId}_sample_s${selection.start.toFixed(4)}_e${selection.end.toFixed(4)}_r${isReversed}_v${currentSpeed.toFixed(2)}`;
            if(flexPitchCache[loopIndex] && flexPitchCache[loopIndex][cacheKey]){
                bufferToPlay = flexPitchCache[loopIndex][cacheKey];
                finalPlaybackRate = 1.0;
            } else {
                finalPlaybackRate = currentSpeed;
                const transferableChannels = [];
                 for(let i=0; i < segment.numberOfChannels; i++) {
                    transferableChannels.push(segment.getChannelData(i).slice(0));
                }
                 audioWorker.postMessage({
                    audioBufferChannels: transferableChannels,
                    sampleRate: segment.sampleRate,
                    rateFactor: currentSpeed,
                    cacheKey: cacheKey
                }, transferableChannels.map(ch => ch.buffer));
            }
        }
        
        if (!bufferToPlay || bufferToPlay.duration <= 0.001) {
            return;
        }

        const source = audioContext.createBufferSource();
        source.buffer = bufferToPlay;
        source.playbackRate.value = finalPlaybackRate;
        
        const gainNode = audioContext.createGain();
        source.connect(gainNode);
        gainNode.connect(loopVolumeGains[loopIndex]);

        const now = audioContext.currentTime;
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(1, now + 0.01);

        source.start(now);
        
        source.onended = () => {
            if (activeSamplers[loopIndex] && activeSamplers[loopIndex].source === source) {
                activeSamplers[loopIndex] = null;
            }
        };

        activeSamplers[loopIndex] = { source, gain: gainNode };
    }

    function triggerSampleOff(loopIndex) {
        if (!activeSamplers[loopIndex]) return;

        const { source, gain } = activeSamplers[loopIndex];
        const now = audioContext.currentTime;
        const releaseTime = 0.02;

        gain.gain.cancelScheduledValues(now);
        gain.gain.setValueAtTime(gain.gain.value, now);
        gain.gain.linearRampToValueAtTime(0, now + releaseTime);

        try {
          source.stop(now + releaseTime);
        } catch(e) {}
        activeSamplers[loopIndex] = null;
    }
    
    function setupMidi() {
        const midiMapBtn = document.getElementById('midiMapBtn');
        let midiAccess = null;

        midiMapBtn.addEventListener('click', () => {
            if (!midiAccess && navigator.requestMIDIAccess) {
                navigator.requestMIDIAccess()
                    .then(onMIDISuccess, onMIDIFailure);
            }

            isMidiMapping = !isMidiMapping;
            document.body.classList.toggle('midi-mapping-active', isMidiMapping);
            midiMapBtn.classList.toggle('active', isMidiMapping);

            if (isMidiMapping) {
                console.log("MAPEADO MIDI ACTIVADO: Haz clic en un control y mueve un knob/fader/botón en tu controlador.");
            } else {
                console.log("MAPEADO MIDI DESACTIVADO.");
                if (elementToMap) {
                    if(elementToMap.classList) elementToMap.classList.remove('control-listening');
                    if(elementToMap.element && elementToMap.element.classList) elementToMap.element.classList.remove('control-listening');
                    elementToMap = null;
                }
            }
        });

        document.querySelectorAll('.mappable').forEach(el => {
            el.addEventListener('click', (e) => {
                if (isMidiMapping) {
                    e.preventDefault();
                    e.stopPropagation();

                    if (elementToMap) {
                        if(elementToMap.classList) elementToMap.classList.remove('control-listening');
                        if(elementToMap.element && elementToMap.element.classList) elementToMap.element.classList.remove('control-listening');
                    }
                    elementToMap = el;
                    elementToMap.classList.add('control-listening');
                    console.log(`Escuchando MIDI para el control: ${el.id || el.dataset.paramId}`);
                }
            });
        });

        function onMIDISuccess(ma) {
            midiAccess = ma;
            console.log("Acceso MIDI concedido.");
            
            function refreshMidiInputs() {
                for (let input of midiAccess.inputs.values()) {
                    input.onmidimessage = null;
                }
                for (let input of midiAccess.inputs.values()) {
                    input.onmidimessage = onMidiMessage;
                    console.log(`Escuchando en el dispositivo MIDI: ${input.name}`);
                }
            }
            
            refreshMidiInputs();
            
            midiAccess.onstatechange = (event) => {
                console.log(`Cambio de estado MIDI: ${event.port.name}, ${event.port.state}`);
                refreshMidiInputs();
            };
        }

        function onMIDIFailure() {
            console.error("No se pudo acceder a los dispositivos MIDI.");
            alert("No se pudo acceder a los dispositivos MIDI. Por favor, revisa la configuración de este sitio en tu navegador (haz clic en el candado en la barra de direcciones) y asegúrate de que el permiso para 'Dispositivos MIDI' esté activado. Luego, recarga la página.");
        }
        
        if (navigator.mediaDevices && navigator.mediaDevices.ondevicechange !== undefined) {
            navigator.mediaDevices.addEventListener('devicechange', initAudioDevicesList);
        }

        if (!navigator.requestMIDIAccess) {
            console.warn("Web MIDI API no está soportada en este navegador.");
            if(midiMapBtn) midiMapBtn.disabled = true;
        }
    }

    function onMidiMessage(event) {
        const command = event.data[0] & 0xf0;
        const number = event.data[1];
        const value = event.data.length > 2 ? event.data[2] : 0;

        if (isMidiMapping && elementToMap) {
            let key;
            let type;
            if (command === 0xB0) { // Control Change
                key = `cc_${number}`;
                type = 'CC';
            } else if (command === 0x90 && value > 0) { // Note On
                key = `note_${number}`;
                type = 'Note';
            } else {
                return; 
            }

            midiMap[key] = { id: elementToMap.id };
            console.log(`Control MIDI ${type} #${number} mapeado a ${elementToMap.id}`);
            
            if(elementToMap.classList) elementToMap.classList.remove('control-listening');
            if(elementToMap.element && elementToMap.element.classList) elementToMap.element.classList.remove('control-listening');
            elementToMap = null;
            isMidiMapping = false;
            document.body.classList.remove('midi-mapping-active');
            document.getElementById('midiMapBtn').classList.remove('active');
            return;
        }

        let key;
        if (command === 0xB0) key = `cc_${number}`;
        else if (command === 0x90 || command === 0x80) key = `note_${number}`;
        else return;

        const mapping = midiMap[key];
        if (!mapping) return;

        if (mapping.id.startsWith('granulator_point_')) {
            if (command === 0xB0) { 
                const normalizedValue = value / 127.0;
                updateParameterProgrammatically(mapping.id, normalizedValue);
            }
            return;
        }


        const targetElement = document.getElementById(mapping.id);
        if (!targetElement) return;

        function handleSwitchToggle(element) {
            element.click();
        }

        if (command === 0xB0) { // CC
            const normalizedValue = value / 127.0;

            if (targetElement.classList.contains('dial')) {
                const min = parseFloat(targetElement.dataset.min);
                const max = parseFloat(targetElement.dataset.max);
                const newValue = min + normalizedValue * (max - min);
                localUpdateDialParamProgrammatic(targetElement, newValue);
            } else if (targetElement.type === 'range') {
                const min = parseFloat(targetElement.min);
                const max = parseFloat(targetElement.max);
                const newValue = min + normalizedValue * (max - min);
                localUpdateRangeParamProgrammatic(targetElement, newValue);
            } else {
                const lastValue = lastCCValues[number] || 0;
                const threshold = 64;
                if (value >= threshold && lastValue < threshold) {
                    if (targetElement.classList.contains('toggle-switch-input') || targetElement.classList.contains('loop-action-btn')) {
                        handleSwitchToggle(targetElement);
                    } else if (targetElement.id.startsWith('loopCanvas')) {
                         const sampleIndex = parseInt(targetElement.id.replace('loopCanvas', '')) - 1;
                         if (!isNaN(sampleIndex)) triggerSampleOn(sampleIndex);
                    } else if (targetElement.tagName === 'BUTTON') {
                        targetElement.click();
                    }
                }
                lastCCValues[number] = value;
            }
        } else if (command === 0x90 && value > 0) { // Note On
             if (targetElement.classList.contains('toggle-switch-input') || targetElement.classList.contains('loop-action-btn')) {
                handleSwitchToggle(targetElement);
             } else if (targetElement.id.startsWith('loopCanvas')) {
                const sampleIndex = parseInt(targetElement.id.replace('loopCanvas', '')) - 1;
                if (!isNaN(sampleIndex)) triggerSampleOn(sampleIndex);
             } else if (targetElement.tagName === 'BUTTON') {
                targetElement.click();
             }
        } else if (command === 0x80 || (command === 0x90 && value === 0)) { // Note Off
             if (targetElement.id.startsWith('loopCanvas')) {
                const sampleIndex = parseInt(targetElement.id.replace('loopCanvas', '')) - 1;
                if (!isNaN(sampleIndex)) triggerSampleOff(sampleIndex);
             }
        }
    }
    
    function setupGlobalKeyListeners(){
    document.addEventListener('keydown',(e)=>{
        const activeEl = document.activeElement;
        const isTextInputActive = activeEl && (
            (activeEl.tagName === 'INPUT' && (activeEl.type === 'text' || activeEl.type === 'number')) ||
            activeEl.tagName === 'TEXTAREA' ||
            activeEl.tagName === 'SELECT' ||
            activeEl.isContentEditable
        );

            if(e.repeat || isTextInputActive) {
                return;
            }
            
            const key = e.key;

            if (key === 'Backspace') {
                e.preventDefault();
                if (undoDrawingBtn) undoDrawingBtn.click();
                return;
            }
            
            if(e.code==='Space' && playPauseBtn){
                e.preventDefault();
                playPauseBtn.click();
                return;
            }

            if (key.toUpperCase() === 'P') {
                stopAutomationRecording();
                e.preventDefault();
            }
            
            switch(key.toUpperCase()){
                case 'W':
                    document.getElementById('spectralSynthDrawModeSwitch')?.click();
                    break;
                case 'E': 
                    if(spectralSynthPowerSwitch) {
                        spectralSynthPowerSwitch.checked = !spectralSynthPowerSwitch.checked;
                        spectralSynthPowerSwitch.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                    break;
                case'R': if(recordBtn&&!recordBtn.disabled)recordBtn.click();break;
                case'T': if(stopRecBtn&&!stopRecBtn.disabled)stopRecBtn.click();break;
                case'G': if(granulatorPlayToggleBtn&&!granulatorPlayToggleBtn.disabled)toggleGranulator();break;
                case'Y': if(appendRecBtn&&!appendRecBtn.disabled) appendRecBtn.click();break;
                case'U': if(overdubNowBtn&&!overdubNowBtn.disabled)overdubNowBtn.click();break;
                case'A': if(loopPlayPauseBtns[0]&&!loopPlayPauseBtns[0].disabled)loopPlayPauseBtns[0].click();break;
                case'S': if(loopPlayPauseBtns[1]&&!loopPlayPauseBtns[1].disabled)loopPlayPauseBtns[1].click();break;
                case'D': if(loopPlayPauseBtns[2]&&!loopPlayPauseBtns[2].disabled)loopPlayPauseBtns[2].click();break;
                case'M': if(recordMasterBtnEl&&!recordMasterBtnEl.disabled)recordMasterBtnEl.click();break;
            }

            switch(key) {
                case'1': if(memButtons[0]&&!memButtons[0].disabled)memButtons[0].click(); break;
                case'2': if(memButtons[1]&&!memButtons[1].disabled)memButtons[1].click(); break;
                case'3': if(memButtons[2]&&!memButtons[2].disabled)memButtons[2].click(); break;
                case'4': if(memButtons[3]&&!memButtons[3].disabled)memButtons[3].click(); break;
                case'5': triggerSampleOn(0); break;
                case'6': triggerSampleOn(1); break;
                case'7': triggerSampleOn(2); break;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            const activeEl = document.activeElement;
            const isTextInputActive = activeEl && (
                (activeEl.tagName === 'INPUT' && (activeEl.type === 'text' || activeEl.type === 'number')) ||
                activeEl.tagName === 'TEXTAREA' ||
                activeEl.tagName === 'SELECT' ||
                activeEl.isContentEditable
            );

            if(isTextInputActive) {
                return;
            }

            switch(e.key){
                case '5': triggerSampleOff(0); break;
                case '6': triggerSampleOff(1); break;
                case '7': triggerSampleOff(2); break;
            }
        });
    }

    function setupSpectralSynthEventListeners() {
        if (!spectrumCanvas) return;

        if (spectralSynthDrawModeSwitch) {
            spectralSynthDrawModeSwitch.addEventListener('change', (e) => {
                isDrawModeActive = e.target.checked;
                if (!isDrawModeActive) {
                    stopSpectralSynth();
                }
            });
        }
        
        if (undoDrawingBtn) {
            undoDrawingBtn.addEventListener('click', () => {
                if(drawnPaths.length > 1) {
                    drawnPaths.pop();
                } else if (drawnPaths.length === 1 && drawnPaths[0].length > 0) {
                    drawnPaths = [[]];
                }
                
                if (pathPlaybackRequestID !== null) {
                    stopPathPlayback();
                    if (drawnPaths.flat().length > 0) {
                        startPathPlayback();
                    }
                }
            });
        }
        
        spectrumCanvas.addEventListener('mouseenter', (e) => {
             if (spectralSynthPowerSwitch && spectralSynthPowerSwitch.checked && mainRecorderAudioBuffer && isDrawModeActive) {
                if(audioContext.state === 'suspended') audioContext.resume();
                
                if (!isDrawingPath && pathPlaybackRequestID === null) {
                     const rect = spectrumCanvas.getBoundingClientRect();
                     const scaleX = spectrumCanvas.width / rect.width;
                     const scaleY = spectrumCanvas.height / rect.height;
                     const x = ((e.clientX - rect.left) * scaleX) / spectrumCanvas.width;
                     const y = ((e.clientY - rect.top) * scaleY) / spectrumCanvas.height;
                     lastSpectralCoords = { x: Math.max(0, Math.min(x, 1)), y: Math.max(0, Math.min(y, 1)), active: true };
                     startSpectralSynth();
                }
             }
        });
        
        if(spectralSynthPowerSwitch) {
            spectralSynthPowerSwitch.disabled = !mainRecorderAudioBuffer;
            spectralSynthPowerSwitch.addEventListener('change', (e) => {
                const hasDrawing = drawnPaths.flat().length > 0;
                if (e.target.checked) {
                    if (hasDrawing) {
                        startPathPlayback();
                    } else if (spectrumCanvas.matches(':hover')) {
                        startSpectralSynth();
                    }
                } else {
                    stopSpectralSynth();
                    stopPathPlayback();
                }
            });
        }

        if(clearDrawingBtn) {
            clearDrawingBtn.addEventListener('click', () => {
                drawnPaths = [[]];
                stopPathPlayback();
                
                const isMouseOverCanvas = spectrumCanvas.matches(':hover');
                if (isMouseOverCanvas && spectralSynthPowerSwitch.checked && !isSpectralSynthActive && isDrawModeActive) {
                    startSpectralSynth();
                } else if (!isMouseOverCanvas && isSpectralSynthActive) {
                    stopSpectralSynth();
                }
            });
        }
    }

    function scheduleNextSpectralGrain() {
        if (!isSpectralSynthActive || !mainRecorderAudioBuffer || !lastSpectralCoords.active || pathPlaybackRequestID !== null) {
            return;
        }

        if (currentSpectralSynthSource) {
            try { currentSpectralSynthSource.stop(0); } catch(e) {}
            currentSpectralSynthSource = null;
        }
        
        const grainLength = 0.1; 
        const bufferDuration = mainRecorderAudioBuffer.duration;

        let startPosition = lastSpectralCoords.x * (bufferDuration - grainLength);
        startPosition = Math.max(0, Math.min(startPosition, bufferDuration - grainLength));

        const source = audioContext.createBufferSource();
        source.buffer = mainRecorderAudioBuffer;

        const envelope = audioContext.createGain();
        source.connect(envelope);
        envelope.connect(spectralSynthInputGain);

        const now = audioContext.currentTime;
        const fadeIn = grainLength * 0.5;
        
        envelope.gain.setValueAtTime(0, now);
        envelope.gain.linearRampToValueAtTime(1, now + fadeIn);
        envelope.gain.linearRampToValueAtTime(0, now + grainLength);
        
        source.start(now, startPosition, grainLength);
        currentSpectralSynthSource = source;
        source.onended = () => {
            if (currentSpectralSynthSource === source) currentSpectralSynthSource = null;
            try { source.disconnect(); envelope.disconnect(); } catch(e){}
        };
        
        const finalDelay = 50;
        spectralSynthTimeoutId = setTimeout(scheduleNextSpectralGrain, finalDelay);
    }

    function startPathPlayback() {
        if (pathPlaybackRequestID || !spectralSynthPowerSwitch.checked) return;
        
        stopSpectralSynth();
        pathPlaybackIndex = 0;

        function playbackLoop() {
            if (!spectralSynthPowerSwitch.checked) { 
                stopPathPlayback();
                return; 
            }
            const currentPath = drawnPaths.flat();
            if (currentPath.length < 1) { 
                stopPathPlayback();
                return; 
            }

            const currentPoint = currentPath[pathPlaybackIndex];
            lastSpectralCoords = { x: currentPoint.x, y: currentPoint.y, active: true };
            updateSpectralSynthFilters();
            
            playGrainAtCurrentPathPosition();

            pathPlaybackIndex++;
            if (pathPlaybackIndex >= currentPath.length) {
                pathPlaybackIndex = 0;
            }
            
            const finalDelay = 50;
            pathPlaybackRequestID = setTimeout(playbackLoop, finalDelay);
        }
        playbackLoop();
    }

    function stopPathPlayback() {
        if (pathPlaybackRequestID) {
            clearTimeout(pathPlaybackRequestID);
            pathPlaybackRequestID = null;
        }
    }

    function playGrainAtCurrentPathPosition() {
        if (!mainRecorderAudioBuffer || !lastSpectralCoords.active) return;
        
        if (currentSpectralSynthSource) {
            try { currentSpectralSynthSource.stop(0); } catch(e) {}
            currentSpectralSynthSource = null;
        }

        const grainLength = 0.1;
        const bufferDuration = mainRecorderAudioBuffer.duration;
        let startPosition = lastSpectralCoords.x * (bufferDuration - grainLength);
        startPosition = Math.max(0, Math.min(startPosition, bufferDuration - grainLength));

        const source = audioContext.createBufferSource();
        source.buffer = mainRecorderAudioBuffer;
        const envelope = audioContext.createGain();
        source.connect(envelope);
        envelope.connect(spectralSynthInputGain);

        const now = audioContext.currentTime;
        const fadeIn = grainLength * 0.5;
        
        envelope.gain.setValueAtTime(0, now);
        envelope.gain.linearRampToValueAtTime(1, now + fadeIn);
        envelope.gain.linearRampToValueAtTime(0, now + grainLength);
        
        source.start(now, startPosition, grainLength);
        currentSpectralSynthSource = source;
        source.onended = () => {
            if (currentSpectralSynthSource === source) currentSpectralSynthSource = null;
            try { source.disconnect(); envelope.disconnect(); } catch(e){}
        };
    }

    function updateSpectralSynthFilters() {
        if (!lastSpectralCoords.active) return;
        const centerFreqNormalized = 1 - lastSpectralCoords.y;
        const brushSizeNormalized = 0.1; 

        spectralFilterBank.forEach((channel, i) => {
            const filterPosNormalized = i / (SPECTRAL_FILTER_COUNT - 1);
            const distance = Math.abs(filterPosNormalized - centerFreqNormalized);
            
            let gainValue = 0;
            if (distance < brushSizeNormalized) {
                gainValue = 1.0 - (distance / brushSizeNormalized);
                gainValue = Math.pow(gainValue, 2);
            }
            
            channel.gainNode.gain.setTargetAtTime(gainValue, audioContext.currentTime, 0.015);
        });
    }
    
    function startSpectralSynth() {
        if (isSpectralSynthActive) return;
        isSpectralSynthActive = true;
        updateSpectralSynthFilters();
        scheduleNextSpectralGrain();
    }

    function stopSpectralSynth() {
        if (!isSpectralSynthActive) return;
        isSpectralSynthActive = false;
        if (spectralSynthTimeoutId) {
            clearTimeout(spectralSynthTimeoutId);
            spectralSynthTimeoutId = null;
        }
        spectralFilterBank.forEach(channel => {
            channel.gainNode.gain.cancelScheduledValues(audioContext.currentTime);
            channel.gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.2);
        });
    }

    function setupAutomationMemories() {
        memButtons.forEach((button, index) => {
            if (!button) return;
            button.addEventListener('click', () => {
                const now = performance.now();
                const DOUBLE_CLICK_THRESHOLD = 400; 

                if (now - memBtnLastClickTime[index] < DOUBLE_CLICK_THRESHOLD) {
                    if (automationMemories[index]) {
                        stopAutomationPlayback(index);
                        automationMemories[index] = null;
                        console.log(`Automation memory in slot ${index + 1} deleted.`);
                        updateAutomationBtnUI();
                    }
                    memBtnLastClickTime[index] = 0;
                } else {
                    memBtnLastClickTime[index] = now;
                    const state = automationPlaybackStates[index];
                    if (state.isPlaying) {
                        stopAutomationPlayback(index);
                    } else if (automationMemories[index]) {
                        playAutomation(index);
                    } else {
                        armAutomationSlot(index);
                    }
                }
            });
        });
    }

    function updateAutomationBtnUI() {
        memButtons.forEach((btn, i) => {
            if (!btn) return;
            btn.classList.remove('automation-armed', 'automation-has-data', 'automation-playing');
            btn.style.animation = '';

            const state = automationPlaybackStates[i];

            if (state.isPlaying) {
                btn.classList.add('automation-playing');
            } else if (armedAutomationSlot === i) {
                btn.classList.add('automation-armed');
                btn.style.animation = 'blink-red 1s infinite';
            } else if (automationMemories[i] && automationMemories[i].length > 0) {
                btn.classList.add('automation-has-data');
            }
        });
    }

    function armAutomationSlot(index) {
        if (isRecordingAutomation) return;
        
        automationPlaybackStates.forEach((state, i) => {
            if(state.isPlaying) stopAutomationPlayback(i);
        });

        if (armedAutomationSlot === index) {
            armedAutomationSlot = -1;
        } else {
            armedAutomationSlot = index;
            automationMemories[index] = null; 
        }
        updateAutomationBtnUI();
    }

    function startAutomationRecording(controlId, value) {
        isRecordingAutomation = true;
        automationRecordingStartTime = performance.now();
        tempAutomationSequence = [];
        console.log(`Automation recording started for slot ${armedAutomationSlot + 1}`);
        
        recordAutomationEvent(controlId, value, true);
        updateAutomationBtnUI();
    }
    
    window.recordAutomationEvent = function(controlId, value, isFirstEvent = false) {
        if (armedAutomationSlot !== -1 && !isRecordingAutomation) {
            startAutomationRecording(controlId, value);
            return;
        }

        if (isRecordingAutomation) {
            let timestamp = isFirstEvent ? 0 : performance.now() - automationRecordingStartTime;
            tempAutomationSequence.push({ id: controlId, value: value, time: timestamp });
        }
    }

    function stopAutomationRecording() {
        if (!isRecordingAutomation) return;

        isRecordingAutomation = false;
        if (armedAutomationSlot !== -1 && tempAutomationSequence.length > 0) {
            automationMemories[armedAutomationSlot] = tempAutomationSequence;
            console.log(`Automation recorded to slot ${armedAutomationSlot + 1} with ${tempAutomationSequence.length} events.`);
        } else if (armedAutomationSlot !== -1) {
             automationMemories[armedAutomationSlot] = null;
             console.log(`Automation recording for slot ${armedAutomationSlot + 1} cancelled (no events).`);
        }
        
        armedAutomationSlot = -1;
        tempAutomationSequence = [];
        updateAutomationBtnUI();
    }

    function playAutomation(index) {
        const sequence = automationMemories[index];
        if (!sequence || sequence.length === 0 || automationPlaybackStates[index].isPlaying) return;

        automationPlaybackStates.forEach((state, i) => {
            if(state.isPlaying) stopAutomationPlayback(i);
        });
        
        const state = automationPlaybackStates[index];
        state.isPlaying = true;
        state.eventIndex = 0;
        state.startTime = performance.now();
        console.log(`Playing automation from slot ${index + 1}`);
        updateAutomationBtnUI();

        function playbackLoop() {
            if (!state.isPlaying) return;

            const elapsedTime = performance.now() - state.startTime;
            
            while (state.eventIndex < sequence.length && sequence[state.eventIndex].time <= elapsedTime) {
                const event = sequence[state.eventIndex];
                updateParameterProgrammatically(event.id, event.value);
                state.eventIndex++;
            }

            if (state.eventIndex >= sequence.length) {
                const totalDuration = sequence[sequence.length - 1].time;
                state.startTime = performance.now() - (elapsedTime - totalDuration);
                state.eventIndex = 0;
            }

            state.loopId = requestAnimationFrame(playbackLoop);
        }
        state.loopId = requestAnimationFrame(playbackLoop);
    }

    function stopAutomationPlayback(index) {
        const state = automationPlaybackStates[index];
        if (!state.isPlaying) return;

        cancelAnimationFrame(state.loopId);
        state.isPlaying = false;
        state.loopId = null;
        console.log(`Stopped automation playback for slot ${index + 1}`);
        updateAutomationBtnUI();
    }

    const infoBtn = document.getElementById('infoBtn');
    const infoModalOverlay = document.getElementById('info-modal-overlay');
    const infoModalCloseBtn = document.getElementById('info-modal-close-btn');

    function hideInfoModal() {
        if(infoModalOverlay) infoModalOverlay.classList.add('hidden');
    }

    function showInfoModal() {
        if (!infoModalOverlay || !audioContext) return;
        
        document.getElementById('info-audio-file-name').textContent = loadedAudioFileName || 'No hay archivo de audio en la fuente.';
        document.getElementById('info-sample-rate').textContent = `${audioContext.sampleRate} Hz`;
        
        const eqTableBody = document.getElementById('info-eq-table-body');
        eqTableBody.innerHTML = ''; 

        if (eqBandInstances && eqBandInstances.length > 0) {
            eqBandInstances.forEach((band, index) => {
                const filter = band.filterNode;
                if(filter) {
                    const row = eqTableBody.insertRow();
                    row.innerHTML = `
                        <td>${index + 1}</td>
                        <td>${filter.frequency.value.toFixed(2)}</td>
                        <td>${filter.gain.value.toFixed(2)}</td>
                        <td>${filter.Q.value.toFixed(2)}</td>
                    `;
                }
            });
        }
        
        infoModalOverlay.classList.remove('hidden');
    }

    if (infoBtn) infoBtn.addEventListener('click', showInfoModal);
    if (infoModalCloseBtn) infoModalCloseBtn.addEventListener('click', hideInfoModal);
    if (infoModalOverlay) infoModalOverlay.addEventListener('click', (e) => {
        if (e.target === infoModalOverlay) {
            hideInfoModal();
        }
    });

})();
</script>
</body>
</html>
