<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SUSPIRA - Playground de Síntesis </title>
  <script src="soundtouch-compiled.js"></script>
  <style>
    :root {
      --primary-bg-color: #303030;
      --secondary-bg-color: #222;
      --control-panel-bg: rgba(255, 255, 255, 0.85);
      --casilla-bg-color: #333;
      --text-color: #fff;
      --control-text-color: #000;
      --button-bg-color: #505050;
      --button-text-color: #fff;
      --border-color: #ccc;
      --highlight-color: #f0f;
      --loop-selection-bg: rgba(255, 255, 0, 0.3);
      --sample-selection-bg: rgba(0, 150, 255, 0.3);
      --font-main: 'Avenir', Arial, sans-serif;
      --switch-bg-off: #777;
      --switch-thumb-off: #ccc;
    }

    html {
      font-size: clamp(12px, 1.1vw, 16px);
    }

    *, *::before, *::after { box-sizing: border-box; }

    body {
      font-family: var(--font-main);
      font-size: 0.875rem;
      margin: 0;
      padding: 10px;
      background-color: var(--primary-bg-color);
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      min-height: calc(100vh - 20px);
      overflow-x: hidden;
      overflow-y: auto;
    }
    
    body.theater-mode-active {
        overflow: hidden;
    }

    h1, h2, h3, h4 { text-align: center; margin-top: 0.4em; margin-bottom: 0.4em; }
    h3 { font-size: 1.1em; }
    h4 { font-size: 0.95em; }

    button {
      cursor: pointer; padding: 4px 8px; border: none; border-radius: 3px;
      background-color: var(--button-bg-color); color: var(--button-text-color);
      font-family: inherit; font-size: 0.85rem; min-height: 26px;
      display: inline-flex; align-items: center; justify-content: center;
    }
    button:disabled {
      background-color: #383838;
      color: #777;
      cursor: not-allowed;
    }
    input[type="range"] { vertical-align: middle; min-height: 20px; }

    .dial-value-input,
    .fader-value-input,
    .loop-controls input[type="number"] {
        border: none;
        background-color: transparent;
        color: var(--text-color);
        padding: 1px 2px;
        margin-left: 3px;
        margin-right: 3px;
        font-family: inherit;
        -moz-appearance: textfield;
        appearance: textfield;
        cursor: default;
    }

    .dial-value-input::-webkit-outer-spin-button,
    .dial-value-input::-webkit-inner-spin-button,
    .fader-value-input::-webkit-outer-spin-button,
    .fader-value-input::-webkit-inner-spin-button,
    .loop-controls input[type="number"]::-webkit-outer-spin-button,
    .loop-controls input[type="number"]::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
    }

    .dial-value-input:focus,
    .fader-value-input:focus,
    .loop-controls input[type="number"]:focus {
        outline: 1px solid var(--highlight-color);
        background-color: rgba(80, 80, 80, 0.7);
        color: var(--text-color);
        cursor: text;
    }
    
    .dial-value-input {
        font-size: 0.7rem;
        min-width: 30px;
        width: auto;
        max-width: 65px;
        margin-top: 6px;
        text-align: center;
    }
    .fader-value-input {
        font-size: 0.75rem;
        width: 50px;
        text-align: right;
    }
     #masterTimelineContainer input[type="number"].fader-value-input,
     #timelineValueInput.fader-value-input {
        width: 60px;
    }

    .loop-controls input[type="number"] {
        width: 50px;
        font-size: 0.75rem;
        text-align: right;
        flex-shrink: 0;
    }
     .fader-containerloop input[type="number"].fader-value-input {
        position: absolute;
        bottom: -28px;
        left: 50%;
        transform: translateX(-50%);
        width: 45px;
        font-size: 0.65rem;
        text-align: center;
        padding: 2px;
    }


    label { display: inline-block; margin-right: 4px; font-size: 0.85rem; }
    select {
      font-size: 0.8rem; padding: 5px; height: 30px; border-radius: 3px;
      border: 1px solid var(--border-color); background-color: #fff; color: var(--control-text-color);
    }

    .main-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex-grow: 1;
        padding: 8px;
        gap: 8px;
        width: 100%;
    }

    .top-controls-grid {
        display: flex;
        flex-direction: row;
        gap: 1rem;
        width: 95%;
        max-width: 1800px;
        padding: 3px;
        align-items: stretch;
    }

    @media (max-width: 1024px) {
      .top-controls-grid {
        flex-direction: column;
        width: 98%;
      }
    }

    .column-left, .column-middle, .column-right {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .column-left { flex: 1; min-width: 250px; }
    .column-middle { flex: 2.5; min-width: 320px; }
    .column-right { flex: 1; min-width: 250px; }


    .casilla {
      background-color: var(--casilla-bg-color); padding: 8px; border-radius: 6px;
      border: 1px solid #555; display: flex; flex-direction: column; gap: 6px; position: relative;
    }
    .casilla h3, .casilla h4 { color: var(--text-color); margin-top: 0; margin-bottom: 0.25em; }
    .casilla label { color: var(--text-color); }

    #source-controls-casilla {
      position: relative;
      min-height: 145px;
    }
    
    #source-controls-casilla .control-panel { background-color: var(--secondary-bg-color); color: var(--text-color); border: 1px solid #444; padding: 6px; border-radius: 3px; }
    #source-controls-casilla .control-panel label, #source-controls-casilla .control-panel span { color: var(--text-color); }
    #sourceToggleButton {
        position: absolute; top: -2px; right: 4px; left: auto; width: 20px; height: 20px; padding: 0; margin: 0;
        background-color: transparent !important; color: var(--text-color); display: flex; justify-content: center;
        align-items: center; border: none; border-radius: 50%; cursor: pointer; z-index: 10;
    }
    #sourceToggleButton::before {
        content: ''; display: block; width: 2.5px; height: 2.5px; background-color: currentColor;
        border-radius: 50%; box-shadow: -5px 0 0 currentColor, 5px 0 0 currentColor;
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    }
    #micPanel, #filePanel { margin-top: 5px; min-height: auto; }
    .panel-controls-grid { display: flex; flex-direction: column; gap: 8px; width: 100%; padding-top: 3px; }
    .file-panel-top-row { display: flex; align-items: center; gap: 6px; }
    .file-panel-top-row #dropZoneTrigger {
        flex-grow: 1; text-align: center; padding: 5px 8px; min-height: 30px; font-size: 0.8rem;
        background-color: #666; border: 1px solid #777; border-radius: 3px;
    }
    .file-panel-top-row .file-panel-top-row-buttons { display: flex; gap: 4px; flex-shrink: 0; }
    .file-panel-top-row .file-panel-top-row-buttons button {
        padding: 4px; min-width: 30px; min-height: 30px; font-size: 0.9rem;
        background-color: var(--button-bg-color); border: 1px solid #585858; border-radius: 3px;
    }
    .file-panel-top-row .file-panel-top-row-buttons button#exportToBuffersBtn {
        font-size: 0.7rem;
        padding: 4px 6px;
    }
    .file-panel-top-row .file-panel-top-row-buttons button:hover:not(:disabled) { background-color: #606060; }
    
    .file-panel-volume-row { display: flex; align-items: center; gap: 6px; width: 100%; flex-wrap: wrap; }
    .file-panel-volume-row label[for="volumeFader"] { margin-right: 2px; flex-shrink: 0; font-size: 0.75rem; }
    .file-panel-volume-row #volumeFader { width: 60px; flex-shrink: 0; margin: 0; }
    .file-panel-volume-row .switch-control-row { flex-grow: 1; }

    .file-panel-bottom-row { display: flex; align-items: center; gap: 6px; width: 100%; flex-wrap: wrap; }
    .file-panel-bottom-row #timeline { flex-grow: 1; min-width: 40px; margin: 0; }
    .file-panel-bottom-row #currentTimeDisplay { min-width: 30px; text-align: right; flex-shrink: 0; font-size: 0.75rem; padding-left: 4px; }
    
    .mic-panel-top-row { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }
    .mic-panel-top-row select { flex-grow: 1; height: 30px; font-size: 0.75rem; border: 1px solid #585858; padding: 4px 6px; min-width: 120px; }
    
    .mic-panel-bottom-row { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }
    .mic-panel-bottom-row #micMuteBtn { flex-shrink: 0; padding: 5px 10px; min-height: 30px; font-size: 0.7rem; border: 1px solid #585858; border-radius: 3px; }
    .mic-panel-bottom-row #micMuteBtn[aria-pressed="true"] { background-color: #c04040; }
    .mic-panel-bottom-row #micMuteBtn[aria-pressed="true"]:hover { background-color: #d05050; }
    .mic-panel-bottom-row #micVolumeFader { flex-grow: 1; margin: 0; }
    .mic-panel-bottom-row .switch-control-row { justify-content: flex-end; }


    .switch-control-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      padding: 2px 0;
    }
    .switch-control-row label:first-child {
        font-size: 0.8rem;
    }
    .toggle-switch-container {
      display: inline-block;
      position: relative;
      width: 35px;
      height: 19px;
    }
    .toggle-switch-input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .toggle-switch-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--switch-bg-off);
      transition: .4s;
      border-radius: 19px;
      border: 1px solid #555;
    }
    .toggle-switch-slider:before {
      position: absolute;
      content: "";
      height: 14px;
      width: 14px;
      left: 2px;
      bottom: 1.5px;
      background-color: var(--switch-thumb-off);
      transition: .4s;
      border-radius: 50%;
    }
    .toggle-switch-input:checked + .toggle-switch-slider {
      background-color: var(--highlight-color);
    }
    .toggle-switch-input:focus + .toggle-switch-slider {
      box-shadow: 0 0 2px var(--highlight-color);
    }
    .toggle-switch-input:checked + .toggle-switch-slider:before {
      transform: translateX(16px);
      background-color: white;
    }

    .toggle-switch-container.small-switch {
        width: 28px;
        height: 15.2px;
    }
    .toggle-switch-container.small-switch .toggle-switch-slider {
        border-radius: 15.2px;
    }
    .toggle-switch-container.small-switch .toggle-switch-slider:before {
        height: 11.2px;
        width: 11.2px;
        left: 1.6px;
        bottom: 1.2px;
    }
    .toggle-switch-container.small-switch .toggle-switch-input:checked + .toggle-switch-slider:before {
        transform: translateX(12.8px);
    }

    #lfo-controls-casilla > div:first-of-type {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        margin-bottom: 8px;
    }
    #lfo-controls-casilla h4 { text-align: left; margin: 0; }
    #lfo-controls-casilla .control-row { display: flex; flex-direction:row; align-items: center; gap: 5px; }
    #lfo-controls-casilla label { font-size: 0.8rem; }
    #lfo-controls-casilla .control-row label { flex-shrink: 0; }
    #lfo-controls-casilla .control-row input[type="range"] { flex-grow: 1; }
    #lfo-controls-casilla .control-row input[type="number"].fader-value-input { width: 60px; flex-shrink: 0; }


    #reverb-eq-visualizer-casilla {
        gap: 8px;
        display: flex;
        flex-direction: column;
        align-items: stretch;
        flex-grow: 1;
        position: relative;
    }
    #reverb-eq-visualizer-casilla.theater-mode {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 2000;
        padding: 2rem;
        background-color: var(--primary-bg-color);
    }

     .reverb-eq-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .reverb-eq-header .header-buttons {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    #reverb-eq-visualizer-casilla canvas#spectrumCanvas {
        border: 1px solid #555; background-color: rgb(30, 30, 30);
        margin-bottom: 0;
        cursor: pointer;
        width: 100%;
        aspect-ratio: 2 / 1;
        object-fit: contain;
        display: block;
        min-height: 200px;
    }
    #reverb-eq-visualizer-casilla label.canvas-label { margin-top: 10px; margin-bottom: 5px; font-size: 1em; font-weight: bold; }

    #undoDrawingBtn, #midiMapBtn, #togglePatchBayBtn, #clearDrawingBtn, #toggleFullscreenBtn {
      font-size: 0.7rem; padding: 3px 6px; min-height: 22px;
    }
    #midiMapBtn.active {
      background-color: var(--highlight-color);
      color: white;
      box-shadow: 0 0 8px var(--highlight-color);
    }
    
    .actions-container {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        width: 100%;
        gap: 6px;
        margin-top: 10px;
    }
    .rec-action-buttons, .save-action-buttons { display: flex; flex-wrap: wrap; gap: 4px; }
    .rec-action-buttons { justify-content: flex-start; }
    .save-action-buttons { justify-content: flex-end; }
    .rec-action-buttons button, .save-action-buttons button { font-size: 0.7rem; padding: 4px 6px; flex-grow: 0; min-height: 24px; }

    #master-controls-casilla { display: flex; flex-direction: column; gap: 8px; }
    .master-timeline-and-buttons-container { display: flex; flex-direction: row; align-items: center; gap: 8px; flex-wrap: wrap; }
    #master-controls-casilla #masterTimelineContainer { flex-grow: 1; display: flex; align-items: center; gap: 4px; min-width: 120px; }
    #master-controls-casilla #masterTimelineContainer input[type="range"] { flex-grow: 1; }
    #master-controls-casilla #masterTimelineContainer span { font-size: 0.75rem; }
    .master-recording-buttons { display: flex; gap: 4px; flex-shrink: 0; }
    .master-recording-buttons button { font-size: 0.7rem; padding: 4px 6px; min-height: 24px; }
    #master-controls-casilla #masterVolumeControl { display: flex; flex-direction: row; align-items: center; gap: 6px; margin: 0; width: 100%; }
    #master-controls-casilla #masterVolumeControl label { white-space: nowrap; font-size: 0.8rem; }
    #master-controls-casilla #masterVolumeFader { flex-grow: 1; }
    #master-controls-casilla #masterVolumeValue { min-width: 45px; text-align: right; font-size: 0.75rem; }

    #granulator-main-casilla .granulator-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
    #granulator-main-casilla .granulator-header h4 { margin: 0; text-align: left; }
    #granulator-main-casilla .granulator-header div { display: flex; gap: 4px; }
    #granulator-main-casilla .granulator-fader-container { display: flex; align-items: center; gap: 5px; margin-bottom: 5px;}
    #granulator-main-casilla .granulator-fader-container label { flex-shrink: 0; }
    #granulator-main-casilla .granulator-fader-container input[type="range"] { flex-grow: 1; }
    #granulator-main-casilla .granulator-fader-container input[type="number"].fader-value-input { width: 60px; }
    #granulator-main-casilla .granulator-filter-sidechain-controls { display: flex; gap: 4px; margin-top: 6px; margin-bottom: 4px; width: 100%; }
    #granulator-main-casilla .granulator-filter-sidechain-controls button { flex-grow: 1; font-size: 0.7rem; padding: 4px 6px; }
    #granulatorPlayToggleBtn { font-size: 1.1em; padding: 4px; min-width: 28px; min-height: 28px; }
     #granulator-main-casilla #recordedWaveform {
        width: 100%;
        height: 38px;
        background-color: var(--primary-bg-color);
        border: 1px solid #555;
        border-radius: 3px;
        margin-bottom: 6px;
        cursor: pointer;
    }

    #granulator-main-casilla .dial-controls-container { margin: 6px 0; }
    #granulator-main-casilla label { font-size: 0.8rem; }
    #granulator-main-casilla input[type="range"]:not(.fader),
    #granulator-main-casilla button:not(#granulatorPlayToggleBtn):not(#toggleGranulatorFilterBtn):not(#toggleGranulatorSidechainFilterModBtn) {
        width: 100%; font-size: 0.7rem;
    }
    #granulator-main-casilla > div:has(> #granulatorVolume) { margin-top: 6px; }

    #reverb-dials-casilla h4 { text-align: left; }
    #reverb-dials-casilla .dial-controls-container input[type="number"].dial-value-input { width: 60px; }


    #sidechain-envelope-casilla { position: relative; }
    #sidechain-envelope-casilla h4 { text-align: left; margin-bottom: 6px; }
    #sidechain-envelope-casilla .dial-controls-container input[type="number"].dial-value-input { width: 70px; }

    .dial-controls-container { display: flex; flex-direction: row; justify-content: space-around; align-items: flex-start; gap: 4px; flex-wrap: wrap; }
    .dial-container { display: flex; flex-direction: column; align-items: center; text-align: center; user-select: none; flex: 1; min-width: 55px; }
    .dial-container label { font-size: 0.7rem; margin-bottom: 4px; }
    .dial { width: 40px; height: 40px; background-color: #eee; border: 1.5px solid var(--border-color); border-radius: 50%; position: relative; cursor: grab; box-shadow: inset 0 0 4px rgba(0,0,0,0.3); }
    .dial:active { cursor: grabbing; }
    .dial-indicator { width: 3px; height: 16px; background-color: var(--button-bg-color); position: absolute; top: 4px; left: 50%; transform: translateX(-50%) rotate(0deg); transform-origin: 50% calc(100% - 1.5px); border-radius: 1.5px; }
    
    #loopSection {
        display: flex; flex-direction: row; flex-wrap: wrap; gap: 12px;
        margin: 8px auto; padding: 12px;
        background-color: var(--primary-bg-color); color: var(--text-color);
        border-radius: 6px; width: 95%; max-width: 1800px;
        justify-content: center; border: 1px solid #555;
    }
    .loop-visualizer-group {
        padding: 8px; border-radius: 4px; background-color: var(--casilla-bg-color);
        border: 1px solid #555; display: flex; flex-direction: column; gap: 6px;
        flex-grow: 1;
        flex-basis: 280px;
        min-width: 240px;
        position: relative;
    }
    .loop-visualizer-group label { color: var(--text-color); font-size: 0.8rem; }

    .loop-canvas-container { position: relative; width: 100%; }
    .loop-visualizer-group canvas { width: 100%; height: 80px; background-color: rgb(105, 105, 105); border: 1px solid #555; cursor: crosshair; }
    .loop-zoom-controls { position: absolute; bottom: 5px; left: 50%; transform: translateX(-50%); display: flex; gap: 8px; z-index: 6; }
    .loop-zoom-controls button { width: 20px; height: 20px; padding: 0; border: none; border-radius: 30%; background-color: rgba(50, 50, 50, 0); color: var(--text-color); cursor: pointer; display: flex; align-items: center; justify-content: center; position: relative; font-size: 0; }
    .loop-zoom-controls button:hover { background-color: rgba(70, 70, 70, 0.85); }
    .loop-zoom-controls button::before, .loop-zoom-controls button::after { content: ''; position: absolute; background-color: currentColor; }
    .loop-zoom-controls .zoom-out-btn::before { width: 8px; height: 2px; top: 50%; left: 50%; transform: translate(-50%, -50%); }
    .loop-zoom-controls .zoom-out-btn::after { display: none; }
    .loop-zoom-controls .zoom-in-btn::before { width: 8px; height: 2px; top: 50%; left: 50%; transform: translate(-50%, -50%); }
    .loop-zoom-controls .zoom-in-btn::after { width: 2px; height: 8px; top: 50%; left: 50%; transform: translate(-50%, -50%); }
    
    .loop-sidechain-switch-container {
        position: absolute;
        top: 4px;
        right: 4px;
        z-index: 5;
    }

    .visualizer-volume-container { display: flex; flex-direction: row; align-items: center; gap: 6px; }
    .fader-containerloop { display: flex; align-items: center; width: 25px; justify-content: center; position:relative; }
    .fader-containerloop input[type="range"] { writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 8px; height: 70px; padding: 0 4px; }

    .loop-controls { display: flex; flex-direction: column; gap: 6px; align-items: stretch; margin-top: 6px; }
    .loop-controls > div:first-child {
        display: flex;
        align-items: center;
        gap: 4px;
        justify-content: flex-start;
    }
    .loop-controls > div { display: flex; align-items: center; gap: 4px; justify-content: space-between; }
    .loop-controls label { flex-shrink: 0; margin-right: 4px; }
    .loop-controls input[type="range"], .loop-controls input[type="checkbox"] { flex-grow: 1; }
    .loop-controls button { width: 100%; margin-top: 4px; font-size: 0.8rem; padding: 4px 6px; }
    .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0; }

    #patch-bay-casilla, #routing-patch-bay-casilla {
      display: none;
    }
    #patch-bay-casilla.visible, #routing-patch-bay-casilla.visible {
        display: flex;
        flex-direction: column;
        position: absolute;
        z-index: 150;
        border: 2px solid var(--highlight-color);
        box-shadow: 0 5px 15px rgba(0,0,0,0.5);
    }
    #patch-bay-casilla.visible {
        top: 35px;
        right: 5px;
        width: clamp(380px, 22vw, 420px);
        height: auto;
    }
    #routing-patch-bay-casilla.visible {
        top: 35px;
        right: clamp(400px, 25vw, 450px);
        width: clamp(280px, 18vw, 320px);
        max-height: 300px;
    }
    .drag-handle {
        cursor: move;
        user-select: none;
        padding: 4px;
        padding-left: 30px;
    }
    .patch-bay-content {
        overflow-y: auto;
        flex-grow: 1;
        min-height: 0;
        padding: 4px;
    }
    #patch-bay-casilla .patch-bay-content {
      overflow-y: hidden;
    }
    .close-btn {
        position: absolute;
        top: 6px;
        left: 6px;
        width: 20px;
        height: 20px;
        background-color: transparent;
        border: none;
        color: white;
        font-size: 1.4rem;
        line-height: 1;
        padding: 0;
        cursor: pointer;
        z-index: 10;
        opacity: 0.7;
    }
    .close-btn:hover {
        opacity: 1;
    }

    #patch-bay-casilla h4, #routing-patch-bay-casilla h4 {
      text-align: left;
      margin-bottom: 6px;
    }
    #patchBayGrid, #routingPatchBayGrid {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.7rem;
    }
    #patchBayGrid th, #patchBayGrid td,
    #routingPatchBayGrid th, #routingPatchBayGrid td {
      border: 1px solid #555;
      padding: 3px;
      text-align: center;
      vertical-align: middle;
      white-space: nowrap;
    }
    #patchBayGrid th:first-child, #patchBayGrid td:first-child,
    #routingPatchBayGrid th:first-child, #routingPatchBayGrid td:first-child {
      text-align: left;
      min-width: 70px;
      font-weight: bold;
    }
    #patchBayGrid th, #routingPatchBayGrid th {
        font-size: 0.65rem;
    }
    #patchBayGrid input[type="checkbox"], #routingPatchBayGrid input[type="checkbox"] {
      vertical-align: middle;
      cursor: pointer;
      margin: 0;
    }
    
    body.midi-mapping-active .mappable, body.midi-mapping-active .eq-band-mappable {
      outline: 2px solid var(--highlight-color);
      outline-offset: 2px;
      cursor: copy !important;
      transition: outline 0.2s ease-in-out;
    }
    body.midi-mapping-active .control-listening {
      outline: 3px solid yellow;
      box-shadow: 0 0 10px yellow;
    }
    
    .hidden { display: none !important; }

    .loader-overlay {
        position: absolute;
        top: 0; right: 0; bottom: 0; left: 0;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
        flex-direction: column;
    }
    .loader {
        border: 5px solid #f3f3f3;
        border-top: 5px solid #3498db;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        animation: spin 1s linear infinite;
    }
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    .loader-overlay p {
        margin-top: 1rem;
        color: #FFFFFF;
    }

    /* --- Animation for Armed Automation Button --- */
    @keyframes blink-red {
        50% { background-color: #c04040; box-shadow: 0 0 8px #c04040; }
    }
    button.automation-armed {
        animation: blink-red 1s infinite;
    }
    button.automation-has-data {
        background-color: green;
    }
    button.automation-playing {
        background-color: lightblue;
        color: black;
    }

  </style>
</head>
<body>

  <main class="main-container">
    <div class="top-controls-grid">
      <div class="column-left">
        <div class="casilla" id="source-controls-casilla">
          <h3 class="sr-only">Fuente de Audio</h3>
          <div id="sourceSelectContainer">
            <button type="button" id="sourceToggleButton" aria-label="Cambiar fuente de audio"></button>
            <select id="sourceSelect" style="display:none;">
              <option value="file" selected>Fuente: Archivo</option>
              <option value="mic">Fuente: Micrófono</option>
            </select>
          </div>
          <div id="filePanel" class="control-panel">
            <div class="panel-controls-grid">
              <div class="file-panel-top-row">
                <button id="dropZoneTrigger" type="button" aria-label="Agregar archivo de audio">Agregar Audio</button>
                <div class="file-panel-top-row-buttons">
                  <button id="playPauseBtn" aria-label="Reproducir o pausar audio" class="mappable">▶</button>
                  <button id="exportToBuffersBtn" aria-label="Exportar a Buffers" disabled>→ Buffers</button>
                </div>
              </div>
              <div class="file-panel-volume-row">
                <label for="volumeFader">Vol</label>
                <input type="range" id="volumeFader" min="0" max="1" step="0.01" value="0.9" aria-label="Volumen del reproductor" class="mappable">
                <input type="number" id="volumeFaderValueInput" class="fader-value-input" min="0" max="1" step="0.01" value="0.9" aria-label="Volumen del reproductor (valor)">
                <div class="switch-control-row">
                    <label for="sourceSidechainSendSwitch_file" style="font-size: 0.8rem;">Envío Sidechain</label>
                    <label class="toggle-switch-container">
                        <input type="checkbox" id="sourceSidechainSendSwitch_file" class="toggle-switch-input source-sidechain-switch">
                        <span class="toggle-switch-slider"></span>
                    </label>
                </div>
              </div>
              <div class="file-panel-bottom-row">
                <input type="range" id="timeline" value="0" min="0" max="100" step="0.1" aria-label="Progreso del audio">
                <input type="number" id="timelineValueInput" class="fader-value-input" value="0" min="0" max="100" step="0.1" aria-label="Progreso del audio (valor)">
                <span id="currentTimeDisplay" aria-live="polite">0:00</span>
              </div>
            </div>
            <input type="file" id="audioFileInput" accept="audio/*" style="display:none;">
            <div id="dropZoneActual" style="display:none;">Arrastre aquí</div>
          </div>
          <div id="micPanel" class="control-panel" style="display:none;">
            <div class="panel-controls-grid">
              <div class="mic-panel-top-row">
                <select id="micSelect" aria-label="Seleccionar dispositivo de micrófono"></select>
                <select id="channelSelect" aria-label="Seleccionar canal de micrófono">
                  <option value="0">Canal 1</option>
                  <option value="1">Canal 2</option>
                </select>
              </div>
              <div class="mic-panel-bottom-row">
                <button id="micMuteBtn" type="button" aria-pressed="false" class="mappable">Mute</button>
                <div class="switch-control-row" style="width: auto;">
                    <label class="toggle-switch-container">
                        <input type="checkbox" id="sourceSidechainSendSwitch_mic" class="toggle-switch-input source-sidechain-switch">
                        <span class="toggle-switch-slider"></span>
                    </label>
                </div>
                <input type="range" id="micVolumeFader" min="0" max="1" step="0.01" value="1" aria-label="Volumen del micrófono" class="mappable">
                <input type="number" id="micVolumeFaderValueInput" class="fader-value-input" min="0" max="1" step="0.01" value="1" aria-label="Volumen del micrófono (valor)">
              </div>
            </div>
          </div>
        </div>
        <div class="casilla" id="granulator-main-casilla">
            <div class="granulator-header">
              <h4 id="granulator-heading">Granulador (Puntos de Grano)</h4>
              <div>
                <button id="granulatorPlayToggleBtn" aria-label="Iniciar o detener granulador" class="mappable">▶</button>
              </div>
            </div>
            <canvas id="recordedWaveform" width="250" height="40"></canvas>
            <div class="granulator-filter-sidechain-controls">
              <button id="toggleGranulatorFilterBtn" type="button" class="mappable">Filtro: Highpass</button>
            </div>
            <div class="dial-controls-container">
              <div class="dial-container" id="overlapDialContainer">
                <label for="overlapDial" id="overlapDialLabel">Overlap</label>
                <div class="dial mappable" id="overlapDial" data-min="0" data-max="1" data-step="0.01" data-value="0.8" data-decimals="2">
                  <div class="dial-indicator"></div>
                </div>
                <input type="number" class="dial-value-input" id="overlapDialValue" value="0.80" min="0" max="1" step="0.01" data-decimals="2" aria-labelledby="overlapDialLabel">
              </div>
              <div class="dial-container" id="grainLengthDialContainer">
                <label for="grainLengthDial" id="grainLengthDialLabel">G.Length</label>
                <div class="dial mappable" id="grainLengthDial" data-min="0.01" data-max="1" data-step="0.01" data-value="0.6" data-decimals="2">
                  <div class="dial-indicator"></div>
                </div>
                <input type="number" class="dial-value-input" id="grainLengthDialValue" value="0.60" min="0.01" max="1" step="0.01" data-decimals="2" aria-labelledby="grainLengthDialLabel">
              </div>
              <div class="dial-container" id="granulatorFilterFreqContainer">
                <label for="granulatorFilterFreq" id="granulatorFilterFreqLabel">Cutoff</label>
                <div class="dial mappable" id="granulatorFilterFreq" data-min="20" data-max="20000" data-step="1" data-value="10000" data-decimals="0">
                  <div class="dial-indicator"></div>
                </div>
                <input type="number" class="dial-value-input" id="granulatorFilterFreqValue" value="10000" min="20" max="20000" step="1" data-decimals="0" aria-labelledby="granulatorFilterFreqLabel">
              </div>
              <div class="dial-container" id="pitchBendDialContainer">
                <label for="pitchBendDial" id="pitchBendDialLabel">Pitch Bend</label>
                <div class="dial mappable" id="pitchBendDial" data-min="-12" data-max="12" data-step="0.1" data-value="0" data-decimals="1" data-unit="st">
                  <div class="dial-indicator"></div>
                </div>
                <input type="number" class="dial-value-input" id="pitchBendDialValue" value="0.0" min="-12" max="12" step="0.1" data-decimals="1" data-unit="st" aria-labelledby="pitchBendDialLabel">
              </div>
            </div>
            <div class="granulator-fader-container">
              <label for="granulatorVolume" id="granulatorVolumeLabel">Vol. Granulador:</label>
              <input type="range" id="granulatorVolume" class="fader mappable" min="0" max="1" step="0.01" value="0.2">
              <input type="number" id="granulatorVolumeValueInput" class="fader-value-input" min="0" max="1" step="0.01" value="0.20" aria-labelledby="granulatorVolumeLabel">
              <span id="granulatorVolumeValue" class="sr-only">0.2</span>
            </div>
        </div>
        <div class="casilla" id="spectral-synth-casilla">
            <div class="switch-control-row">
                <h4>Sintetizador Espectral</h4>
                <label class="toggle-switch-container">
                    <input type="checkbox" id="spectralSynthPowerSwitch" class="toggle-switch-input">
                    <span class="toggle-switch-slider"></span>
                </label>
            </div>
            <div class="granulator-fader-container">
                <label for="spectralSynthVolume" id="spectralSynthVolumeLabel">Volumen:</label>
                <input type="range" id="spectralSynthVolume" class="fader mappable" min="0" max="1" step="0.01" value="0.9">
                <input type="number" id="spectralSynthVolumeValueInput" class="fader-value-input" min="0" max="1" step="0.01" value="0.90" aria-labelledby="spectralSynthVolumeLabel">
            </div>
            <div class="switch-control-row" style="padding-top: 5px;">
              <label for="spectralSynthDrawModeSwitch">Modo Dibujo</label>
              <label class="toggle-switch-container">
                  <input type="checkbox" id="spectralSynthDrawModeSwitch" class="toggle-switch-input" checked>
                  <span class="toggle-switch-slider"></span>
              </label>
            </div>
        </div>
      </div>
      <div class="column-middle">
        <div class="casilla" id="reverb-eq-visualizer-casilla">
            <div class="reverb-eq-header">
                <label class="canvas-label" for="spectrumCanvas">Visualizador Principal (EQ / Espectral):</label>
                <div class="header-buttons">
                    <div class="switch-control-row" style="width: auto; padding: 0; gap: 6px;">
                        <label for="animationPowerSwitch" style="font-size: 0.8rem;">Animación</label>
                        <label class="toggle-switch-container small-switch">
                            <input type="checkbox" id="animationPowerSwitch" class="toggle-switch-input" checked>
                            <span class="toggle-switch-slider"></span>
                        </label>
                    </div>
                    <button id="toggleFullscreenBtn" aria-label="Activar Modo fácil">Modo fácil</button>
                    <button id="clearDrawingBtn" aria-label="Limpiar Dibujo Espectral">Limpiar Dibujo</button>
                    <button id="undoDrawingBtn" aria-label="Deshacer último trazo">Retroceder</button>
                    <button id="midiMapBtn" aria-label="Activar mapeo MIDI">MIDI</button>
                    <button id="togglePatchBayBtn" aria-label="Toggle Patch Bay">PatchBay</button>
                </div>
            </div>
            <canvas id="spectrumCanvas" width="600" height="300"></canvas>
            <div id="loader-overlay" class="loader-overlay hidden">
                <div class="loader"></div>
                <p>Procesando...</p>
            </div>
            <div class="actions-container">
                <div class="rec-action-buttons">
                    <button id="recordBtn" class="mappable">Record</button>
                    <button id="stopRecBtn" class="mappable" disabled>Stop</button>
                    <button id="appendRecBtn" class="mappable">Append</button>
                    <button id="overdubNowBtn" class="mappable">Overdub</button>
                    <button id="clearRecBtn" class="mappable">Clear</button>
                </div>
                <div class="save-action-buttons">
                    <button id="stateBtn1" aria-label="Guardar o cargar estado 1" class="mappable">Save 1</button>
                    <button id="stateBtn2" aria-label="Guardar o cargar estado 2" class="mappable">Save 2</button>
                    <button id="stateBtn3" aria-label="Guardar o cargar estado 3" class="mappable">Save 3</button>
                    <button id="stateBtn4" aria-label="Guardar o cargar estado 4" class="mappable">Save 4</button>
                    <button id="memBtn1" aria-label="Grabar o reproducir memoria de automatización 1" class="mappable">Mem 1</button>
                    <button id="memBtn2" aria-label="Grabar o reproducir memoria de automatización 2" class="mappable">Mem 2</button>
                    <button id="memBtn3" aria-label="Grabar o reproducir memoria de automatización 3" class="mappable">Mem 3</button>
                    <button id="memBtn4" aria-label="Grabar o reproducir memoria de automatización 4" class="mappable">Mem 4</button>
                </div>
            </div>
        </div>
        <div class="casilla" id="master-controls-casilla">
          <h3 class="sr-only">Controles Master</h3>
          <div class="master-timeline-and-buttons-container">
            <div id="masterTimelineContainer" class="timeline-container">
              <label for="masterTimeline" class="sr-only" id="masterTimelineLabel">Línea de tiempo del Master</label>
              <input type="range" id="masterTimeline" value="0" min="0" step="0.1">
              <input type="number" id="masterTimelineValueInput" class="fader-value-input" value="0" min="0" step="0.1" aria-labelledby="masterTimelineLabel">
              <span id="masterCurrentTime" aria-live="polite">0:00</span> / <span id="masterDuration">0:00</span>
            </div>
            <div class="master-recording-buttons">
                <button id="recordMasterBtn" class="mappable">Grabar Master</button>
                <button id="playMasterBufferBtn" class="mappable">Play Grab.</button>
                <button id="pauseMasterBufferBtn" class="mappable">Pause Grab.</button>
                <button id="downloadMasterBtn">Descargar</button>
            </div>
          </div>
          <div id="masterVolumeControl">
            <label for="masterVolumeFader" id="masterVolumeLabel">Volumen Principal (Dry):</label>
            <input type="range" id="masterVolumeFader" min="0" max="1" step="0.01" value="1" class="mappable">
            <input type="number" id="masterVolumeFaderValueInput" class="fader-value-input" min="0" max="1" step="0.01" value="1" aria-labelledby="masterVolumeLabel">
            <span id="masterVolumeValue" aria-live="polite">0.0 dB</span>
          </div>
        </div>
      </div>
      <div class="column-right">
        <div class="casilla" id="lfo-controls-casilla">
            <div>
                <h4>LFO Filtro (Post-Reverb)</h4>
                <label class="toggle-switch-container">
                    <input type="checkbox" id="lfoPowerSwitch" class="toggle-switch-input">
                    <span class="toggle-switch-slider"></span>
                </label>
            </div>
            <div class="control-row">
              <label for="granulatorLfoSpeed" id="granulatorLfoSpeedLabel">Vel. LFO (Hz):</label>
              <input type="range" id="granulatorLfoSpeed" min="0.1" max="20" step="0.01" value="1" class="mappable">
              <input type="number" id="granulatorLfoSpeedValueInput" class="fader-value-input" min="0.1" max="20" step="0.01" value="1" aria-labelledby="granulatorLfoSpeedLabel">
            </div>
            <div class="control-row">
              <label for="granulatorLfoDepth" id="granulatorLfoDepthLabel">Depth LFO (Cutoff):</label>
              <input type="range" id="granulatorLfoDepth" min="0" max="10000" step="1" value="500" class="mappable">
              <input type="number" id="granulatorLfoDepthValueInput" class="fader-value-input" min="0" max="10000" step="1" value="500" aria-labelledby="granulatorLfoDepthLabel">
            </div>
        </div>
        <div class="casilla" id="sidechain-envelope-casilla">
          <div class="switch-control-row">
            <h4>Sidechain Envelope (Post-Reverb)</h4>
            <label class="toggle-switch-container">
                <input type="checkbox" id="sidechainEnvelopePowerSwitch" class="toggle-switch-input">
                <span class="toggle-switch-slider"></span>
            </label>
          </div>
          <div class="dial-controls-container">
            <div class="dial-container" id="sidechainThresholdDialContainer">
              <label for="sidechainThresholdDial" id="sidechainThresholdDialLabel">Umbral</label>
              <div class="dial mappable" id="sidechainThresholdDial" data-min="-70" data-max="0" data-step="1" data-value="-24" data-unit="dB" data-decimals="0">
                <div class="dial-indicator"></div>
              </div>
              <input type="number" class="dial-value-input" id="sidechainThresholdDialValue" value="-24" min="-70" max="0" step="1" data-unit="dB" data-decimals="0" aria-labelledby="sidechainThresholdDialLabel">
            </div>
            <div class="dial-container" id="sidechainAttackDialContainer">
              <label for="sidechainAttackDial" id="sidechainAttackDialLabel">Ataque</label>
              <div class="dial mappable" id="sidechainAttackDial" data-min="0.001" data-max="0.5" data-step="0.001" data-value="0.01" data-unit="s" data-decimals="3">
                <div class="dial-indicator"></div>
              </div>
              <input type="number" class="dial-value-input" id="sidechainAttackDialValue" value="0.010" min="0.001" max="0.5" step="0.001" data-unit="s" data-decimals="3" aria-labelledby="sidechainAttackDialLabel">
            </div>
             <div class="dial-container" id="sidechainReleaseDialContainer">
              <label for="sidechainReleaseDial" id="sidechainReleaseDialLabel">Relaj.</label>
              <div class="dial mappable" id="sidechainReleaseDial" data-min="0.01" data-max="1.0" data-step="0.01" data-value="0.1" data-unit="s" data-decimals="2">
                <div class="dial-indicator"></div>
              </div>
              <input type="number" class="dial-value-input" id="sidechainReleaseDialValue" value="0.10" min="0.01" max="1.0" step="0.01" data-unit="s" data-decimals="2" aria-labelledby="sidechainReleaseDialLabel">
            </div>
            <div class="dial-container" id="sidechainAmountDialContainer">
              <label for="sidechainAmountDial" id="sidechainAmountDialLabel">Cantidad</label>
              <div class="dial mappable" id="sidechainAmountDial" data-min="0" max="12000" data-step="100" data-value="1000" data-unit="Hz" data-decimals="0">
                <div class="dial-indicator"></div>
              </div>
              <input type="number" class="dial-value-input" id="sidechainAmountDialValue" value="1000" min="0" max="12000" step="100" data-unit="Hz" data-decimals="0" aria-labelledby="sidechainAmountDialLabel">
            </div>
          </div>
        </div>
        <div class="casilla" id="reverb-dials-casilla">
            <h4>Controles de Reverb (Master)</h4>
            <div class="dial-controls-container">
                <div class="dial-container" id="reverbSizeDialContainer">
                    <label for="reverbSizeDial" id="reverbSizeDialLabel">Size</label>
                    <div class="dial mappable" id="reverbSizeDial" data-min="0.1" data-max="6" data-step="0.1" data-value="5.0" data-unit="s" data-decimals="1">
                        <div class="dial-indicator"></div>
                    </div>
                    <input type="number" class="dial-value-input" id="reverbSizeDialValue" value="5.0" min="0.1" max="6" step="0.1" data-unit="s" data-decimals="1" aria-labelledby="reverbSizeDialLabel">
                </div>
                <div class="dial-container" id="reverbDryWetDialContainer">
                    <label for="reverbDryWetDial" id="reverbDryWetDialLabel">Dry/Wet</label>
                    <div class="dial mappable" id="reverbDryWetDial" data-min="0" data-max="1" data-step="0.01" data-value="0.85" data-decimals="2">
                        <div class="dial-indicator"></div>
                    </div>
                    <input type="number" class="dial-value-input" id="reverbDryWetDialValue" value="0.85" min="0" max="1" step="0.01" data-decimals="2" aria-labelledby="reverbDryWetDialLabel">
                </div>
            </div>
        </div>

        <div class="casilla" id="routing-patch-bay-casilla">
          <button class="close-btn" aria-label="Cerrar Patch Bay">&times;</button>
          <h4 class="drag-handle">Patch Bay de Ruteo de Audio</h4>
          <div class="patch-bay-content">
            <table id="routingPatchBayGrid">
              <thead>
                <tr>
                  <th>Fuente</th>
                  <th>Master</th>
                  <th>Reverb</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Reproductor</td>
                  <td><input type="checkbox" data-source="filePlayer" data-dest="dry" checked></td>
                  <td><input type="checkbox" data-source="filePlayer" data-dest="wet" checked></td>
                </tr>
                <tr>
                  <td>Micrófono</td>
                  <td><input type="checkbox" data-source="mic" data-dest="dry" checked></td>
                  <td><input type="checkbox" data-source="mic" data-dest="wet" checked></td>
                </tr>
                <tr>
                  <td>Granulador</td>
                  <td><input type="checkbox" data-source="granulator" data-dest="dry" checked></td>
                  <td><input type="checkbox" data-source="granulator" data-dest="wet" checked></td>
                </tr>
                <tr>
                  <td>Sint. Espectral</td>
                  <td><input type="checkbox" data-source="spectralSynth" data-dest="dry" checked></td>
                  <td><input type="checkbox" data-source="spectralSynth" data-dest="wet" checked></td>
                </tr>
                <tr>
                  <td>Loop 1</td>
                  <td><input type="checkbox" data-source="loop1" data-dest="dry" checked></td>
                  <td><input type="checkbox" data-source="loop1" data-dest="wet" checked></td>
                </tr>
                <tr>
                  <td>Loop 2</td>
                  <td><input type="checkbox" data-source="loop2" data-dest="dry" checked></td>
                  <td><input type="checkbox" data-source="loop2" data-dest="wet" checked></td>
                </tr>
                <tr>
                  <td>Loop 3</td>
                  <td><input type="checkbox" data-source="loop3" data-dest="dry" checked></td>
                  <td><input type="checkbox" data-source="loop3" data-dest="wet" checked></td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <div class="casilla" id="patch-bay-casilla">
          <button class="close-btn" aria-label="Cerrar Patch Bay">&times;</button>
          <h4 class="drag-handle">Modulación Directa (Patch Bay)</h4>
          <div class="patch-bay-content">
            <p style="font-size: 0.75rem; margin-bottom: 8px; color: #ccc;">Marca las casillas para asignar el control del ratón (sobre esta ventana) a los parámetros. El movimiento se escala al rango del parámetro.</p>
            <table id="patchBayGrid">
              <thead>
                <tr>
                  <th>Control</th>
                  <th>Vel. LFO</th>
                  <th>Grain Pos</th>
                  <th>Cutoff</th>
                  <th>PitchBend</th>
                  <th>Size</th>
                  <th>Dry/Wet</th>
                </tr>
              </thead>
              <tbody>
                <tr data-mouse-axis="mouseY">
                  <td>Ratón Y (Vertical)</td>
                  <td><input type="checkbox" data-param-id="granulatorLfoSpeed" aria-label="Mapear Ratón Y a Velocidad LFO"></td>
                  <td><input type="checkbox" data-param-id="grainPosFader" aria-label="Mapear Ratón Y a Posición de Grano Principal"></td>
                  <td><input type="checkbox" data-param-id="granulatorFilterFreq" aria-label="Mapear Ratón Y a Cutoff de Filtro"></td>
                  <td><input type="checkbox" data-param-id="pitchBendDial" aria-label="Mapear Ratón Y a Pitch Bend"></td>
                  <td><input type="checkbox" data-param-id="reverbSizeDial" aria-label="Mapear Ratón Y a Tamaño de Reverb"></td>
                  <td><input type="checkbox" data-param-id="reverbDryWetDial" aria-label="Mapear Ratón Y a Dry/Wet de Reverb"></td>
                </tr>
                <tr data-mouse-axis="mouseX">
                  <td>Ratón X (Horizontal)</td>
                  <td><input type="checkbox" data-param-id="granulatorLfoSpeed" aria-label="Mapear Ratón X a Velocidad LFO"></td>
                  <td><input type="checkbox" data-param-id="grainPosFader" aria-label="Mapear Ratón X a Posición de Grano Principal"></td>
                  <td><input type="checkbox" data-param-id="granulatorFilterFreq" aria-label="Mapear Ratón X a Cutoff de Filtro"></td>
                  <td><input type="checkbox" data-param-id="pitchBendDial" aria-label="Mapear Ratón X a Pitch Bend"></td>
                  <td><input type="checkbox" data-param-id="reverbSizeDial" aria-label="Mapear Ratón X a Tamaño de Reverb"></td>
                  <td><input type="checkbox" data-param-id="reverbDryWetDial" aria-label="Mapear Ratón X a Dry/Wet de Reverb"></td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
    <section id="loopSection" aria-labelledby="loop-section-heading">
      <h2 id="loop-section-heading" class="sr-only">Sección de Loops</h2>
      <div class="loop-visualizer-group">
        <div class="visualizer-volume-container">
          <div class="loop-canvas-container">
            <div class="loop-sidechain-switch-container">
              <label class="toggle-switch-container small-switch" title="Envío a Sidechain Loop 1">
                <input type="checkbox" id="loop1SidechainSendSwitch" class="toggle-switch-input" data-loopindex="0">
                <span class="toggle-switch-slider"></span>
              </label>
            </div>
            <canvas id="loopCanvas1" width="300" height="100" class="mappable"></canvas>
            <div class="loop-zoom-controls">
                <button class="zoom-out-btn" data-loopindex="0" aria-label="Zoom out loop 1"></button>
                <button class="zoom-in-btn" data-loopindex="0" aria-label="Zoom in loop 1"></button>
            </div>
          </div>
          <div class="fader-containerloop">
            <label for="loopVolume1" class="sr-only" id="loopVolume1Label">Volumen Loop 1</label>
            <input type="range" id="loopVolume1" min="0" max="1" step="0.01" value="1" orient="vertical" class="mappable">
            <input type="number" id="loopVolume1ValueInput" class="fader-value-input" min="0" max="1" step="0.01" value="1" aria-labelledby="loopVolume1Label">
          </div>
        </div>
        <div class="loop-controls">
          <div>
            <label for="speedControl1" id="speedControl1Label">Velocidad:</label>
            <input type="range" id="speedControl1" min="0.1" max="4" step="0.01" value="1" data-decimals="2" class="mappable">
            <input type="number" id="speedValue1" min="0.1" max="4" step="0.01" value="1" data-decimals="2" aria-labelledby="speedControl1Label">
          </div>
          <div style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; gap: 8px;">
              <div class="switch-control-row" style="width: auto; padding: 0;">
                  <label for="flexPitchSwitch1" style="font-size: 0.8rem; margin-right: 5px;">Flex Pitch</label>
                  <label class="toggle-switch-container small-switch">
                      <input type="checkbox" id="flexPitchSwitch1" class="toggle-switch-input">
                      <span class="toggle-switch-slider"></span>
                  </label>
              </div>
              <div class="switch-control-row" style="width: auto; padding: 0;">
                  <label for="reverseSwitch1" style="font-size: 0.8rem; margin-right: 5px;">Reversa</label>
                  <label class="toggle-switch-container small-switch">
                      <input type="checkbox" id="reverseSwitch1" class="toggle-switch-input">
                      <span class="toggle-switch-slider"></span>
                  </label>
              </div>
          </div>
          <div><button id="loopPlayPauseBtn1" type="button" class="mappable">Play</button></div>
        </div>
      </div>
      <div class="loop-visualizer-group">
        <div class="visualizer-volume-container">
          <div class="loop-canvas-container">
            <div class="loop-sidechain-switch-container">
              <label class="toggle-switch-container small-switch" title="Envío a Sidechain Loop 2">
                <input type="checkbox" id="loop2SidechainSendSwitch" class="toggle-switch-input" data-loopindex="1">
                <span class="toggle-switch-slider"></span>
              </label>
            </div>
            <canvas id="loopCanvas2" width="300" height="100" class="mappable"></canvas>
            <div class="loop-zoom-controls">
                <button class="zoom-out-btn" data-loopindex="1" aria-label="Zoom out loop 2"></button>
                <button class="zoom-in-btn" data-loopindex="1" aria-label="Zoom in loop 2"></button>
            </div>
          </div>
          <div class="fader-containerloop">
            <label for="loopVolume2" class="sr-only" id="loopVolume2Label">Volumen Loop 2</label>
            <input type="range" id="loopVolume2" min="0" max="1" step="0.01" value="1" orient="vertical" class="mappable">
            <input type="number" id="loopVolume2ValueInput" class="fader-value-input" min="0" max="1" step="0.01" value="1" aria-labelledby="loopVolume2Label">
          </div>
        </div>
        <div class="loop-controls">
          <div>
            <label for="speedControl2" id="speedControl2Label">Velocidad:</label>
            <input type="range" id="speedControl2" min="0.1" max="4" step="0.01" value="1" data-decimals="2" class="mappable">
            <input type="number" id="speedValue2" min="0.1" max="4" step="0.01" value="1" data-decimals="2" aria-labelledby="speedControl2Label">
          </div>
          <div style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; gap: 8px;">
              <div class="switch-control-row" style="width: auto; padding: 0;">
                  <label for="flexPitchSwitch2" style="font-size: 0.8rem; margin-right: 5px;">Flex Pitch</label>
                  <label class="toggle-switch-container small-switch">
                      <input type="checkbox" id="flexPitchSwitch2" class="toggle-switch-input">
                      <span class="toggle-switch-slider"></span>
                  </label>
              </div>
              <div class="switch-control-row" style="width: auto; padding: 0;">
                  <label for="reverseSwitch2" style="font-size: 0.8rem; margin-right: 5px;">Reversa</label>
                  <label class="toggle-switch-container small-switch">
                      <input type="checkbox" id="reverseSwitch2" class="toggle-switch-input">
                      <span class="toggle-switch-slider"></span>
                  </label>
              </div>
          </div>
          <div><button id="loopPlayPauseBtn2" type="button" class="mappable">Play</button></div>
        </div>
      </div>
      <div class="loop-visualizer-group">
        <div class="visualizer-volume-container">
          <div class="loop-canvas-container">
             <div class="loop-sidechain-switch-container">
              <label class="toggle-switch-container small-switch" title="Envío a Sidechain Loop 3">
                <input type="checkbox" id="loop3SidechainSendSwitch" class="toggle-switch-input" data-loopindex="2">
                <span class="toggle-switch-slider"></span>
              </label>
            </div>
            <canvas id="loopCanvas3" width="300" height="100" class="mappable"></canvas>
            <div class="loop-zoom-controls">
                <button class="zoom-out-btn" data-loopindex="2" aria-label="Zoom out loop 2"></button>
                <button class="zoom-in-btn" data-loopindex="2" aria-label="Zoom in loop 2"></button>
            </div>
          </div>
          <div class="fader-containerloop">
            <label for="loopVolume3" class="sr-only" id="loopVolume3Label">Volumen Loop 3</label>
            <input type="range" id="loopVolume3" min="0" max="1" step="0.01" value="1" orient="vertical" class="mappable">
            <input type="number" id="loopVolume3ValueInput" class="fader-value-input" min="0" max="1" step="0.01" value="1" aria-labelledby="loopVolume3Label">
          </div>
        </div>
        <div class="loop-controls">
          <div>
            <label for="speedControl3" id="speedControl3Label">Velocidad:</label>
            <input type="range" id="speedControl3" min="0.1" max="4" step="0.01" value="1" data-decimals="2" class="mappable">
            <input type="number" id="speedValue3" min="0.1" max="4" step="0.01" value="1" data-decimals="2" aria-labelledby="speedControl3Label">
          </div>
          <div style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; gap: 8px;">
              <div class="switch-control-row" style="width: auto; padding: 0;">
                  <label for="flexPitchSwitch3" style="font-size: 0.8rem; margin-right: 5px;">Flex Pitch</label>
                  <label class="toggle-switch-container small-switch">
                      <input type="checkbox" id="flexPitchSwitch3" class="toggle-switch-input">
                      <span class="toggle-switch-slider"></span>
                  </label>
              </div>
              <div class="switch-control-row" style="width: auto; padding: 0;">
                  <label for="reverseSwitch3" style="font-size: 0.8rem; margin-right: 5px;">Reversa</label>
                  <label class="toggle-switch-container small-switch">
                      <input type="checkbox" id="reverseSwitch3" class="toggle-switch-input">
                      <span class="toggle-switch-slider"></span>
                  </label>
              </div>
          </div>
          <div><button id="loopPlayPauseBtn3" type="button" class="mappable">Play</button></div>
        </div>
      </div>
    </section>
  </main>
  <script>
function degToRad(deg) { return deg * (Math.PI / 180); }
function radToDeg(rad) { return rad * (180 / Math.PI); }

function initDial(dialElement) {
    const dial = dialElement;
    const indicator = dial.querySelector('.dial-indicator');
    const displayInput = dial.parentElement.querySelector('input[type="number"].dial-value-input');
    if (!indicator) { console.error("Dial indicator not found for:", dial.id); return; }

    const min = parseFloat(dial.getAttribute('data-min'));
    const max = parseFloat(dial.getAttribute('data-max'));
    const step = parseFloat(dial.getAttribute('data-step'));
    let currentValue = parseFloat(dial.getAttribute('data-value'));
    const angleMin = -135, angleMax = 135;
    
    if (isNaN(min) || isNaN(max) || isNaN(step)) {
        console.error("Atributo data-* inválido en el dial:", dial.id);
        return;
    }

    const dataDecimalsAttr = dial.getAttribute('data-decimals');
    const finalDecimals = dataDecimalsAttr ?
                          parseInt(dataDecimalsAttr) :
                          (step.toString().includes('.') ? step.toString().split('.')[1].length : 0);

    function updateDialVisuals(valToUpdate, dispatchChangeEvent = true) {
        const percent = (max - min === 0) ? 0 : (valToUpdate - min) / (max - min);
        const angle = angleMin + percent * (angleMax - angleMin);
        indicator.style.transform = `translateX(-50%) rotate(${angle}deg)`;

        if (displayInput) {
            let numericValue = parseFloat(valToUpdate.toFixed(finalDecimals));
            displayInput.value = numericValue;
        }
        dial.setAttribute('data-value', valToUpdate);
        dial.setAttribute('aria-valuenow', valToUpdate);

        if (dispatchChangeEvent) {
            const event = new CustomEvent('dialChange', { bubbles: true, detail: { value: valToUpdate } });
            dial.dispatchEvent(event);
            
            if(window.recordAutomationEvent) {
                window.recordAutomationEvent(dial.id, valToUpdate);
            }
        }
    }
    updateDialVisuals(currentValue, false);

    if (displayInput) {
        displayInput.min = min;
        displayInput.max = max;
        displayInput.step = step;

        displayInput.addEventListener('input', (e) => {
            let rawValue = e.target.value;
            if (rawValue === "" || rawValue === "-" || rawValue.endsWith(".")) {
                return;
            }
            let newValue = parseFloat(rawValue);
            if (isNaN(newValue)) return;

            const tempVal = Math.min(max, Math.max(min, newValue));
            const percent = (max - min === 0) ? 0 : (tempVal - min) / (max - min);
            const angle = angleMin + percent * (angleMax - angleMin);
            indicator.style.transform = `translateX(-50%) rotate(${angle}deg)`;
            dial.setAttribute('data-value', tempVal);
        });

        displayInput.addEventListener('change', (e) => {
            let finalValue = parseFloat(e.target.value);
            if (isNaN(finalValue)) {
                finalValue = currentValue;
            } else {
                finalValue = Math.min(max, Math.max(min, finalValue));
                finalValue = Math.round(finalValue / step) * step;
            }
            currentValue = finalValue;
            updateDialVisuals(currentValue, true);
        });
    }

    let isDragging = false;
    function onMove(event) {
        let clientX, clientY;
        if (event.touches) { clientX = event.touches[0].clientX; clientY = event.touches[0].clientY; }
        else { clientX = event.clientX; clientY = event.clientY; }
        const rect = dial.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2, centerY = rect.top + rect.height / 2;
        const dx = clientX - centerX, dy = clientY - centerY;
        let angleRad = Math.atan2(dy, dx);
        let angleDeg = radToDeg(angleRad) + 90;
        if (angleDeg < -180) angleDeg += 360; if (angleDeg > 180) angleDeg -= 360;
        angleDeg = Math.max(angleMin, Math.min(angleMax, angleDeg));
        const percent = (angleMax - angleMin === 0) ? 0 : (angleDeg - angleMin) / (angleMax - angleMin);
        
        let newValue = min + percent * (max - min);
        newValue = Math.round(newValue / step) * step;

        currentValue = Math.min(max, Math.max(min, newValue));
        updateDialVisuals(currentValue, true);
    }
    dial.addEventListener('mousedown', (e) => { if (e.button !== 0) return; isDragging = true; document.body.style.cursor = 'grabbing'; dial.style.cursor = 'grabbing'; onMove(e); e.preventDefault(); });
    dial.addEventListener('touchstart', (e) => { isDragging = true; onMove(e); e.preventDefault(); }, { passive: false });
    window.addEventListener('mousemove', (e) => { if (isDragging) onMove(e); });
    window.addEventListener('touchmove', (e) => { if (isDragging) onMove(e); }, { passive: false });
    const stopDragging = () => { if (isDragging) { isDragging = false; document.body.style.cursor = 'default'; dial.style.cursor = 'grab'; } };
    window.addEventListener('mouseup', stopDragging);
    window.addEventListener('touchend', stopDragging);
}

function makeDraggable(element, handle) {
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

    const dragMouseDown = (e) => {
        e = e || window.event;
        e.preventDefault();
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        document.onmousemove = elementDrag;
    };

    handle.onmousedown = dragMouseDown;

    const elementDrag = (e) => {
        e = e || window.event;
        e.preventDefault();
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        element.style.top = (element.offsetTop - pos2) + "px";
        element.style.left = (element.offsetLeft - pos1) + "px";
    };

    const closeDragElement = () => {
        document.onmouseup = null;
        document.onmousemove = null;
    };
}


document.addEventListener('DOMContentLoaded', function() {
    console.log("DOM Content Loaded. Initializing Dials, Faders and UI...");

    const controlDefaults = {};
    function saveDefaults() {
        document.querySelectorAll('.dial').forEach(el => {
            controlDefaults[el.id] = { value: el.getAttribute('data-value'), type: 'dial' };
        });
        document.querySelectorAll('input[type="range"]').forEach(el => {
            controlDefaults[el.id] = { value: el.value, type: 'range' };
        });
        document.querySelectorAll('.toggle-switch-input').forEach(el => {
            controlDefaults[el.id] = { checked: el.checked, type: 'checkbox' };
        });
        console.log("Valores por defecto de controles guardados.");
    }
    saveDefaults();

    document.querySelectorAll('.dial').forEach(dialElement => { initDial(dialElement); });

    document.querySelectorAll('input[type="range"]').forEach(rangeEl => {
        const rangeId = rangeEl.id;
        let numberInputEl;
        if (document.getElementById(rangeId + 'ValueInput')) {
            numberInputEl = document.getElementById(rangeId + 'ValueInput');
        } else if (rangeId.startsWith('speedControl')) {
            numberInputEl = document.getElementById(rangeId.replace('Control', 'Value'));
        }
        
        const originalInputHandler = () => {
            if(numberInputEl) {
                const rStep = parseFloat(rangeEl.step);
                const numDecimalsAttr = numberInputEl.dataset.decimals || rangeEl.dataset.decimals;
                const numDecimals = numDecimalsAttr ?
                               parseInt(numDecimalsAttr) :
                               (rStep.toString().includes('.') ? rStep.toString().split('.')[1].length : 0);
                const valNum = parseFloat(rangeEl.value);
                numberInputEl.value = isNaN(valNum) ? '' : valNum.toFixed(numDecimals);
            }
            if(window.recordAutomationEvent) {
                window.recordAutomationEvent(rangeEl.id, parseFloat(rangeEl.value));
            }
        };

        if (numberInputEl) {
            const rMin = parseFloat(rangeEl.min);
            const rMax = parseFloat(rangeEl.max);
            const rStep = parseFloat(rangeEl.step);
            
            numberInputEl.min = rMin;
            numberInputEl.max = rMax;
            numberInputEl.step = rStep;
            originalInputHandler(); 

            rangeEl.addEventListener('input', originalInputHandler);
            
            numberInputEl.addEventListener('change', (e) => {
                let val = parseFloat(e.target.value);
                if (isNaN(val)) {
                    val = parseFloat(rangeEl.value);
                } else {
                    val = Math.min(rMax, Math.max(rMin, val));
                    val = Math.round(val / rStep) * rStep;
                }
                if (parseFloat(rangeEl.value) !== val) {
                    rangeEl.value = val;
                    rangeEl.dispatchEvent(new Event('input', { bubbles: true }));
                }
            });
        } else {
             rangeEl.addEventListener('input', originalInputHandler);
        }
    });

    document.querySelectorAll('button.mappable').forEach(btn => {
        if (!btn.id.startsWith('memBtn')) {
            btn.addEventListener('click', () => {
                if (window.recordAutomationEvent) {
                    window.recordAutomationEvent(btn.id, 'click');
                }
            });
        }
    });

    document.querySelectorAll('.toggle-switch-input').forEach(toggle => {
        toggle.addEventListener('change', () => {
            if (window.recordAutomationEvent) {
                window.recordAutomationEvent(toggle.id, toggle.checked);
            }
        });
    });

    const dropZoneTriggerEl = document.getElementById('dropZoneTrigger');
    const audioFileInputEl = document.getElementById('audioFileInput');
    if (dropZoneTriggerEl && audioFileInputEl) {
        dropZoneTriggerEl.addEventListener('click', () => { audioFileInputEl.click(); });
        dropZoneTriggerEl.addEventListener('dragover', (event) => { event.preventDefault(); event.dataTransfer.dropEffect = 'copy'; });
        dropZoneTriggerEl.addEventListener('drop', (event) => {
            event.preventDefault();
            if (event.dataTransfer.files && event.dataTransfer.files.length > 0) {
                audioFileInputEl.files = event.dataTransfer.files;
                audioFileInputEl.dispatchEvent(new Event('change', { bubbles: true }));
            }
        });
    }
    
    const masterVolFader = document.getElementById('masterVolumeFader');
    const masterVolValueDisplaySpan = document.getElementById('masterVolumeValue');
    if (masterVolFader && masterVolValueDisplaySpan) {
        const initialLinearVal = parseFloat(masterVolFader.value);
        masterVolValueDisplaySpan.textContent = `${(initialLinearVal > 0 ? 20 * Math.log10(initialLinearVal) : -Infinity).toFixed(1)} dB`;
    }

    const togglePatchBayBtn = document.getElementById('togglePatchBayBtn');
    const patchBayCasilla = document.getElementById('patch-bay-casilla');
    const routingPatchBayCasilla = document.getElementById('routing-patch-bay-casilla');
    if (togglePatchBayBtn && patchBayCasilla && routingPatchBayCasilla) {
        togglePatchBayBtn.addEventListener('click', () => {
            patchBayCasilla.classList.toggle('visible');
            routingPatchBayCasilla.classList.toggle('visible');
        });
        
        makeDraggable(patchBayCasilla, patchBayCasilla.querySelector('.drag-handle'));
        makeDraggable(routingPatchBayCasilla, routingPatchBayCasilla.querySelector('.drag-handle'));

        document.querySelectorAll('.close-btn').forEach(button => {
            button.addEventListener('click', () => {
                button.closest('.casilla').classList.remove('visible');
            });
        });
    }

    document.addEventListener('click', (e) => {
        if (!e.altKey) return;

        let target = e.target;
        if (target.classList.contains('dial-indicator')) {
            target = target.closest('.dial');
        }

        const id = target.id;
        if (id && controlDefaults[id]) {
            e.preventDefault();
            e.stopPropagation();

            const defaultConfig = controlDefaults[id];
            console.log(`Reseteando ${id} a su valor por defecto.`);

            if (defaultConfig.type === 'dial' && window.localUpdateDialParamProgrammatic) {
                window.localUpdateDialParamProgrammatic(target, parseFloat(defaultConfig.value));
            } else if (defaultConfig.type === 'range' && window.localUpdateRangeParamProgrammatic) {
                window.localUpdateRangeParamProgrammatic(target, parseFloat(defaultConfig.value));
            } else if (defaultConfig.type === 'checkbox') {
                if (target.checked !== defaultConfig.checked) {
                    target.checked = defaultConfig.checked;
                    target.dispatchEvent(new Event('change', { bubbles: true }));
                }
            }
        }
    }, true);
});

(function(){
    console.log("SUSPIRA Audio Logic Initializing...");
    
    // --- Worker Initialization ---
    let animationWorker;
    let lastParticleData = null; // Almacenará los últimos datos recibidos del worker
    let offscreenCanvas = document.createElement('canvas'); // Canvas en memoria para optimizar el dibujado
    let offscreenCtx = offscreenCanvas.getContext('2d');   // Contexto del canvas en memoria

    if (window.Worker) {
        animationWorker = new Worker('worker.js');

        // Escucha los resultados del worker
        animationWorker.onmessage = function(e) {
            lastParticleData = e.data;
        };
        
        // Envía mensaje para inicializar las partículas en el worker
        animationWorker.postMessage({ type: 'init' });
    } else {
        console.error("Tu navegador no soporta Web Workers. La animación de partículas estará desactivada.");
    }
    // --- End Worker Initialization ---

    let audioContext;
    let gainNode;
    let micGainNode, micBooster;
    let masterGain;
    let finalOutputGain;
    let granulatorVolumeGain, granulatorFilter;
    let granulatorPitchBend = 0;
    
    let dryBus, wetBus;
    let filePlayerDrySend, filePlayerWetSend;
    let micDrySend, micWetSend;
    let granulatorDrySend, granulatorWetSend;
    let spectralSynthDrySend, spectralSynthWetSend;
    let loopDrySends = [], loopWetSends = [];

    let granulatorLFO, granulatorLFOGain;
    let loopVolumeGains = [];
    
    let sourceSidechainSendGain;
    let loopSidechainSendGains = [];
    let sidechainSummingGain, sidechainAnalyserNode, sidechainModulationNode;
    let sidechainEnvelopeDataArray;
    let isSidechainEnvelopeProcessingActive = false;
    let sidechainThresholdValue = -24, sidechainAttackTime = 0.01, sidechainReleaseTime = 0.1, sidechainModulationAmount = 1000;
    let sidechainSmoothedEnvelope = 0, sidechainAnimationRequest = null;
    
    let mediaStream, currentSourceNode;
    let mainPlayerAnimationFrameId = null;
    let audioBuffer = null;
    let isMainPlayerPlaying = false;
    let mainPlayerStartOffset = 0, mainPlayerStartTime = 0, mainPlayerDuration = 0;
    let currentMicChannelIndex = 0;

    let mainRecordingStreamDestinationNode, mainAudioRecorder, mainRecordedChunks = [];
    let recordSourceMixer;

    let mainRecorderAudioBuffer = null, mainRecorderAudioBufferId = 0;
    let flexPitchCache = [{}, {}, {}];
    let currentAudioSourceType = 'file';
    let currentRecordingMode = "";
    
    let granulatorTimeoutId = null;
    let isGranulatorRunning = false;
    
    const SPECTRAL_FILTER_COUNT = 25;
    let spectralFilterBank = [];
    let spectralSynthInputGain, spectralSynthVolumeGain, spectralSynthBoostGain, spectralSynthBooster;
    let isSpectralSynthActive = false;
    let spectralSynthTimeoutId = null;
    let currentSpectralSynthSource = null;
    let lastSpectralCoords = { x: -1, y: -1, active: false };
    const SPECTRAL_MIN_FREQ = 20;
    const SPECTRAL_MAX_FREQ = 20000;
    let isDrawingPath = false;
    let drawnPaths = [[]];
    let pathPlaybackRequestID = null;
    let pathPlaybackIndex = 0;
    let isDrawModeActive = true; 

    let samplerGrainPoints = [
        { x: 0.50, y: 0.5, active: true, isMain: true },
        { x: 0.25, y: 0.5, active: false, isMain: false },
        { x: 0.40, y: 0.5, active: false, isMain: false },
        { x: 0.60, y: 0.5, active: false, isMain: false },
        { x: 0.75, y: 0.5, active: false, isMain: false }
    ];
    let selectedGrainPointIndex = -1;
    let isDraggingGrainPoint = false;

    let masterRecordedAudioBuffer = null, masterBufferSourceNode = null;
    let masterOutputRecorder, masterRecordedChunksForMaster = [];
    let isMasterRecordingPlaying = false, masterRecordingStartTime = 0, masterRecordingStartOffset = 0;
    
    let isMainPlayerLoopEnabled = false;
    let isMicMuted = false;
    let loopZoomLevels = [1, 1, 1], loopPanOffsets = [0, 0, 0], loopIsDraggingForPan = [false, false, false], loopPanLastMouseX = [0, 0, 0];
    let loopPlaybackAnimationIds = [null, null, null];
    let loopPlaybackStartTimes = [0, 0, 0], loopNextStartTimeoutId = [null, null, null];
    
    const PLAY_SYMBOL = "▶", PAUSE_SYMBOL = "⏸", STOP_SYMBOL = "■", LOOP_ACTIVE_COLOR = "green";

    let sampleSelections = [{start: 0, end: 0}, {start: 0, end: 0}, {start: 0, end: 0}];
    let isSelectingSampleFlags = [false, false, false];
    let activeSamplers = [null, null, null];

    let sparklesArray;
    let analyserWet, analyserDry;
    let frequencyDataWet, frequencyDataDry, frequencyHistory;
    let selectedBand = null, selectedBandIndex = -1;
    let isQAdjusting = false;
    const glowColor = 'rgba(255, 0, 150, 0.8)';
    const HISTORY_LENGTH = 25;
    const visualBands = [
        { f_low: 60,   f_high: 300,   name: '60-300Hz' },
        { f_low: 300,  f_high: 800,   name: '300-800Hz' },
        { f_low: 800,  f_high: 1000,  name: '800-1kHz' },
        { f_low: 1000, f_high: 2000,  name: '1-2kHz' },
        { f_low: 2000, f_high: 4000,  name: '2-4kHz' },
        { f_low: 4000, f_high: 8000,  name: '4-8kHz' },
        { f_low: 8000, f_high: 16000, name: '8-16kHz' },
    ];
    let eqBandInstances = [];
    let eqBandDefaults = [];
    
    let animationFrameId_visualizer;
    let visualizerLastRenderTime = 0;
    const VISUALIZER_FPS = 30;
    const visualizerRenderInterval = 1000 / VISUALIZER_FPS;
    let isAnimationEnabled = true;

    let convolverNode, dryGainNode_reverb, wetGainNode_reverb, inputGainNode_reverb, reverbBooster;
    let reverbSizeDialEl, reverbDryWetDialEl;
    const NUM_EQ_BANDS = 7;
    
    const spectrumCanvas = document.getElementById('spectrumCanvas');
    let spectrumCanvasCtx;
    const loaderOverlay = document.getElementById('loader-overlay');

    let isMidiMapping = false;
    let elementToMap = null;
    let midiMap = {};
    let lastCCValues = {};

    let automationMemories = [null, null, null, null];
    let automationPlaybackStates = [
        { isPlaying: false, loopId: null, startTime: 0, eventIndex: 0 },
        { isPlaying: false, loopId: null, startTime: 0, eventIndex: 0 },
        { isPlaying: false, loopId: null, startTime: 0, eventIndex: 0 },
        { isPlaying: false, loopId: null, startTime: 0, eventIndex: 0 }
    ];
    let armedAutomationSlot = -1;
    let isRecordingAutomation = false;
    let automationRecordingStartTime = 0;
    let tempAutomationSequence = [];
    let memBtnLastClickTime = [0, 0, 0, 0];
    const memButtons = [
        document.getElementById("memBtn1"), document.getElementById("memBtn2"),
        document.getElementById("memBtn3"), document.getElementById("memBtn4")
    ];

    const sourceToggleButton = document.getElementById('sourceToggleButton');
    const micSelect = document.getElementById('micSelect'), micPanel = document.getElementById('micPanel');
    const filePanel = document.getElementById('filePanel'), channelSelect = document.getElementById('channelSelect');
    const micMuteBtn = document.getElementById('micMuteBtn');
    const micVolumeFader = document.getElementById('micVolumeFader');

    const playPauseBtn = document.getElementById('playPauseBtn'), timeline = document.getElementById('timeline');
    const currentTimeDisplay = document.getElementById('currentTimeDisplay');
    const volumeFader = document.getElementById('volumeFader');

    const recordBtn = document.getElementById('recordBtn'), stopRecBtn = document.getElementById('stopRecBtn');
    const appendRecBtn = document.getElementById('appendRecBtn'), overdubNowBtn = document.getElementById('overdubNowBtn');
    const clearRecBtn = document.getElementById('clearRecBtn'), recordedWaveformCanvas = document.getElementById('recordedWaveform');
    
    const overlapDialEl = document.getElementById('overlapDial');
    const grainLengthDialEl = document.getElementById('grainLengthDial');
    const granulatorFilterFreqEl = document.getElementById('granulatorFilterFreq');
    const pitchBendDialEl = document.getElementById('pitchBendDial');
    
    const granulatorPlayToggleBtn = document.getElementById('granulatorPlayToggleBtn');
    const toggleGranulatorFilterBtn = document.getElementById('toggleGranulatorFilterBtn');
    
    const granulatorLfoSpeedFader = document.getElementById('granulatorLfoSpeed');
    const granulatorLfoDepthFader = document.getElementById('granulatorLfoDepth');
    const lfoPowerSwitch = document.getElementById('lfoPowerSwitch');
    
    const granulatorVolumeFader = document.getElementById('granulatorVolume');
    const audioFileInput = document.getElementById('audioFileInput');
    
    const spectralSynthPowerSwitch = document.getElementById('spectralSynthPowerSwitch');
    const spectralSynthVolumeFader = document.getElementById('spectralSynthVolume');
    const spectralSynthDrawModeSwitch = document.getElementById('spectralSynthDrawModeSwitch');
    const clearDrawingBtn = document.getElementById('clearDrawingBtn');
    const undoDrawingBtn = document.getElementById('undoDrawingBtn');
    const animationPowerSwitch = document.getElementById('animationPowerSwitch');

    const sidechainEnvelopePowerSwitch = document.getElementById('sidechainEnvelopePowerSwitch');
    const sidechainThresholdDialEl = document.getElementById('sidechainThresholdDial');
    const sidechainAttackDialEl = document.getElementById('sidechainAttackDial');
    const sidechainReleaseDialEl = document.getElementById('sidechainReleaseDial');
    const sidechainAmountDialEl = document.getElementById('sidechainAmountDial');

    const sourceSidechainSendSwitches = document.querySelectorAll('.source-sidechain-switch');

    const loopSidechainSendSwitches = [
        document.getElementById('loop1SidechainSendSwitch'),
        document.getElementById('loop2SidechainSendSwitch'),
        document.getElementById('loop3SidechainSendSwitch')
    ];
    
    const loopToggleBtn = document.getElementById('loopToggleBtn');
    const exportToBuffersBtn = document.getElementById('exportToBuffersBtn');
    const loopCanvases = [document.getElementById('loopCanvas1'), document.getElementById('loopCanvas2'), document.getElementById('loopCanvas3')];
    let loopSelections = [{start: 0, end: 1}, {start: 0, end: 1}, {start: 0, end: 1}];
    let loopIsSelectingFlags = [false, false, false];
    
    const loopSpeedControls = [document.getElementById('speedControl1'), document.getElementById('speedControl2'), document.getElementById('speedControl3')];
    const loopFlexPitchSwitches = [document.getElementById('flexPitchSwitch1'), document.getElementById('flexPitchSwitch2'), document.getElementById('flexPitchSwitch3')];
    const loopReverseSwitches = [document.getElementById('reverseSwitch1'), document.getElementById('reverseSwitch2'), document.getElementById('reverseSwitch3')];
    const loopPlayPauseBtns = [document.getElementById('loopPlayPauseBtn1'), document.getElementById('loopPlayPauseBtn2'), document.getElementById('loopPlayPauseBtn3')];
    const loopVolumeFaders = [document.getElementById('loopVolume1'), document.getElementById('loopVolume2'), document.getElementById('loopVolume3')];

    const loopZoomInBtns = document.querySelectorAll('.zoom-in-btn'), loopZoomOutBtns = document.querySelectorAll('.zoom-out-btn');
    
    const masterVolumeFaderEl = document.getElementById('masterVolumeFader');
    const masterVolumeValueDisplay = document.getElementById('masterVolumeValue');
    
    const recordMasterBtnEl = document.getElementById('recordMasterBtn');
    const playMasterBufferBtnEl = document.getElementById('playMasterBufferBtn');
    const pauseMasterBufferBtnEl = document.getElementById('pauseMasterBufferBtn');
    const downloadMasterBtnEl = document.getElementById('downloadMasterBtn');
    
    const masterTimelineFader = document.getElementById('masterTimeline');
    const masterCurrentTimeDisplay = document.getElementById('masterCurrentTime'), masterDurationDisplay = document.getElementById('masterDuration');
    
    const stateButtons = [document.getElementById("stateBtn1"),document.getElementById("stateBtn2"),document.getElementById("stateBtn3"),document.getElementById("stateBtn4")];
    let savedStates = [null, null, null, null], statePressTimes = [0, 0, 0, 0];

    const patchableParameterIds = ['granulatorLfoSpeed', 'grainPosFader', 'granulatorFilterFreq', 'pitchBendDial', 'reverbSizeDial', 'reverbDryWetDial'];
    let patchParametersInfo = {};
    let patchMappings = {};
    let isPatchBayActive = false;

    class EQBand {
        constructor(initialAngle, neutralRadius, centerX, centerY) {
            this.angle = initialAngle;
            this.distance = neutralRadius;
            this.x = centerX + Math.cos(this.angle) * this.distance;
            this.y = centerY + Math.sin(this.angle) * this.distance;
            this.drawRadius = 10;
            this.interactionRadius = 10;
            this.color = 'rgba(255, 255, 255, 0.08)';
            this.wetLevel = 0;
            this.dryLevel = 0;
            
            // La creación del filterNode se mueve a un método separado
            // para ser llamado DESPUÉS de que exista el audioContext.
            this.filterNode = null; 
        }

        createFilter() {
            if (audioContext && !this.filterNode) {
                this.filterNode = audioContext.createBiquadFilter();
                this.filterNode.type = 'peaking';
                this.q = 1.41;
            }
        }

        updateFilter(centerX, centerY, neutralRadius) {
            if (!this.filterNode) return;
            const dx = this.x - centerX;
            const dy = this.y - centerY;
            this.distance = Math.sqrt(dx * dx + dy * dy);
            this.angle = Math.atan2(dy, dx);
            let normalizedAngle = (this.angle + Math.PI) / (2 * Math.PI);
            const minFreq = 20, maxFreq = 20000;
            const freqRange = Math.log(maxFreq / minFreq);
            const frequency = minFreq * Math.exp(freqRange * normalizedAngle);
            this.filterNode.frequency.setTargetAtTime(frequency, audioContext.currentTime, 0.01);
            const maxGain = 18.0;
            const gain = ((this.distance - neutralRadius) / (neutralRadius * 0.8)) * maxGain;
            const clampedGain = Math.max(-maxGain, Math.min(maxGain, gain));
            this.filterNode.gain.setTargetAtTime(clampedGain, audioContext.currentTime, 0.01);
            this.filterNode.Q.setTargetAtTime(this.q, audioContext.currentTime, 0.01);
            this.drawRadius = 5 + 20 / this.q;
        }

        draw() {
            if (!spectrumCanvasCtx) return;
            spectrumCanvasCtx.beginPath();
            spectrumCanvasCtx.arc(this.x, this.y, this.drawRadius, 0, Math.PI * 2);

            if (isMidiMapping) {
                spectrumCanvasCtx.strokeStyle = 'rgba(255, 0, 255, 0.8)';
            } else {
                spectrumCanvasCtx.strokeStyle = this.color;
            }
            
            spectrumCanvasCtx.lineWidth = 2;
            spectrumCanvasCtx.stroke();
            spectrumCanvasCtx.beginPath();
            spectrumCanvasCtx.arc(this.x, this.y, 2, 0, Math.PI * 2);
            spectrumCanvasCtx.fillStyle = this.color;
            spectrumCanvasCtx.fill();
        }
    }

    class Sparkle {
        constructor(angle, brightness) {
            this.angle = angle; this.brightness = brightness;
            this.lifespan = 1.0;
            this.radius = 2 + (brightness * 8 * 0.6); 
            
            const centerX = spectrumCanvas.width / 2;
            const centerY = spectrumCanvas.height / 2;
            const cloudRadius = Math.min(spectrumCanvas.width, spectrumCanvas.height) / 3.0;
            let dist;
            do {
                this.x = Math.random() * spectrumCanvas.width;
                this.y = Math.random() * spectrumCanvas.height;
                const dx = this.x - centerX;
                const dy = this.y - centerY;
                dist = Math.sqrt(dx * dx + dy * dy);
            } while (dist < cloudRadius);
        }
        updateAndDraw() {
            if (!spectrumCanvasCtx) return;
            this.lifespan -= 0.04;
            if (this.lifespan <= 0) return;
            const currentRadius = this.radius * this.lifespan;
            const currentOpacity = this.brightness * this.lifespan;
            spectrumCanvasCtx.beginPath();
            spectrumCanvasCtx.arc(this.x, this.y, currentRadius * 0.5, 0, Math.PI * 2);
            spectrumCanvasCtx.fillStyle = `rgba(255, 255, 255, ${currentOpacity * 0.7})`;
            spectrumCanvasCtx.fill();
            const rayLength = currentRadius * 2.5;
            spectrumCanvasCtx.lineWidth = Math.max(1, currentRadius * 0.3);
            spectrumCanvasCtx.strokeStyle = `rgba(255, 200, 255, ${currentOpacity * 0.5 * 0.7})`;
            spectrumCanvasCtx.beginPath();
            spectrumCanvasCtx.moveTo(this.x - rayLength, this.y); spectrumCanvasCtx.lineTo(this.x + rayLength, this.y);
            spectrumCanvasCtx.moveTo(this.x, this.y - rayLength); spectrumCanvasCtx.lineTo(this.x, this.y + rayLength);
            spectrumCanvasCtx.stroke();
        }
    }
    
    window.localUpdateDialParamProgrammatic = function(dialElement, newValue) {
        if (!dialElement) return;
        const min = parseFloat(dialElement.getAttribute('data-min'));
        const max = parseFloat(dialElement.getAttribute('data-max'));
        const step = parseFloat(dialElement.getAttribute('data-step'));
        
        const dataDecimalsAttr = dialElement.getAttribute('data-decimals');
        const finalDecimals = dataDecimalsAttr ? parseInt(dataDecimalsAttr) : (step.toString().includes('.') ? step.toString().split('.')[1].length : 0);
        
        let clampedValue = Math.min(max, Math.max(min, newValue));
        clampedValue = Math.round(clampedValue / step) * step;

        const indicator = dialElement.querySelector('.dial-indicator');
        const displayInput = dialElement.parentElement.querySelector('input[type="number"].dial-value-input');
        const angleMin = -135, angleMax = 135;
        
        const percent = (max - min === 0) ? 0 : (clampedValue - min) / (max - min);
        const angle = angleMin + percent * (angleMax - angleMin);
        
        if (indicator) indicator.style.transform = `translateX(-50%) rotate(${angle}deg)`;
        if (displayInput) {
            let numericValue = parseFloat(clampedValue.toFixed(finalDecimals));
            displayInput.value = numericValue;
        }
        dialElement.setAttribute('data-value', clampedValue);
        dialElement.setAttribute('aria-valuenow', clampedValue);
        dialElement.dispatchEvent(new CustomEvent('dialChange', { bubbles: true, detail: { value: clampedValue } }));
    }
    
    window.localUpdateRangeParamProgrammatic = function(rangeElement, newValue) {
        if (!rangeElement) return;
        const min = parseFloat(rangeElement.min);
        const max = parseFloat(rangeElement.max);
        const step = parseFloat(rangeElement.step);
        
        const numberInputEl = document.getElementById(rangeElement.id + 'ValueInput') ||
                              (rangeElement.id.startsWith('speedControl') ? document.getElementById(rangeElement.id.replace('Control', 'Value')) : null);

        const dataDecimalsAttr = numberInputEl ? numberInputEl.dataset.decimals : rangeElement.dataset.decimals;
        const finalDecimals = dataDecimalsAttr ? parseInt(dataDecimalsAttr) : (step.toString().includes('.') ? step.toString().split('.')[1].length : 0);

        let clampedValue = Math.min(max, Math.max(min, newValue));
        clampedValue = Math.round(clampedValue / step) * step;

        rangeElement.value = clampedValue;

        if (numberInputEl) {
            numberInputEl.value = parseFloat(clampedValue).toFixed(finalDecimals);
        }
        rangeElement.dispatchEvent(new Event('input', { bubbles: true }));
    }
    
    function updateParameterProgrammatically(paramId, value) {
        if (paramId.startsWith('eq_band_')) {
            const index = parseInt(paramId.split('_')[2]);
            if (eqBandInstances[index] && typeof value === 'object') {
                const band = eqBandInstances[index];
                band.x = value.x;
                band.y = value.y;
                band.q = value.q;
                band.updateFilter(spectrumCanvas.width / 2, spectrumCanvas.height / 2, Math.min(spectrumCanvas.width, spectrumCanvas.height) / 3.5);
            }
            return;
        }
        
        const el = document.getElementById(paramId);
        if(!el) {
            console.warn(`Automation playback: Element with ID "${paramId}" not found.`);
            return;
        }

        if (value === 'click') {
            el.click();
            return;
        }

        if (typeof value === 'boolean' && (el.type === 'checkbox' || el.classList.contains('toggle-switch-input'))) {
            if(el.checked !== value) {
                el.checked = value;
                el.dispatchEvent(new Event('change', { bubbles: true }));
            }
            return;
        }
        
        if (paramId === 'grainPosFader') {
            if (samplerGrainPoints && samplerGrainPoints.length > 0) {
                const mainPoint = samplerGrainPoints.find(p => p.isMain);
                if (mainPoint) {
                    const min = 0, max = 1;
                    let clampedValue = Math.min(max, Math.max(min, value));
                    mainPoint.x = clampedValue;
                    drawMainRecordedWaveform();
                }
            }
            return;
        }

        if (el.classList.contains('dial')) {
            localUpdateDialParamProgrammatic(el, value);
        } else if (el.type === 'range') {
            localUpdateRangeParamProgrammatic(el, value);
        }
    }
   
    function triggerSpectralSynthFromSparkle(frequency, intensity, duration) {
        if (!audioContext || !mainRecorderAudioBuffer || !spectralSynthPowerSwitch.checked) return;

        if (currentSpectralSynthSource) {
            try { currentSpectralSynthSource.stop(0); } catch(e) {}
        }

        const grainLength = 0.1; 
        const bufferDuration = mainRecorderAudioBuffer.duration;
        let startPosition = Math.random() * (bufferDuration - grainLength);
        
        const source = audioContext.createBufferSource();
        source.buffer = mainRecorderAudioBuffer;

        const envelope = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        
        filter.type = 'bandpass';
        filter.frequency.value = frequency;
        filter.Q.value = 50;

        source.connect(filter);
        filter.connect(envelope);
        envelope.connect(spectralSynthBooster);

        const now = audioContext.currentTime;
        const peakTime = now + (duration * 0.2);
        const endTime = now + duration;
        
        envelope.gain.setValueAtTime(0, now);
        envelope.gain.linearRampToValueAtTime(intensity, peakTime);
        envelope.gain.linearRampToValueAtTime(0, endTime);
        
        source.start(now, startPosition, grainLength);
        currentSpectralSynthSource = source;
        source.onended = () => {
            if (currentSpectralSynthSource === source) currentSpectralSynthSource = null;
            try {
                source.disconnect();
                filter.disconnect();
                envelope.disconnect();
            } catch(e) {}
        };
    }

    function reverb_generateImpulseResponse(aCtx,durS,decR){
        const sR=aCtx.sampleRate,len=sR*durS,imp=aCtx.createBuffer(2,len,sR),iL=imp.getChannelData(0),iR=imp.getChannelData(1);
        for(let i=0;i<len;i++){const e=Math.pow(1-i/len,decR);iL[i]=(Math.random()*2-1)*e;iR[i]=(Math.random()*2-1)*e;} return imp;
    }
    function reverb_updateReverbSize() {
        if (!audioContext || !convolverNode || !reverbSizeDialEl) return;
        const size = parseFloat(reverbSizeDialEl.getAttribute('data-value'));
        const minDecay = 1.5, maxDecay = 3.0, normalizedSize = (size - 0.1) / (6 - 0.1);
        const decayRate = maxDecay - normalizedSize * (maxDecay - minDecay);
        try { convolverNode.buffer = reverb_generateImpulseResponse(audioContext, size, decayRate); }
        catch (e) { console.error("Error generating impulse response:", e); }
    }
    function reverb_updateDryWetMix() {
        if (!dryGainNode_reverb || !wetGainNode_reverb || !audioContext || !reverbDryWetDialEl) return;
        const mixValue = parseFloat(reverbDryWetDialEl.getAttribute('data-value'));
        dryGainNode_reverb.gain.setTargetAtTime(Math.cos(mixValue * 0.5 * Math.PI), audioContext.currentTime, 0.01);
        wetGainNode_reverb.gain.setTargetAtTime(Math.sin(mixValue * 0.5 * Math.PI), audioContext.currentTime, 0.01);
    }
    function reverb_setupReverbControls() {
        reverbSizeDialEl = document.getElementById('reverbSizeDial');
        reverbDryWetDialEl = document.getElementById('reverbDryWetDial');
        if(reverbSizeDialEl) reverbSizeDialEl.addEventListener('dialChange', reverb_updateReverbSize);
        if(reverbDryWetDialEl) reverbDryWetDialEl.addEventListener('dialChange', reverb_updateDryWetMix);
    }
    
    function drawInitialMessage(msg="Carga un archivo de audio para ver el espectro."){
        if(!spectrumCanvasCtx)return;
        spectrumCanvasCtx.fillStyle='rgb(30,30,30)';
        spectrumCanvasCtx.fillRect(0,0,spectrumCanvas.width,spectrumCanvas.height);
        spectrumCanvasCtx.fillStyle="white";
        spectrumCanvasCtx.textAlign="center";
        spectrumCanvasCtx.font="1rem Arial";
        spectrumCanvasCtx.fillText(msg,spectrumCanvas.width/2,spectrumCanvas.height/2);
}
function drawDrawnPaths(ctx, width, height) {
        if (drawnPaths.length === 0) return;
        const radius = height * 0.035;

        for (const path of drawnPaths) {
            if (path.length === 0) continue;
            for (const point of path) {
                const x = point.x * width;
                const y = point.y * height;
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, 'rgba(255, 0, 255, 0.9)');
                gradient.addColorStop(1, 'rgba(255, 0, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    function drawSpectralSynthVisuals() {
        if (!spectrumCanvasCtx) return;

        if (lastSpectralCoords.active && isDrawModeActive) {
            const x = lastSpectralCoords.x * spectrumCanvas.width;
            const y = lastSpectralCoords.y * spectrumCanvas.height;
            const radius = spectrumCanvas.height * 0.035;
            const gradient = spectrumCanvasCtx.createRadialGradient(x, y, 0, x, y, radius);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            spectrumCanvasCtx.fillStyle = gradient;
            spectrumCanvasCtx.beginPath();
            spectrumCanvasCtx.arc(x, y, radius, 0, Math.PI * 2);
            spectrumCanvasCtx.fill();
        }
    }

    // --- START: New Visualizer Core Functions ---
    function initParticleSystem() {
        // La inicialización de partículas ahora ocurre en el worker.
        // Solo reiniciamos los sparkles aquí.
        sparklesArray = [];
    }

    function initEQBands() {
        if (!spectrumCanvas) return;
        const centerX = spectrumCanvas.width/2, centerY = spectrumCanvas.height/2;
        const neutralRadius = Math.min(spectrumCanvas.width, spectrumCanvas.height) / 3.5;
        eqBandInstances = [];
        eqBandDefaults = [];
        for (let i = 0; i < NUM_EQ_BANDS; i++) {
            const angle = (i / NUM_EQ_BANDS) * Math.PI * 2 - Math.PI / 2;
            const newBandInstance = new EQBand(angle, neutralRadius, centerX, centerY);
            eqBandInstances.push(newBandInstance);
            eqBandDefaults.push({ x: newBandInstance.x, y: newBandInstance.y, q: newBandInstance.q });
        }
    }

    function getResonanceData(freq) {
        const totalHours = 12, totalAngle = Math.PI * 2;
        let hour = 0, sectorIndex = -1;
        for (let i = 0; i < visualBands.length; i++) {
            if (freq >= visualBands[i].f_low && freq < visualBands[i].f_high) {
                sectorIndex = i; break;
            }
        }
        if (sectorIndex === -1) return null;
        
        if (freq <= 300)   hour = (freq - 60) / 240 * 2;
        else if (freq <= 800)  hour = 2 + (freq - 300) / 500 * 2;
        else if (freq <= 1000) hour = 4 + (freq - 800) / 200 * 2;
        else if (freq <= 2000) hour = 6 + (freq - 1000) / 1000 * 2;
        else if (freq <= 8000) hour = 8 + (freq - 2000) / 6000 * 3;
        else if (freq <= 16000)hour = 11 + (freq - 8000) / 8000 * 1;
        else return null;

        const angle = ((hour - 3) / totalHours) * totalAngle;
        return { angle, sectorIndex };
    }

    function analyzeFrequencies() {
        if (!analyserWet || !analyserDry) return 0;
        
        analyserWet.getByteFrequencyData(frequencyDataWet);
        analyserDry.getByteFrequencyData(frequencyDataDry);
        
        if (frequencyHistory.length >= HISTORY_LENGTH) {
            const averages = frequencyHistory[0].map((_, i) => 
                frequencyHistory.reduce((sum, frame) => sum + frame[i], 0) / HISTORY_LENGTH
            );
            const binToFreq = audioContext.sampleRate / analyserWet.fftSize;
            for (let i = 0; i < frequencyDataWet.length; i++) {
                const currentVal = frequencyDataWet[i], avgVal = averages[i];
                if (currentVal > avgVal * 2.8 && currentVal > 80) {
                    const freq = i * binToFreq;
                    const resonanceData = getResonanceData(freq);
                    if (resonanceData) {
                        // Limite de destellos ajustado a 15
                        if (sparklesArray.length < 15) {
                            const brightness = Math.min((currentVal - avgVal) / 100, 1.0);
                            setTimeout(() => {
                                sparklesArray.push(new Sparkle(resonanceData.angle, brightness));
                            }, Math.random() * 200);
                            triggerSpectralSynthFromSparkle(freq, brightness, 1.0);
                        }
                    }
                }
            }
            frequencyHistory.shift(); 
        }
        frequencyHistory.push(new Uint8Array(frequencyDataWet));

        const binToFreq = audioContext.sampleRate / analyserWet.fftSize;
        const bandsLevelsWet = new Array(NUM_EQ_BANDS).fill(0).map(() => ({ total: 0, count: 0 }));
        const bandsLevelsDry = new Array(NUM_EQ_BANDS).fill(0).map(() => ({ total: 0, count: 0 }));

        for (let i = 0; i < frequencyDataWet.length; i++) {
            const freq = i * binToFreq;
            for (let j = 0; j < visualBands.length; j++) {
                 if (freq >= visualBands[j].f_low && freq < visualBands[j].f_high) {
                    bandsLevelsWet[j].total += frequencyDataWet[i]; bandsLevelsWet[j].count++;
                    bandsLevelsDry[j].total += frequencyDataDry[i]; bandsLevelsDry[j].count++;
                    break;
                }
            }
        }

        eqBandInstances.forEach((band, index) => {
             const levelDataWet = bandsLevelsWet[index];
             const levelDataDry = bandsLevelsDry[index];
             band.wetLevel = levelDataWet.count > 0 ? (levelDataWet.total/levelDataWet.count)/255 : 0;
             band.dryLevel = levelDataDry.count > 0 ? (levelDataDry.total/levelDataDry.count)/255 : 0;
        });

        eqBandInstances.forEach(band => { 
            band.wetLevel *= 2; 
            band.dryLevel *= 2;
            if (band.wetLevel > 1.0) band.wetLevel = 1.0;
            if (band.dryLevel > 1.0) band.dryLevel = 1.0;
        });
    }
    
    // ESTA ES LA NUEVA FUNCIÓN DE ANIMACIÓN OPTIMIZADA
    function animateVisualizer(currentTime) {
        animationFrameId_visualizer = requestAnimationFrame(animateVisualizer);

        // Asegurarse de que el canvas off-screen tenga el tamaño correcto
        if (offscreenCanvas.width !== spectrumCanvas.width || offscreenCanvas.height !== spectrumCanvas.height) {
            offscreenCanvas.width = spectrumCanvas.width;
            offscreenCanvas.height = spectrumCanvas.height;
        }

        if (!isAnimationEnabled) {
            if (currentTime - visualizerLastRenderTime > 250) {
                spectrumCanvasCtx.fillStyle = 'rgb(30, 30, 30)';
                spectrumCanvasCtx.fillRect(0, 0, spectrumCanvas.width, spectrumCanvas.height);
                visualizerLastRenderTime = currentTime;
            }
            return;
        }

        if (currentTime - visualizerLastRenderTime < visualizerRenderInterval) {
            return;
        }
        visualizerLastRenderTime = currentTime;

        if (!audioContext || !spectrumCanvasCtx) {
            return;
        }

        analyzeFrequencies();

        // Envía los datos de las bandas al worker para que calcule el siguiente frame
        if (animationWorker && eqBandInstances.length > 0) {
            const bandsData = eqBandInstances.map(b => ({
                x: b.x, y: b.y, wetLevel: b.wetLevel, dryLevel: b.dryLevel
            }));
            animationWorker.postMessage({ type: 'update', payload: { eqBands: bandsData } });
        }

        // --- LÓGICA DE DIBUJO OPTIMIZADA (Off-Screen Canvas) ---
        // 1. Copia el frame visible actual al canvas oculto
        offscreenCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
        offscreenCtx.drawImage(spectrumCanvas, 0, 0);

        // 2. Limpia el canvas visible con un color sólido (muy rápido)
        spectrumCanvasCtx.fillStyle = 'rgb(30, 30, 30)';
        spectrumCanvasCtx.fillRect(0, 0, spectrumCanvas.width, spectrumCanvas.height);

        // 3. Dibuja el frame anterior (ahora en el canvas oculto) con opacidad para el efecto de estela
        spectrumCanvasCtx.globalAlpha = 0.92; // Ajusta este valor para la longitud de la estela
        spectrumCanvasCtx.drawImage(offscreenCanvas, 0, 0);
        spectrumCanvasCtx.globalAlpha = 1.0;

        // 4. Dibuja el nuevo estado de las partículas usando los datos del worker
        if (lastParticleData) {
            // Dibuja las líneas de sombra
            spectrumCanvasCtx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
            spectrumCanvasCtx.lineWidth = 1;
            spectrumCanvasCtx.shadowBlur = 0;
            spectrumCanvasCtx.beginPath();
            for (let i = 0; i < lastParticleData.shadowLines.length; i += 5) {
                spectrumCanvasCtx.moveTo(lastParticleData.shadowLines[i], lastParticleData.shadowLines[i+1]);
                spectrumCanvasCtx.lineTo(lastParticleData.shadowLines[i+2], lastParticleData.shadowLines[i+3]);
            }
            spectrumCanvasCtx.stroke();

            // Dibuja las líneas principales
            spectrumCanvasCtx.lineWidth = 1.5;
            spectrumCanvasCtx.shadowBlur = 15;
            spectrumCanvasCtx.shadowColor = glowColor;
            spectrumCanvasCtx.beginPath();
            for (let i = 0; i < lastParticleData.lines.length; i += 5) {
                const opacity = Math.min(lastParticleData.lines[i+4], 1.0);
                if (opacity > 0.05) { // Solo dibuja líneas visibles
                    spectrumCanvasCtx.strokeStyle = `rgba(255,0,150,${opacity})`;
                    spectrumCanvasCtx.moveTo(lastParticleData.lines[i], lastParticleData.lines[i+1]);
                    spectrumCanvasCtx.lineTo(lastParticleData.lines[i+2], lastParticleData.lines[i+3]);
                }
            }
            spectrumCanvasCtx.stroke();
            spectrumCanvasCtx.shadowBlur = 0;
        }
        
        // El resto de la lógica de dibujo se mantiene igual
        for (let i = sparklesArray.length - 1; i >= 0; i--) {
            const s = sparklesArray[i];
            s.updateAndDraw();
            if (s.lifespan <= 0) { sparklesArray.splice(i, 1); }
        }

        drawDrawnPaths(spectrumCanvasCtx, spectrumCanvas.width, spectrumCanvas.height);
        if(eqBandInstances) eqBandInstances.forEach(b => b.draw());
        drawSpectralSynthVisuals();
    }

    function setupCanvasEventListeners() {
        if (!spectrumCanvas) return;

        if(animationPowerSwitch) {
            animationPowerSwitch.addEventListener('change', (e) => {
                isAnimationEnabled = e.target.checked;
                if(!isAnimationEnabled) {
                    setTimeout(() => {
                        spectrumCanvasCtx.fillStyle = 'rgb(30, 30, 30)';
                        spectrumCanvasCtx.fillRect(0, 0, spectrumCanvas.width, spectrumCanvas.height);
                    }, 50);
                }
            });
        }
        
        spectrumCanvas.addEventListener('mousedown', (e) => {
            if (!audioContext || e.button !== 0) return;

            const rect = spectrumCanvas.getBoundingClientRect();
            const scaleX = spectrumCanvas.width / rect.width;
            const scaleY = spectrumCanvas.height / rect.height;
            const clientX = (e.clientX - rect.left) * scaleX;
            const clientY = (e.clientY - rect.top) * scaleY;
            
            if (!eqBandInstances) return;

            for (let i = 0; i < eqBandInstances.length; i++) {
                const band = eqBandInstances[i];
                const dx = band.x - clientX;
                const dy = band.y - clientY;
                if (Math.sqrt(dx * dx + dy * dy) < band.interactionRadius) {
                    
                    if (e.altKey) {
                        const defaultState = eqBandDefaults[i];
                        if (defaultState) {
                            band.x = defaultState.x;
                            band.y = defaultState.y;
                            band.q = defaultState.q;
                            band.updateFilter(spectrumCanvas.width / 2, spectrumCanvas.height / 2, Math.min(spectrumCanvas.width, spectrumCanvas.height) / 3.5);
                        }
                        e.preventDefault();
                        e.stopPropagation();
                        return;
                    }

                    if (isMidiMapping) {
                        if (elementToMap && elementToMap.element) elementToMap.element.classList.remove('control-listening');
                        elementToMap = { id: `eq_band_${i}`, element: band }; 
                        console.log(`Escuchando MIDI para la Banda de EQ ${i}`);
                        
                        return;
                    }

                    selectedBand = band;
                    selectedBandIndex = i;
                    isQAdjusting = e.metaKey || e.ctrlKey;
                    return;
                }
            }
            
            if (spectralSynthPowerSwitch && spectralSynthPowerSwitch.checked && mainRecorderAudioBuffer && isDrawModeActive) {
                stopPathPlayback();
                isDrawingPath = true;
                if(drawnPaths.length > 0 && drawnPaths[drawnPaths.length-1].length > 0 && drawnPaths[drawnPaths.length-1].some(p => p.x)) {
                   drawnPaths.push([]);
                } else if (drawnPaths.length === 0 || (drawnPaths.length === 1 && drawnPaths[0].length === 0)) {
                   drawnPaths = [[]];
                }
                console.log("[SYNTH-MODE] Modo de Dibujo: Iniciado.");
                return;
            }
        });

        window.addEventListener('mousemove', (e) => {
            const rect = spectrumCanvas.getBoundingClientRect();
            const scaleX = spectrumCanvas.width / rect.width;
            const scaleY = spectrumCanvas.height / rect.height;
            const clientX = (e.clientX - rect.left) * scaleX;
            const clientY = (e.clientY - rect.top) * scaleY;

            if (selectedBand) {
                const centerX = spectrumCanvas.width / 2;
                const centerY = spectrumCanvas.height / 2;
                const neutralRadius = Math.min(spectrumCanvas.width, spectrumCanvas.height) / 3.5;
                if (isQAdjusting) {
                    const deltaY = e.movementY;
                    selectedBand.q -= deltaY * 0.1;
                    selectedBand.q = Math.max(0.1, Math.min(30, selectedBand.q));
                } else {
                    selectedBand.x = clientX;
                    selectedBand.y = clientY;
                }
                selectedBand.updateFilter(centerX, centerY, neutralRadius);
                
                if (window.recordAutomationEvent && armedAutomationSlot !== -1) {
                    const bandState = { x: selectedBand.x, y: selectedBand.y, q: selectedBand.q };
                    window.recordAutomationEvent(`eq_band_${selectedBandIndex}`, bandState);
                }
                return;
            }

            if (!spectralSynthPowerSwitch.checked) return;
            
            lastSpectralCoords = { x: clientX / spectrumCanvas.width, y: clientY / spectrumCanvas.height, active: true }; 
            
            if (isDrawingPath) {
                 const time = performance.now();
                 const lastPath = drawnPaths[drawnPaths.length - 1];
                 if(lastPath) lastPath.push({ x: lastSpectralCoords.x, y: lastSpectralCoords.y, time });
                 updateSpectralSynthFilters();
            }
             
            if (isSpectralSynthActive && !isDrawingPath && pathPlaybackRequestID === null && isDrawModeActive) {
                updateSpectralSynthFilters();
            }
        });

        window.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                 if (isDrawingPath) {
                    isDrawingPath = false;
                    const lastPath = drawnPaths[drawnPaths.length - 1];
                    console.log(`[SYNTH-MODE] Modo de Dibujo: Finalizado. Grabados ${lastPath ? lastPath.length : 0} puntos en el último trazo.`);
                    if (lastPath && lastPath.length > 1) {
                        startPathPlayback();
                    }
                }
                if (selectedBand) {
                    selectedBand = null;
                    selectedBandIndex = -1;
                    isQAdjusting = false;
                }
            }
        });
        
        spectrumCanvas.addEventListener('mouseleave', () => {
             if (isSpectralSynthActive) {
                stopSpectralSynth();
                lastSpectralCoords.active = false;
                console.log("[SYNTH-MODE] Modo Flotante: Detenido (ratón fuera del lienzo).");
            }
        });

        spectrumCanvas.addEventListener('contextmenu', e => e.preventDefault());
    }

    async function tryGetDeviceSampleRate(devId){try{const c={audio:{video:false}};if(devId&&devId!=="default")c.audio.deviceId={exact:devId};const s=await navigator.mediaDevices.getUserMedia(c),t=s.getAudioTracks()[0];let sR=t?.getSettings()?.sampleRate;s.getTracks().forEach(tr=>tr.stop());if(sR)return sR;}catch(err){}return undefined;}

    window.addEventListener('load', async () => {
        if(typeof SoundTouch==='undefined'||typeof SimpleFilter==='undefined')console.warn("SoundTouchJS no parece estar cargado. Flex Pitch no funcionará.");
        
        let targetSampleRate; 
        await initAudioDevicesList();
        
        if(micSelect.options.length > 0 && micSelect.options[0].value && micSelect.options[0].value !== "" && micSelect.options[0].value !== "No hay micrófonos" && micSelect.options[0].value !== "Error al listar"){
            const firstMicId = micSelect.options[0].value;
            targetSampleRate = await tryGetDeviceSampleRate(firstMicId);
        } else {
            targetSampleRate = await tryGetDeviceSampleRate("default");
        }
        
        try{
            let contextOptions={};
            if(targetSampleRate) contextOptions.sampleRate = targetSampleRate;
            audioContext = new(window.AudioContext || window.webkitAudioContext)(contextOptions);
            if(targetSampleRate && audioContext.sampleRate !== targetSampleRate) console.warn(`ADVERTENCIA: Tasa de muestreo solicitada ${targetSampleRate}Hz, pero AudioContext usa ${audioContext.sampleRate}Hz.`);
            console.log("AudioContext creado con sampleRate:", audioContext.sampleRate);
        } catch(e) {
            console.error("Error crítico al crear AudioContext:",e);
            alert("Error al inicializar el motor de audio. Intentando con config por defecto.");
            try {
                audioContext=new(window.AudioContext||window.webkitAudioContext)();
                console.log("AudioContext creado con sampleRate (fallback):", audioContext.sampleRate);
            } catch(e2) {
                console.error("Error crítico al crear AudioContext (fallback):",e2);
                alert("No se pudo inicializar el motor de audio. La aplicación no funcionará.");
                return;
            }
        }
        
        if (audioContext.state === 'suspended') {
            console.log("AudioContext está suspendido. Esperando interacción del usuario para resumir.");
        }

        if(spectrumCanvas){
            spectrumCanvasCtx=spectrumCanvas.getContext('2d');
            // La función resizeCanvas ahora está separada para ser llamada cuando sea necesario.
            function resizeCanvas() {
                const dpr = window.devicePixelRatio || 1;
                const rect = spectrumCanvas.getBoundingClientRect();
                spectrumCanvas.width = rect.width * dpr;
                spectrumCanvas.height = rect.height * dpr;
                
                initEQBands();
                initParticleSystem();

                // --- INICIO DE LA SOLUCIÓN ---
                // 1. Asegurarse de que los nuevos objetos EQBand tengan sus BiquadFilterNode creados.
                if (audioContext && eqBandInstances) {
                    eqBandInstances.forEach(band => band.createFilter());
                }
                // 2. Volver a construir la cadena de audio para usar los nuevos nodos de filtro.
                createMainAudioChain();
                // --- FIN DE LA SOLUCIÓN ---

                if(eqBandInstances) {
                    const centerX = spectrumCanvas.width / 2;
                    const centerY = spectrumCanvas.height / 2;
                    const neutralRadius = Math.min(spectrumCanvas.width, spectrumCanvas.height) / 3.5;
                    // Actualiza los valores de los nuevos filtros (esto ya estaba y es correcto)
                    eqBandInstances.forEach(b => b.updateFilter(centerX, centerY, neutralRadius));
                }
                if (!animationFrameId_visualizer) { drawInitialMessage(); }
            }
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        } else console.error("Spectrum canvas no encontrado!");

        // --- INICIALIZACIÓN DE NODOS DE AUDIO ---
        gainNode = audioContext.createGain();
        micGainNode = audioContext.createGain();
        micBooster = audioContext.createGain();
        micBooster.gain.value = 1.15;
        masterGain = audioContext.createGain();
        finalOutputGain = audioContext.createGain();
        finalOutputGain.gain.value = 1.0;
        recordSourceMixer = audioContext.createGain();
        recordSourceMixer.gain.value = 1.0;
        dryBus = audioContext.createGain();
        wetBus = audioContext.createGain();
        filePlayerDrySend = audioContext.createGain();
        filePlayerWetSend = audioContext.createGain();
        micDrySend = audioContext.createGain();
        micWetSend = audioContext.createGain();
        granulatorDrySend = audioContext.createGain();
        granulatorWetSend = audioContext.createGain();
        spectralSynthDrySend = audioContext.createGain();
        spectralSynthWetSend = audioContext.createGain();
        for (let i = 0; i < 3; i++) {
            loopDrySends.push(audioContext.createGain());
            loopWetSends.push(audioContext.createGain());
        }
        sourceSidechainSendGain = audioContext.createGain();
        sourceSidechainSendGain.gain.value = 0.0;
        loopVolumeGains=loopVolumeFaders.map((f,i)=>{const g=audioContext.createGain();g.gain.value=f?parseFloat(f.value):1;return g;});
        for(let i=0;i<3;i++){
            const sG=audioContext.createGain();
            sG.gain.value = loopSidechainSendSwitches[i].checked ? 1.0 : 0.0;
            loopSidechainSendGains.push(sG);
        }
        sidechainSummingGain = audioContext.createGain();
        sidechainAnalyserNode = audioContext.createAnalyser();
        sidechainAnalyserNode.fftSize = 256;
        sidechainAnalyserNode.smoothingTimeConstant = 0.1;
        sidechainEnvelopeDataArray = new Uint8Array(sidechainAnalyserNode.frequencyBinCount);
        sidechainModulationSource = audioContext.createConstantSource();
        sidechainModulationSource.offset.value = 1.0;
        sidechainModulationSource.start();
        sidechainModulationGain = audioContext.createGain();
        sidechainModulationGain.gain.value = 0;
        granulatorVolumeGain=audioContext.createGain();
        if(granulatorVolumeFader) granulatorVolumeGain.gain.value=parseFloat(granulatorVolumeFader.value); else granulatorVolumeGain.gain.value = 1;
        spectralSynthVolumeGain = audioContext.createGain();
        if(spectralSynthVolumeFader) spectralSynthVolumeGain.gain.value = parseFloat(spectralSynthVolumeFader.value); else spectralSynthVolumeGain.gain.value = 1;
        spectralSynthBooster = audioContext.createGain();
        spectralSynthBooster.gain.value = 1.35;
        spectralSynthBoostGain = audioContext.createGain();
        spectralSynthBoostGain.gain.value = 6.0;
        granulatorFilter=audioContext.createBiquadFilter();
        granulatorFilter.type="lowpass";
        granulatorFilter.Q.value=1;
        if(granulatorFilterFreqEl) {
             granulatorFilter.frequency.value = parseFloat(granulatorFilterFreqEl.getAttribute('data-value'));
        }
        inputGainNode_reverb=audioContext.createGain();
        dryGainNode_reverb=audioContext.createGain();
        wetGainNode_reverb=audioContext.createGain();
        reverbBooster = audioContext.createGain();
        reverbBooster.gain.value = 1.35;
        convolverNode=audioContext.createConvolver();
        analyserWet = audioContext.createAnalyser();
        analyserWet.fftSize = 2048;
        analyserWet.smoothingTimeConstant = 0.6;
        frequencyDataWet = new Uint8Array(analyserWet.frequencyBinCount);
        analyserDry = audioContext.createAnalyser();
        analyserDry.fftSize = 2048;
        analyserDry.smoothingTimeConstant = 0.6;
        frequencyDataDry = new Uint8Array(analyserDry.frequencyBinCount);
        frequencyHistory = [];
        
        // CORRECCIÓN DEL BUG DEL EQ: Crear los filtros DESPUÉS de tener el audioContext
        eqBandInstances.forEach(band => band.createFilter());
        
        // --- ASIGNACIÓN DE EVENTOS Y CONFIGURACIÓN FINAL ---
        if (playPauseBtn) playPauseBtn.addEventListener('click', togglePlayPauseFilePlayer);
        const maxChannels = 8;
        splitter = audioContext.createChannelSplitter(maxChannels);
        if (micVolumeFader) micVolumeFader.addEventListener('input', () => { if (micGainNode && audioContext) micGainNode.gain.setTargetAtTime(isMicMuted ? 0 : parseFloat(micVolumeFader.value), audioContext.currentTime, 0.01); });
        if (volumeFader) volumeFader.addEventListener('input', () => { if (gainNode && audioContext) gainNode.gain.setTargetAtTime(parseFloat(volumeFader.value), audioContext.currentTime, 0.01); });
        if (spectralSynthVolumeFader) spectralSynthVolumeFader.addEventListener('input', () => { if(spectralSynthVolumeGain) spectralSynthVolumeGain.gain.value = parseFloat(spectralSynthVolumeFader.value); });
        if (granulatorVolumeFader) granulatorVolumeFader.addEventListener('input', () => { if(granulatorVolumeGain && audioContext) granulatorVolumeGain.gain.setTargetAtTime(parseFloat(granulatorVolumeFader.value), audioContext.currentTime, 0.01); });
        const masterVolumeFader = document.getElementById('masterVolumeFader');
        const masterVolValueDisplaySpan = document.getElementById('masterVolumeValue');
        if (masterVolumeFader) {
            masterVolumeFader.addEventListener('input', () => {
                if (dryBus) dryBus.gain.value = parseFloat(masterVolumeFader.value);
                const dB = masterVolumeFader.value > 0 ? (20 * Math.log10(masterVolumeFader.value)).toFixed(1) : '-∞';
                if (masterVolValueDisplaySpan) masterVolValueDisplaySpan.textContent = `${dB} dB`;
            });
        }
        reverb_setupReverbControls();
        reverb_updateReverbSize();
        reverb_updateDryWetMix();
        setupCanvasEventListeners();
        setupSpectralSynthEventListeners();
        createSpectralSynthFilterBank();
        createMainAudioChain();
        setupAudioFileLoader();
        setupMainAudioRecorder();
        setupMasterRecorder();
        setupMidi();
        setupAutomationMemories();
        if (pitchBendDialEl) pitchBendDialEl.addEventListener('dialChange', (e) => { granulatorPitchBend = parseFloat(e.detail.value); });
        if (granulatorFilterFreqEl) granulatorFilterFreqEl.addEventListener('dialChange', (e) => { if (granulatorFilter) granulatorFilter.frequency.setTargetAtTime(parseFloat(e.detail.value), audioContext.currentTime, 0.01); });
        if (toggleGranulatorFilterBtn) toggleGranulatorFilterBtn.addEventListener('click', () => { if (granulatorFilter) { const newType = granulatorFilter.type === 'lowpass' ? 'highpass' : 'lowpass'; granulatorFilter.type = newType; toggleGranulatorFilterBtn.textContent = `Filtro: ${newType === 'lowpass' ? 'Lowpass' : 'Highpass'}`; } });
        patchableParameterIds.forEach(id => {
            const el = document.getElementById(id);
            if (id === 'grainPosFader') {
                patchParametersInfo[id] = { id, type: 'virtual', element: null, min: 0, max: 1, step: 0.01 };
                patchMappings[id] = { mouseX: false, mouseY: false };
                return;
            }
            if (el) {
                let type, min, max, step;
                if (el.classList.contains('dial')) { type = 'dial'; min = parseFloat(el.getAttribute('data-min')); max = parseFloat(el.getAttribute('data-max')); step = parseFloat(el.getAttribute('data-step')); }
                else if (el.type === 'range') { type = 'range'; min = parseFloat(el.min); max = parseFloat(el.max); step = parseFloat(el.step); }
                else { return; }
                patchParametersInfo[id] = { id, type, element: el, min, max, step };
                patchMappings[id] = { mouseX: false, mouseY: false };
            }
        });
        document.querySelectorAll('#patchBayGrid input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                const paramId = checkbox.dataset.paramId;
                const mouseAxis = checkbox.closest('tr').dataset.mouseAxis;
                if (patchMappings[paramId] && (mouseAxis === 'mouseX' || mouseAxis === 'mouseY')) patchMappings[paramId][mouseAxis] = checkbox.checked;
                isPatchBayActive = document.querySelectorAll('#patchBayGrid input[type="checkbox"]:checked').length > 0;
            });
        });
        document.addEventListener('mousemove', (event) => {
            if (isDrawingPath || !isPatchBayActive) return;
            const targetEl = event.target;
            const isUIElement = targetEl.tagName === 'INPUT' || targetEl.tagName === 'SELECT' || targetEl.tagName === 'BUTTON' || targetEl.closest('.dial');
            if (isUIElement && !targetEl.closest('#patchBayGrid')) return;
            const normalizedMouseX = event.clientX / window.innerWidth;
            const normalizedMouseY = 1.0 - (event.clientY / window.innerHeight);
            for (const paramId in patchMappings) {
                const mapping = patchMappings[paramId];
                const paramInfo = patchParametersInfo[paramId];
                if (!paramInfo || (!mapping.mouseX && !mapping.mouseY)) continue;
                let valueFromX = mapping.mouseX ? paramInfo.min + normalizedMouseX * (paramInfo.max - paramInfo.min) : null;
                let valueFromY = mapping.mouseY ? paramInfo.min + normalizedMouseY * (paramInfo.max - paramInfo.min) : null;
                let finalValue = (valueFromX !== null && valueFromY !== null) ? (valueFromX + valueFromY) / 2 : (valueFromX !== null ? valueFromX : valueFromY);
                if (finalValue !== null) {
                    if (paramId === 'grainPosFader') {
                        const mainPoint = samplerGrainPoints.find(p => p.isMain);
                        if (mainPoint) { mainPoint.x = finalValue; drawMainRecordedWaveform(); }
                    } else {
                        updateParameterProgrammatically(paramId, finalValue);
                    }
                }
            }
        });
        updateMainPlayerTimelineDisplay(); updateMasterRecordingTimelineDisplay();
        attachLoopCanvasEventsAll();
        setupGlobalKeyListeners();
        setupSidechainEventListeners();
        updateSourceButtonUIAfterDOMChange();
        toggleSourcePanels();
        const routingPatchBayGrid = document.getElementById('routingPatchBayGrid');
        if (routingPatchBayGrid) {
            const checkboxes = routingPatchBayGrid.querySelectorAll('input[type="checkbox"]');
            const nodeMap = { filePlayer: { dry: filePlayerDrySend, wet: filePlayerWetSend }, mic: { dry: micDrySend, wet: micWetSend }, granulator: { dry: granulatorDrySend, wet: granulatorWetSend }, spectralSynth: { dry: spectralSynthDrySend, wet: spectralSynthWetSend }, loop1: { dry: loopDrySends[0], wet: loopWetSends[0] }, loop2: { dry: loopDrySends[1], wet: loopWetSends[1] }, loop3: { dry: loopDrySends[2], wet: loopWetSends[2] } };
            checkboxes.forEach(checkbox => {
                const source = checkbox.dataset.source;
                const dest = checkbox.dataset.dest;
                const targetNode = nodeMap[source] ? nodeMap[source][dest] : null;
                if (targetNode) targetNode.gain.value = checkbox.checked ? 1.0 : 0.0;
                checkbox.addEventListener('change', (e) => { if (targetNode && audioContext) targetNode.gain.setTargetAtTime(e.target.checked ? 1.0 : 0.0, audioContext.currentTime, 0.01); });
            });
        }
        const toggleFullscreenBtn = document.getElementById('toggleFullscreenBtn');
        const visualizerCasilla = document.getElementById('reverb-eq-visualizer-casilla');
        function toggleTheaterMode() {
            const isInTheaterMode = visualizerCasilla.classList.toggle('theater-mode');
            document.body.classList.toggle('theater-mode-active', isInTheaterMode);
            toggleFullscreenBtn.textContent = isInTheaterMode ? "Salir de Fácil" : "Modo fácil";
            setTimeout(() => {
                if (spectrumCanvas) {
                    const resizeEvent = new Event('resize');
                    window.dispatchEvent(resizeEvent);
                }
            }, 50);
        }
        if (toggleFullscreenBtn && visualizerCasilla) toggleFullscreenBtn.addEventListener('click', toggleTheaterMode);
        requestAnimationFrame(animateVisualizer);
        console.log("SUSPIRA inicialización de UI y Audio completada.");
        loadInitialAudio('Output 1-2.wav');
    });
    function createSpectralSynthFilterBank() {
        if (!audioContext) return;
        spectralFilterBank = [];
        spectralSynthInputGain = audioContext.createGain();
        for (let i = 0; i < SPECTRAL_FILTER_COUNT; i++) {
            const filter = audioContext.createBiquadFilter();
            filter.type = 'bandpass';
            const logIndex = i / (SPECTRAL_FILTER_COUNT - 1);
            const freq = SPECTRAL_MIN_FREQ * Math.pow(SPECTRAL_MAX_FREQ / SPECTRAL_MIN_FREQ, logIndex);
            filter.frequency.value = freq;
            filter.Q.value = 50;
            const gainNode = audioContext.createGain();
            gainNode.gain.value = 0;
            spectralSynthInputGain.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(spectralSynthBoostGain);
            spectralFilterBank.push({ filter: filter, gainNode: gainNode });
        }
    }
    function createMainAudioChain() {
        if (!audioContext || !finalOutputGain) { console.error("Nodos de audio críticos no inicializados en createMainAudioChain"); return; }
        const nodesToClean = [ gainNode, micGainNode, micBooster, granulatorVolumeGain, spectralSynthVolumeGain, spectralSynthBooster, recordSourceMixer, inputGainNode_reverb, dryGainNode_reverb, wetGainNode_reverb, reverbBooster, convolverNode, finalOutputGain, sourceSidechainSendGain, sidechainSummingGain, sidechainAnalyserNode, sidechainModulationSource, sidechainModulationGain, analyserDry, analyserWet, dryBus, wetBus, filePlayerDrySend, filePlayerWetSend, micDrySend, micWetSend, granulatorDrySend, granulatorWetSend, spectralSynthDrySend, spectralSynthWetSend, granulatorFilter, ...loopVolumeGains, ...loopSidechainSendGains, ...loopDrySends, ...loopWetSends ];
        if (masterGain) nodesToClean.push(masterGain);
        eqBandInstances.forEach(band => { if (band && band.filterNode) nodesToClean.push(band.filterNode); });
        nodesToClean.forEach(node => { if (node && typeof node.disconnect === 'function') try { node.disconnect(); } catch (e) {} });
        if (spectralSynthBoostGain && spectralSynthVolumeGain) spectralSynthBoostGain.connect(spectralSynthVolumeGain);
        spectralSynthVolumeGain.connect(spectralSynthBooster);
        gainNode.connect(filePlayerDrySend);
        gainNode.connect(filePlayerWetSend);
        micGainNode.connect(micBooster);
        micBooster.connect(micDrySend);
        micBooster.connect(micWetSend);
        granulatorVolumeGain.connect(granulatorDrySend);
        granulatorVolumeGain.connect(granulatorWetSend);
        spectralSynthBooster.connect(spectralSynthDrySend);
        spectralSynthBooster.connect(spectralSynthWetSend);
        loopVolumeGains.forEach((loopVolGain, i) => { if (loopVolGain && loopDrySends[i] && loopWetSends[i]) { loopVolGain.connect(loopDrySends[i]); loopVolGain.connect(loopWetSends[i]); } });
        filePlayerDrySend.connect(dryBus); micDrySend.connect(dryBus); granulatorDrySend.connect(dryBus); spectralSynthDrySend.connect(dryBus); loopDrySends.forEach(send => send.connect(dryBus));
        filePlayerWetSend.connect(wetBus); micWetSend.connect(wetBus); granulatorWetSend.connect(wetBus); spectralSynthWetSend.connect(wetBus); loopWetSends.forEach(send => send.connect(wetBus));
        dryBus.connect(analyserDry);
        analyserDry.connect(finalOutputGain);
        wetBus.connect(inputGainNode_reverb);
        inputGainNode_reverb.connect(dryGainNode_reverb);
        inputGainNode_reverb.connect(convolverNode);
        let lastEqNode = convolverNode;
        if (eqBandInstances && eqBandInstances.length > 0) { eqBandInstances.forEach(bandInstance => { if (bandInstance.filterNode) { lastEqNode.connect(bandInstance.filterNode); lastEqNode = bandInstance.filterNode; } }); }
        lastEqNode.connect(granulatorFilter);
        if (granulatorLFOGain) granulatorLFOGain.connect(granulatorFilter.frequency);
        if (sidechainModulationSource && sidechainModulationGain) { sidechainModulationSource.connect(sidechainModulationGain); sidechainModulationGain.connect(granulatorFilter.frequency); }
        granulatorFilter.connect(wetGainNode_reverb);
        dryGainNode_reverb.connect(reverbBooster);
        wetGainNode_reverb.connect(reverbBooster);
        reverbBooster.connect(analyserWet);
        analyserWet.connect(finalOutputGain);
        gainNode.connect(recordSourceMixer);
        micBooster.connect(recordSourceMixer);
        gainNode.connect(sourceSidechainSendGain);
        micBooster.connect(sourceSidechainSendGain);
        sourceSidechainSendGain.connect(sidechainSummingGain);
        loopVolumeGains.forEach((loopVolGain, i) => { if (loopVolGain && loopSidechainSendGains[i]) loopVolGain.connect(loopSidechainSendGains[i]); });
        loopSidechainSendGains.forEach(scSendGain => { if (scSendGain && sidechainSummingGain) scSendGain.connect(sidechainSummingGain); });
        if (sidechainSummingGain && sidechainAnalyserNode) sidechainSummingGain.connect(sidechainAnalyserNode);
        if (window.masterAudioStreamDestinationNode) finalOutputGain.connect(window.masterAudioStreamDestinationNode);
        finalOutputGain.connect(audioContext.destination);
        console.log("Cadena de audio principal re-configurada.");
    }
    function setupAudioFileLoader() {
        if (audioFileInput) audioFileInput.addEventListener('change', handleAudioFileSelected);
    }
    function handleAudioFileSelected(event) {
        if (!audioContext) { console.error("AudioContext no inicializado."); alert("Error: El motor de audio no está listo."); return; }
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e_reader) { processArrayBuffer(e_reader.target.result); };
        reader.onerror = function() { if (loaderOverlay) loaderOverlay.classList.add('hidden'); alert("Error al leer archivo."); drawInitialMessage("Error al leer archivo."); };
        reader.readAsArrayBuffer(file);
    }
    function processArrayBuffer(arrayBuffer) {
        if (!arrayBuffer || arrayBuffer.byteLength === 0) { if (loaderOverlay) loaderOverlay.classList.add('hidden'); alert("Error al leer el archivo."); return; }
        if (isMainPlayerPlaying && currentSourceNode) { try { currentSourceNode.stop(); } catch (e) {} isMainPlayerPlaying = false; if (playPauseBtn) playPauseBtn.textContent = PLAY_SYMBOL; if (mainPlayerAnimationFrameId) cancelAnimationFrame(mainPlayerAnimationFrameId); }
        mainPlayerStartOffset = 0; audioBuffer = null; if (exportToBuffersBtn) exportToBuffersBtn.disabled = true;
        if (loaderOverlay) loaderOverlay.classList.remove('hidden');
        drawInitialMessage("Procesando audio...");
        audioContext.decodeAudioData(arrayBuffer, function(decodedBuffer) {
            audioBuffer = decodedBuffer; mainPlayerDuration = audioBuffer.duration;
            if (timeline) { timeline.max = mainPlayerDuration; localUpdateRangeParamProgrammatic(timeline, 0); }
            if (currentTimeDisplay) currentTimeDisplay.textContent = formatTime(0);
            if (playPauseBtn) { playPauseBtn.disabled = false; playPauseBtn.textContent = PLAY_SYMBOL; }
            if (exportToBuffersBtn) exportToBuffersBtn.disabled = false;
            isMainPlayerPlaying = false; mainPlayerStartOffset = 0;
            startReverbSystemWithBuffer(audioBuffer);
            updateMainPlayerTimelineDisplay(true);
            if (loaderOverlay) loaderOverlay.classList.add('hidden');
            updateLoopAndGranulatorWithNewBuffer(decodedBuffer);
            drawMainRecordedWaveform();
        }, function(error) {
            console.error("Error decodificando audio:", error); alert("Error al decodificar. Formato no compatible?");
            audioBuffer = null;
            if (playPauseBtn) playPauseBtn.disabled = true;
            if (exportToBuffersBtn) exportToBuffersBtn.disabled = true;
            drawInitialMessage("Error al decodificar audio.");
            if (loaderOverlay) loaderOverlay.classList.add('hidden');
        });
    }
    async function loadInitialAudio(url) {
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`No se pudo cargar el audio: ${response.statusText}`);
            const arrayBuffer = await response.arrayBuffer();
            processArrayBuffer(arrayBuffer);
        } catch (error) {
            console.error("Error al cargar el audio inicial:", error);
            drawInitialMessage("No se encontró audio inicial. Carga un archivo.");
        }
    }
    function togglePlayPauseFilePlayer() {
        if (!audioContext) return;
        if (audioContext.state === 'suspended') { audioContext.resume().then(() => { if (isMainPlayerPlaying) pauseAudioFilePlayer(); else playAudioFilePlayer(); }); }
        else { if (isMainPlayerPlaying) pauseAudioFilePlayer(); else playAudioFilePlayer(); }
    }
    function playAudioFilePlayer() {
        if (!animationFrameId_visualizer) { requestAnimationFrame(animateVisualizer); }
        if (!audioBuffer || isMainPlayerPlaying || !audioContext) return;
        if (currentSourceNode) { try { currentSourceNode.disconnect(); } catch (e) {} }
        currentSourceNode = audioContext.createBufferSource();
        currentSourceNode.buffer = audioBuffer;
        currentSourceNode.loop = isMainPlayerLoopEnabled;
        currentSourceNode.connect(gainNode);
        currentSourceNode.onended = () => { if (currentSourceNode && !currentSourceNode.loop && isMainPlayerPlaying) { isMainPlayerPlaying = false; mainPlayerStartOffset = 0; if (playPauseBtn) playPauseBtn.textContent = PLAY_SYMBOL; updateMainPlayerTimelineDisplay(true); } };
        try {
            if (mainPlayerStartOffset >= mainPlayerDuration) mainPlayerStartOffset = 0;
            currentSourceNode.start(0, mainPlayerStartOffset);
            mainPlayerStartTime = audioContext.currentTime;
            isMainPlayerPlaying = true;
            if (playPauseBtn) playPauseBtn.textContent = PAUSE_SYMBOL;
            updateMainPlayerTimelineDisplay();
        } catch (e) {
            console.error("Error al iniciar sourceNode:", e);
            isMainPlayerPlaying = false;
            if (playPauseBtn) playPauseBtn.textContent = PLAY_SYMBOL;
        }
    }
    function pauseAudioFilePlayer() {
        if (!isMainPlayerPlaying || !currentSourceNode || !audioContext) return;
        try { currentSourceNode.stop(); } catch (e) {}
        mainPlayerStartOffset += (audioContext.currentTime - mainPlayerStartTime);
        if (mainPlayerStartOffset >= mainPlayerDuration && !isMainPlayerLoopEnabled) { mainPlayerStartOffset = 0; }
        else if (isMainPlayerLoopEnabled && mainPlayerDuration > 0) { mainPlayerStartOffset %= mainPlayerDuration; }
        mainPlayerStartOffset = Math.max(0, mainPlayerStartOffset);
        isMainPlayerPlaying = false;
        if (playPauseBtn) playPauseBtn.textContent = PLAY_SYMBOL;
        if (mainPlayerAnimationFrameId) { cancelAnimationFrame(mainPlayerAnimationFrameId); mainPlayerAnimationFrameId = null; }
        updateMainPlayerTimelineDisplay(true);
        currentSourceNode = null;
    }
    if (exportToBuffersBtn) {
        exportToBuffersBtn.addEventListener('click', () => {
            if (audioBuffer) { updateLoopAndGranulatorWithNewBuffer(audioBuffer); drawMainRecordedWaveform(); }
            else { alert("Primero carga un archivo de audio para poder exportarlo."); }
        });
    }
    if (timeline) {
        timeline.addEventListener('input', () => { if (!audioBuffer || !audioContext) return; const newTime = parseFloat(timeline.value); if (!isMainPlayerPlaying) { mainPlayerStartOffset = newTime; if (currentTimeDisplay) currentTimeDisplay.textContent = formatTime(newTime); } });
        timeline.addEventListener('change', () => { if (!audioBuffer || !audioContext) return; const newTime = parseFloat(timeline.value); mainPlayerStartOffset = newTime; if (currentTimeDisplay) currentTimeDisplay.textContent = formatTime(newTime); if (isMainPlayerPlaying) { if (currentSourceNode) try { currentSourceNode.stop(); } catch (e) {} playAudioFilePlayer(); } });
    }
    async function initAudioDevicesList() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) { if (micSelect) { micSelect.innerHTML = '<option value="">API no soportada</option>'; micSelect.disabled = true; } return; }
        try {
            const tempStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
            tempStream.getTracks().forEach(track => track.stop());
            const devices = await navigator.mediaDevices.enumerateDevices();
            const audioInputDevices = devices.filter(device => device.kind === 'audioinput');
            if (micSelect) micSelect.innerHTML = '';
            if (audioInputDevices.length === 0) { if (micSelect) { micSelect.appendChild(new Option("No hay micrófonos", "")); micSelect.disabled = true; } return; }
            if (micSelect) { micSelect.disabled = false; audioInputDevices.forEach((device, index) => { micSelect.appendChild(new Option(device.label || `Micrófono ${index + 1}`, device.deviceId)); }); }
        } catch (err) {
            if (micSelect) { micSelect.innerHTML = '<option value="">Error al listar / Sin permiso</option>'; micSelect.disabled = true; }
            if (err.name === "NotAllowedError" || err.name === "PermissionDeniedError") { alert("Permiso para acceder al micrófono denegado."); }
            console.error("Error al inicializar lista de dispositivos de audio:", err);
        }
    }
    function stopCurrentAudioSourceLogic() {
        if (mediaStream) { mediaStream.getTracks().forEach(track => track.stop()); mediaStream = null; }
        if (currentSourceNode) { try { if (typeof currentSourceNode.stop === 'function') currentSourceNode.stop(); currentSourceNode.disconnect(); } catch (e) {} currentSourceNode = null; }
        isMainPlayerPlaying = false;
        if (playPauseBtn) playPauseBtn.textContent = PLAY_SYMBOL;
        if (mainPlayerAnimationFrameId) { cancelAnimationFrame(mainPlayerAnimationFrameId); mainPlayerAnimationFrameId = null; }
    }
    async function startMicAudio(deviceId) {
        if (!animationFrameId_visualizer) { requestAnimationFrame(animateVisualizer); }
        if (!audioContext) return false;
        if (audioContext.state === 'suspended') { try { await audioContext.resume(); } catch (e) { return false; } }
        stopCurrentAudioSourceLogic();
        const maxChannelsToRequest = 8;
        const constraints = { audio: { deviceId: deviceId ? { exact: deviceId } : undefined, channelCount: { ideal: maxChannelsToRequest }, echoCancellation: false, noiseSuppression: false, autoGainControl: false }, video: false };
        try {
            mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
            currentSourceNode = audioContext.createMediaStreamSource(mediaStream);
            const sourceChannelCount = currentSourceNode.channelCount;
            if (channelSelect) {
                const currentChannelValue = channelSelect.value;
                channelSelect.innerHTML = '';
                for (let i = 0; i < sourceChannelCount; i++) { const option = new Option(`Canal ${i + 1}`, i); channelSelect.appendChild(option); }
                channelSelect.value = (currentChannelValue < sourceChannelCount) ? currentChannelValue : 0;
                channelSelect.disabled = (sourceChannelCount < 2);
            }
            currentMicChannelIndex = channelSelect ? parseInt(channelSelect.value, 10) : 0;
            if (isNaN(currentMicChannelIndex) || currentMicChannelIndex >= sourceChannelCount) { currentMicChannelIndex = 0; if (channelSelect) channelSelect.value = "0"; }
            if (!micGainNode) micGainNode = audioContext.createGain();
            micGainNode.gain.value = isMicMuted ? 0 : parseFloat(micVolumeFader.value);
            currentSourceNode.connect(splitter);
            splitter.disconnect();
            splitter.connect(micGainNode, currentMicChannelIndex, 0);
            if (convolverNode && !convolverNode.buffer) reverb_updateReverbSize();
            reverb_updateDryWetMix();
            return true;
        } catch (err) {
            alert(`Error al iniciar micrófono: ${err.message}.`);
            currentAudioSourceType = 'file';
            toggleSourcePanels();
            return false;
        }
    }
    function updateSourceButtonUIAfterDOMChange() { if (sourceToggleButton) { sourceToggleButton.setAttribute('aria-label', currentAudioSourceType === 'file' ? 'Fuente: Archivo, cambiar a Micrófono' : 'Fuente: Micrófono, cambiar a Archivo'); } }
    function toggleSourcePanels() { if (micPanel) micPanel.style.display = currentAudioSourceType === 'mic' ? 'block' : 'none'; if (filePanel) filePanel.style.display = currentAudioSourceType === 'file' ? 'block' : 'none'; updateSourceButtonUIAfterDOMChange(); }
    async function handleSourceChange() {
        stopCurrentAudioSourceLogic();
        toggleSourcePanels();
        if (currentAudioSourceType === 'mic') {
            let micStarted = false;
            if (micSelect.value && micSelect.value !== "") { micStarted = await startMicAudio(micSelect.value); }
            else if (micSelect.options.length > 0 && micSelect.options[0].value !== "" && micSelect.options[0].value !== "No hay micrófonos" && micSelect.options[0].value !== "Error al listar") { micStarted = await startMicAudio(micSelect.options[0].value); }
            if (!micStarted) { currentAudioSourceType = 'file'; toggleSourcePanels(); if (audioBuffer) { startReverbSystemWithBuffer(audioBuffer); } else { drawInitialMessage("Carga un archivo de audio para ver el espectro."); } }
        } else {
            if (audioBuffer) { startReverbSystemWithBuffer(audioBuffer); }
            else { drawInitialMessage("Carga un archivo de audio para ver el espectro."); }
        }
    }
    if (sourceToggleButton) { sourceToggleButton.addEventListener('click', () => { currentAudioSourceType = currentAudioSourceType === 'file' ? 'mic' : 'file'; handleSourceChange(); }); }
    if (micSelect) { micSelect.addEventListener('change', async () => { if (currentAudioSourceType === 'mic') { await handleSourceChange(); } }); }
    if (channelSelect) { channelSelect.addEventListener('change', () => { if (currentAudioSourceType !== 'mic' || !splitter || !micGainNode || !currentSourceNode) return; const newChannelIdx = Number(channelSelect.value); if (isNaN(newChannelIdx) || newChannelIdx >= currentSourceNode.channelCount) return; try { splitter.disconnect(); splitter.connect(micGainNode, newChannelIdx, 0); currentMicChannelIndex = newChannelIdx; } catch (err) { console.error("Error al cambiar canal de micrófono:", err); } }); }
    function startReverbSystemWithBuffer(loadedAudioBuffer) { if (convolverNode && !convolverNode.buffer) reverb_updateReverbSize(); reverb_updateDryWetMix(); }
    function updateMainPlayerTimelineDisplay(isPausedOrForceUpdate = false) {
        if (isMainPlayerPlaying && audioBuffer && audioContext && currentSourceNode) {
            let currentTimeInTrack = mainPlayerStartOffset + (audioContext.currentTime - mainPlayerStartTime);
            if (isMainPlayerLoopEnabled && audioBuffer.duration > 0) { currentTimeInTrack %= audioBuffer.duration; } else { currentTimeInTrack = Math.max(0, Math.min(currentTimeInTrack, mainPlayerDuration)); }
            if (timeline && parseFloat(timeline.value).toFixed(1) !== parseFloat(currentTimeInTrack).toFixed(1)) { timeline.value = currentTimeInTrack; const numInput = document.getElementById('timelineValueInput'); if (numInput) numInput.value = parseFloat(currentTimeInTrack).toFixed(1); }
            if (currentTimeDisplay) { currentTimeDisplay.textContent = formatTime(currentTimeInTrack); }
            mainPlayerAnimationFrameId = requestAnimationFrame(updateMainPlayerTimelineDisplay);
        } else if (isPausedOrForceUpdate) {
            if (mainPlayerAnimationFrameId) { cancelAnimationFrame(mainPlayerAnimationFrameId); mainPlayerAnimationFrameId = null; }
            let finalTime = mainPlayerStartOffset;
            if (audioBuffer && finalTime >= mainPlayerDuration && !isMainPlayerLoopEnabled) finalTime = 0;
            else if (audioBuffer && isMainPlayerLoopEnabled && mainPlayerDuration > 0) finalTime %= mainPlayerDuration;
            finalTime = audioBuffer ? Math.max(0, Math.min(finalTime, mainPlayerDuration)) : 0;
            if (timeline) { timeline.value = finalTime; const numInput = document.getElementById('timelineValueInput'); if (numInput) numInput.value = parseFloat(finalTime).toFixed(1); }
            if (currentTimeDisplay) { currentTimeDisplay.textContent = formatTime(finalTime); }
        }
    }
    function setupMainAudioRecorder() {
        if (!audioContext || !recordSourceMixer) { return; }
        mainRecordingStreamDestinationNode = audioContext.createMediaStreamDestination();
        try { recordSourceMixer.connect(mainRecordingStreamDestinationNode); } catch (e) { console.error("Error al conectar recordSourceMixer a mainRecordingStreamDestinationNode:", e); return; }
        const options = { mimeType: 'audio/webm;codecs=opus' };
        try { mainAudioRecorder = new MediaRecorder(mainRecordingStreamDestinationNode.stream, (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(options.mimeType)) ? options : undefined); }
        catch (e) { mainAudioRecorder = new MediaRecorder(mainRecordingStreamDestinationNode.stream); }
        mainAudioRecorder.ondataavailable = (event) => { if (event.data && event.data.size > 0) mainRecordedChunks.push(event.data); };
        mainAudioRecorder.onstop = async () => {
            if (mainRecordedChunks.length === 0 && currentRecordingMode !== "clear_for_empty_record" && currentRecordingMode !== "clear_direct") {
                if (currentRecordingMode === "record") { updateLoopAndGranulatorWithNewBuffer(null); if (recordedWaveformCanvas) drawMainRecordedWaveform(true); if (granulatorPlayToggleBtn) granulatorPlayToggleBtn.disabled = true; }
                enableRecordingButtons(); currentRecordingMode = ""; return;
            }
            if (currentRecordingMode === "clear_for_empty_record" || currentRecordingMode === "clear_direct") {
                updateLoopAndGranulatorWithNewBuffer(null); mainRecordedChunks = []; if (recordedWaveformCanvas) drawMainRecordedWaveform(true); enableRecordingButtons(); if (granulatorPlayToggleBtn) granulatorPlayToggleBtn.disabled = true; currentRecordingMode = ""; return;
            }
            const blob = new Blob(mainRecordedChunks, { type: mainAudioRecorder.mimeType || 'audio/webm' });
            mainRecordedChunks = [];
            if (blob.size === 0 && currentRecordingMode !== "record") { enableRecordingButtons(); currentRecordingMode = ""; return; }
            try {
                const arrayBuffer = await blob.arrayBuffer();
                if (arrayBuffer.byteLength === 0) { if (currentRecordingMode === "record") { updateLoopAndGranulatorWithNewBuffer(null); if (recordedWaveformCanvas) drawMainRecordedWaveform(true); if (granulatorPlayToggleBtn) granulatorPlayToggleBtn.disabled = true; } enableRecordingButtons(); currentRecordingMode = ""; return; }
                const decodedAudioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                let resultingBuffer = null;
                if (currentRecordingMode === "record") { resultingBuffer = decodedAudioBuffer; }
                else if (currentRecordingMode === "append") {
                    const oldDuration = mainRecorderAudioBuffer ? mainRecorderAudioBuffer.duration : 0;
                    const absoluteLoopSelections = loopSelections.map(sel => ({ start: sel.start * oldDuration, end: sel.end * oldDuration }));
                    resultingBuffer = mainRecorderAudioBuffer ? appendAudioBuffers(mainRecorderAudioBuffer, decodedAudioBuffer, audioContext) : decodedAudioBuffer;
                    const newDuration = resultingBuffer.duration;
                    if (newDuration > 0) { loopSelections = absoluteLoopSelections.map(absSel => ({ start: absSel.start / newDuration, end: absSel.end / newDuration })); }
                } else if (currentRecordingMode === "overdub") { resultingBuffer = mainRecorderAudioBuffer ? mixAudioBuffers(mainRecorderAudioBuffer, decodedAudioBuffer, audioContext) : decodedAudioBuffer; }
                updateLoopAndGranulatorWithNewBuffer(resultingBuffer);
                if (recordedWaveformCanvas) drawMainRecordedWaveform();
                if (granulatorPlayToggleBtn) granulatorPlayToggleBtn.disabled = !mainRecorderAudioBuffer;
            } catch (decodeError) {
                console.error("Error decodificando audio grabado principal:", decodeError);
                if (currentRecordingMode === "record") { updateLoopAndGranulatorWithNewBuffer(null); if (recordedWaveformCanvas) drawMainRecordedWaveform(true); }
            }
            currentRecordingMode = "";
            enableRecordingButtons();
        };
    }
    function enableRecordingButtons() { if (!recordBtn || !stopRecBtn || !appendRecBtn || !overdubNowBtn) return; const isRecorderActive = mainAudioRecorder && mainAudioRecorder.state === "recording"; recordBtn.disabled = isRecorderActive; stopRecBtn.disabled = !isRecorderActive; const hasRecording = !!mainRecorderAudioBuffer; appendRecBtn.disabled = isRecorderActive || !hasRecording; overdubNowBtn.disabled = isRecorderActive || !hasRecording; }
    function appendAudioBuffers(buffer1, buffer2, context) {
        if (!buffer1) return buffer2; if (!buffer2) return buffer1;
        const numberOfChannels = Math.min(buffer1.numberOfChannels, buffer2.numberOfChannels);
        const combinedLength = buffer1.length + buffer2.length;
        const newBuffer = context.createBuffer(numberOfChannels, combinedLength, buffer1.sampleRate);
        for (let i = 0; i < numberOfChannels; i++) { const channelData = newBuffer.getChannelData(i); channelData.set(buffer1.getChannelData(i), 0); channelData.set(buffer2.getChannelData(i), buffer1.length); }
        return newBuffer;
    }
    function mixAudioBuffers(buffer1, buffer2, context) {
        if (!buffer1) return buffer2; if (!buffer1) return buffer2;
        const numberOfChannels = Math.min(buffer1.numberOfChannels, buffer2.numberOfChannels);
        if (buffer1.sampleRate !== buffer2.sampleRate) { console.error("No se pueden mezclar buffers con diferentes sample rates."); return buffer1; }
        const length = Math.max(buffer1.length, buffer2.length);
        const mixedBuffer = context.createBuffer(numberOfChannels, length, buffer1.sampleRate);
        for (let channel = 0; channel < numberOfChannels; channel++) {
            const outputData = mixedBuffer.getChannelData(channel);
            const buffer1Data = buffer1.numberOfChannels > channel ? buffer1.getChannelData(channel) : null;
            const buffer2Data = buffer2.numberOfChannels > channel ? buffer2.getChannelData(channel) : null;
            for (let i = 0; i < length; i++) { let sample1 = buffer1Data && i < buffer1.length ? buffer1Data[i] : 0; let sample2 = buffer2Data && i < buffer2.length ? buffer2Data[i] : 0; outputData[i] = Math.max(-1.0, Math.min(1.0, sample1 + sample2)); }
        }
        return mixedBuffer;
    }
    if (recordBtn) recordBtn.addEventListener('click', () => { if (!audioContext || !mainAudioRecorder) return; if (audioContext.state === 'suspended') audioContext.resume(); mainRecordedChunks = []; currentRecordingMode = "record"; try { mainAudioRecorder.start(); enableRecordingButtons(); } catch (e) { console.error("Error al iniciar grabación:", e); enableRecordingButtons(); } });
    if (appendRecBtn) appendRecBtn.addEventListener('click', () => { if (!mainRecorderAudioBuffer || !audioContext || !mainAudioRecorder) return; if (audioContext.state === 'suspended') audioContext.resume(); mainRecordedChunks = []; currentRecordingMode = "append"; try { mainAudioRecorder.start(); enableRecordingButtons(); } catch (e) { console.error("Error al iniciar append:", e); enableRecordingButtons(); } });
    if (overdubNowBtn) overdubNowBtn.addEventListener('click', () => { if (!mainRecorderAudioBuffer || !audioContext || !mainAudioRecorder) return; if (audioContext.state === 'suspended') audioContext.resume(); mainRecordedChunks = []; currentRecordingMode = "overdub"; try { mainAudioRecorder.start(); enableRecordingButtons(); } catch (e) { console.error("Error al iniciar overdub:", e); enableRecordingButtons(); } });
    if (stopRecBtn) stopRecBtn.addEventListener('click', () => { if (mainAudioRecorder && mainAudioRecorder.state === "recording") { mainAudioRecorder.stop(); if (stopRecBtn) stopRecBtn.disabled = true; } else { enableRecordingButtons(); } });
    if (clearRecBtn) clearRecBtn.addEventListener('click', () => {
        if (mainAudioRecorder && mainAudioRecorder.state === "recording") { currentRecordingMode = "clear_for_empty_record"; mainAudioRecorder.stop(); }
        else { updateLoopAndGranulatorWithNewBuffer(null); mainRecordedChunks = []; if (recordedWaveformCanvas) drawMainRecordedWaveform(true); currentRecordingMode = "clear_direct"; }
        loopSelections.forEach((s, i) => { loopSelections[i] = { start: 0, end: 1 }; sampleSelections[i] = { start: 0, end: 0 }; if (loopCanvases[i]) drawLoopWaveformVisuals(i, true); });
        isLoopRealtimePlaying.forEach((isPlaying, i) => { if (isPlaying) stopLoopRealtimePlayback(i); });
        enableRecordingButtons();
        if (granulatorPlayToggleBtn) granulatorPlayToggleBtn.disabled = true;
        if (currentRecordingMode === "clear_direct") currentRecordingMode = "";
    });
    function drawMainRecordedWaveform(clearCanvasOnly = false) {
        if (!recordedWaveformCanvas) return;
        const canvasCtx = recordedWaveformCanvas.getContext('2d');
        const width = recordedWaveformCanvas.width;
        const height = recordedWaveformCanvas.height;
        canvasCtx.fillStyle = getComputedStyle(recordedWaveformCanvas).backgroundColor || 'var(--primary-bg-color)';
        canvasCtx.fillRect(0, 0, width, height);
        if (!clearCanvasOnly && mainRecorderAudioBuffer && mainRecorderAudioBuffer.duration > 0) {
            const channelData = mainRecorderAudioBuffer.getChannelData(0);
            if (channelData && channelData.length > 0) {
                let step = Math.max(1, Math.floor(channelData.length / width));
                canvasCtx.lineWidth = 1;
                canvasCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                canvasCtx.beginPath();

                for (let x = 0; x < width; x++) {
                    let sliceStart = Math.floor(x * step);
                    if (sliceStart >= channelData.length) break;
                    
                    let minPeak = 0, maxPeak = 0;
                    for (let j = 0; j < step; j++) {
                        if (sliceStart + j < channelData.length) {
                            const val = channelData[sliceStart + j];
                            if (val < minPeak) minPeak = val;
                            if (val > maxPeak) maxPeak = val;
                        }
                    }
                    let yMax = (0.5 * (-maxPeak + 1.0)) * height;
                    let yMin = (0.5 * (-minPeak + 1.0)) * height;
                    
                    canvasCtx.moveTo(x, yMin);
                    canvasCtx.lineTo(x, yMax);
                }
                canvasCtx.stroke();
            }
        }
        
        const pointRadius = 4;
        samplerGrainPoints.forEach(point => {
            const x = point.x * width;
            const y = point.y * height;
            
            canvasCtx.beginPath();
            canvasCtx.arc(x, y, pointRadius, 0, 2 * Math.PI);

            if (point.active) {
                canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                canvasCtx.fill();
                canvasCtx.strokeStyle = 'rgba(200, 200, 200, 0.8)';
                canvasCtx.lineWidth = 1;
                canvasCtx.stroke();
            } else {
                canvasCtx.strokeStyle = 'grey';
                canvasCtx.lineWidth = 1.5;
                canvasCtx.stroke();
            }
        });
    }

    if (recordedWaveformCanvas) {
        recordedWaveformCanvas.addEventListener('contextmenu', e => e.preventDefault());

        recordedWaveformCanvas.addEventListener('mousedown', e => {
            if (!mainRecorderAudioBuffer) return;
            const rect = recordedWaveformCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const pointHitRadius = 10;
            let pointClickedIndex = -1;

            for (let i = samplerGrainPoints.length - 1; i >= 0; i--) {
                const point = samplerGrainPoints[i];
                const pointCanvasX = point.x * rect.width;
                const pointCanvasY = point.y * rect.height;
                const distance = Math.sqrt(Math.pow(x - pointCanvasX, 2) + Math.pow(y - pointCanvasY, 2));

                if (distance < pointHitRadius) {
                    pointClickedIndex = i;
                    break;
                }
            }

            if (pointClickedIndex !== -1) {
                if (e.button === 2) {
                    samplerGrainPoints[pointClickedIndex].active = !samplerGrainPoints[pointClickedIndex].active;
                    if(samplerGrainPoints[pointClickedIndex].isMain) samplerGrainPoints[pointClickedIndex].active = true;
                    drawMainRecordedWaveform();
                    e.preventDefault();
                }
                else if (e.button === 0) {
                    isDraggingGrainPoint = true;
                    selectedGrainPointIndex = pointClickedIndex;
                }
            }
        });

        window.addEventListener('mousemove', e => {
            if (!isDraggingGrainPoint || selectedGrainPointIndex === -1) return;
            
            const rect = recordedWaveformCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const normalizedX = Math.max(0, Math.min(x / rect.width, 1));

            samplerGrainPoints[selectedGrainPointIndex].x = normalizedX;
            drawMainRecordedWaveform();
        });

        window.addEventListener('mouseup', e => {
            if (e.button === 0) {
                isDraggingGrainPoint = false;
                selectedGrainPointIndex = -1;
            }
        });

        recordedWaveformCanvas.addEventListener('mouseleave', () => {
            isDraggingGrainPoint = false;
            selectedGrainPointIndex = -1;
        });
    }

    function formatTime(totalSeconds){
        if(isNaN(totalSeconds) || totalSeconds < 0) totalSeconds = 0;
        let minutes = Math.floor(totalSeconds / 60);
        let seconds = Math.floor(totalSeconds % 60);
        return `${minutes}:${seconds.toString().padStart(2,'0')}`;
    }

    function scheduleNextGrainPlayback() {
        const activePoints = samplerGrainPoints.filter(p => p.active);

        if (!isGranulatorRunning || !mainRecorderAudioBuffer || mainRecorderAudioBuffer.duration === 0 || activePoints.length === 0) {
            isGranulatorRunning = false;
            if (granulatorTimeoutId) clearTimeout(granulatorTimeoutId);
            granulatorTimeoutId = null;
            if(granulatorPlayToggleBtn) {
                 granulatorPlayToggleBtn.disabled = !mainRecorderAudioBuffer;
                 granulatorPlayToggleBtn.textContent = PLAY_SYMBOL;
            }
            return;
        }
        
        const randomPoint = activePoints[Math.floor(Math.random() * activePoints.length)];
        let grainPosition = randomPoint.x;

        let bufferDuration = mainRecorderAudioBuffer.duration;
        const currentGrainLength = parseFloat(grainLengthDialEl.getAttribute('data-value'));
        let effectiveGrainLength = Math.min(currentGrainLength, bufferDuration * 0.99);
        if (effectiveGrainLength <= 0.001) effectiveGrainLength = 0.001;

        let grainStartPositionInBuffer = grainPosition * (bufferDuration - effectiveGrainLength);
        grainStartPositionInBuffer = Math.max(0, Math.min(grainStartPositionInBuffer, bufferDuration - effectiveGrainLength));

        let grainSource = audioContext.createBufferSource();
        grainSource.buffer = mainRecorderAudioBuffer;
        
        let actualPlaybackRate = 1.0;
        const currentPitchBend = parseFloat(pitchBendDialEl.getAttribute('data-value'));
        if (currentPitchBend !== 0) {
            actualPlaybackRate = Math.pow(2, currentPitchBend / 12);
            grainSource.playbackRate.value = actualPlaybackRate;
        }

        let grainEnvelope = audioContext.createGain();
        grainSource.connect(grainEnvelope);
        grainEnvelope.connect(granulatorVolumeGain);

        let now = audioContext.currentTime;
        const grainDuration = effectiveGrainLength / actualPlaybackRate;
        let fadeInDuration = grainDuration * 0.5;
        let fadeOutDuration = grainDuration * 0.5;

        grainEnvelope.gain.setValueAtTime(0, now);
        grainEnvelope.gain.linearRampToValueAtTime(1, now + fadeInDuration);
        grainEnvelope.gain.linearRampToValueAtTime(0, now + grainDuration);

        try {
            grainSource.start(now, grainStartPositionInBuffer, grainDuration);
        } catch (e) {
            console.error("Error al iniciar grano:", e);
            isGranulatorRunning = false;
            if (granulatorTimeoutId) clearTimeout(granulatorTimeoutId);
            granulatorTimeoutId = null;
            if(granulatorPlayToggleBtn) {
                granulatorPlayToggleBtn.disabled = false;
                granulatorPlayToggleBtn.textContent = PLAY_SYMBOL;
            }
            return;
        }
        
        grainSource.onended = () => {
            try {
                grainSource.disconnect();
                grainEnvelope.disconnect();
            } catch (e) { }
        };

        const currentOverlap = parseFloat(overlapDialEl.getAttribute('data-value'));
        const delay = effectiveGrainLength * 1000 * (1 - currentOverlap);
        const finalDelay = Math.max(10, delay / actualPlaybackRate);

        granulatorTimeoutId = setTimeout(scheduleNextGrainPlayback, finalDelay);
    }

    function toggleGranulator() {
        if (isGranulatorRunning) {
            isGranulatorRunning = false;
            if (granulatorTimeoutId) {
                clearTimeout(granulatorTimeoutId);
                granulatorTimeoutId = null;
            }
            if(granulatorPlayToggleBtn) {
                granulatorPlayToggleBtn.disabled = !mainRecorderAudioBuffer;
                granulatorPlayToggleBtn.textContent = PLAY_SYMBOL;
            }
        } else {
            if (!mainRecorderAudioBuffer || mainRecorderAudioBuffer.duration === 0) return;
            if (audioContext.state === 'suspended') audioContext.resume();
            
            isGranulatorRunning = true;
            if(granulatorPlayToggleBtn) {
                granulatorPlayToggleBtn.disabled = false;
                granulatorPlayToggleBtn.textContent = STOP_SYMBOL;
            }
            scheduleNextGrainPlayback();
        }
    }

    if(granulatorPlayToggleBtn) granulatorPlayToggleBtn.addEventListener('click', toggleGranulator);
    
    if(lfoPowerSwitch) {
        lfoPowerSwitch.addEventListener('change', (e) => {
            if (!audioContext || !granulatorFilter) return;
            const lfoEnabled = e.target.checked;
            
            if (lfoEnabled) {
                if (!granulatorLFO) {
                    granulatorLFO = audioContext.createOscillator();
                    granulatorLFO.type = "sine";
                    granulatorLFO.frequency.value = granulatorLfoSpeedFader ? parseFloat(granulatorLfoSpeedFader.value) : 1;
                    
                    granulatorLFOGain = audioContext.createGain();
                    granulatorLFOGain.gain.value = granulatorLfoDepthFader ? parseFloat(granulatorLfoDepthFader.value) : 500;
                    
                    granulatorLFO.connect(granulatorLFOGain);
                    granulatorLFOGain.connect(granulatorFilter.frequency);
                    try {
                        granulatorLFO.start();
                    } catch (startError) {
                        try { granulatorLFO.stop(); granulatorLFO.start(); } catch (restartError) {}
                    }
                }
            } else {
                if (granulatorLFO) {
                    try { granulatorLFO.stop(); } catch (stopError) {}
                    granulatorLFO.disconnect();
                    if (granulatorLFOGain) granulatorLFOGain.disconnect(granulatorFilter.frequency);
                    granulatorLFO = null;
                    granulatorLFOGain = null;
                }
            }
        });
    }

    if(granulatorLfoSpeedFader) granulatorLfoSpeedFader.addEventListener('input', (e) => {
        if (granulatorLFO) granulatorLFO.frequency.setTargetAtTime(parseFloat(e.target.value), audioContext.currentTime, 0.01);
    });
    if(granulatorLfoDepthFader) granulatorLfoDepthFader.addEventListener('input', (e) => {
        if (granulatorLFOGain) granulatorLFOGain.gain.setTargetAtTime(parseFloat(e.target.value), audioContext.currentTime, 0.01);
    });
    
    function setupSidechainEventListeners() {
        if (sidechainEnvelopePowerSwitch) {
            sidechainEnvelopePowerSwitch.addEventListener('change', () => {
                isSidechainEnvelopeProcessingActive = sidechainEnvelopePowerSwitch.checked;
                
                if (isSidechainEnvelopeProcessingActive) {
                    if (audioContext.state === 'suspended') audioContext.resume();
                    startSidechainEnvelopeProcessing();
                } else {
                    stopSidechainEnvelopeProcessing();
                }
            });
        }
        
        if (sourceSidechainSendSwitches) {
            sourceSidechainSendSwitches.forEach(switchEl => {
                switchEl.addEventListener('change', e => {
                    const isChecked = e.target.checked;
                    if(sourceSidechainSendGain && audioContext) {
                        const gainValue = isChecked ? 1.0 : 0.0;
                        sourceSidechainSendGain.gain.setTargetAtTime(gainValue, audioContext.currentTime, 0.01);
                    }
                    sourceSidechainSendSwitches.forEach(otherSwitch => {
                        if (otherSwitch !== e.target) {
                            otherSwitch.checked = isChecked;
                        }
                    });
                });
            });
        }
        
        loopSidechainSendSwitches.forEach((switchEl, idx) => {
            if(switchEl) switchEl.addEventListener('change', (e) => {
                const gainValue = e.target.checked ? 1.0 : 0.0;
                if(loopSidechainSendGains[idx] && audioContext) {
                    loopSidechainSendGains[idx].gain.setTargetAtTime(gainValue, audioContext.currentTime, 0.01);
                }
            });
        });

        sidechainThresholdDialEl?.addEventListener('dialChange', e => { sidechainThresholdValue = parseFloat(e.detail.value); });
        sidechainAttackDialEl?.addEventListener('dialChange', e => { sidechainAttackTime = parseFloat(e.detail.value); });
        sidechainReleaseDialEl?.addEventListener('dialChange', e => { sidechainReleaseTime = parseFloat(e.detail.value); });
        sidechainAmountDialEl?.addEventListener('dialChange', e => {
            sidechainModulationAmount = parseFloat(e.detail.value);
        });
    }

    function startSidechainEnvelopeProcessing() {
        if (!isSidechainEnvelopeProcessingActive || sidechainAnimationRequest !== null) return;
        if (sidechainSummingGain && sidechainAnalyserNode) {
             try { sidechainSummingGain.disconnect(sidechainAnalyserNode); } catch(e){}
             try { sidechainSummingGain.connect(sidechainAnalyserNode); } catch(e){ console.error("Error conectando sidechainSummingGain a sidechainAnalyserNode", e); }
        }
        processEnvelope();
    }
    
    function processEnvelope() {
        if (!isSidechainEnvelopeProcessingActive || !audioContext || audioContext.state === 'closed') {
            stopSidechainEnvelopeProcessing();
            return;
        }
        sidechainAnalyserNode.getByteTimeDomainData(sidechainEnvelopeDataArray);
        let sumOfSquares = 0;
        for (let i = 0; i < sidechainEnvelopeDataArray.length; i++) {
            const normalizedSample = (sidechainEnvelopeDataArray[i] / 128.0) - 1.0;
            sumOfSquares += normalizedSample * normalizedSample;
        }
        const rms = Math.sqrt(sumOfSquares / sidechainEnvelopeDataArray.length);
        const rmsDb = 20 * Math.log10(rms || 0.00001);

        let targetEnvelope = 0;
        if (rmsDb > sidechainThresholdValue) {
            const dynamicRangeDb = 24;
            targetEnvelope = Math.min(1, Math.max(0, (rmsDb - sidechainThresholdValue) / dynamicRangeDb));
        }

        const updateIntervalSeconds = 1/60;
        if (targetEnvelope > sidechainSmoothedEnvelope) {
            const attackConstant = 1 - Math.exp(-updateIntervalSeconds / Math.max(0.001, sidechainAttackTime));
            sidechainSmoothedEnvelope += (targetEnvelope - sidechainSmoothedEnvelope) * attackConstant;
        } else {
            const releaseConstant = 1 - Math.exp(-updateIntervalSeconds / Math.max(0.001, sidechainReleaseTime));
            sidechainSmoothedEnvelope += (targetEnvelope - sidechainSmoothedEnvelope) * releaseConstant;
        }
        sidechainSmoothedEnvelope = Math.max(0, Math.min(1, sidechainSmoothedEnvelope));

        const finalModulationValue = sidechainSmoothedEnvelope * -sidechainModulationAmount;
        if (sidechainModulationGain) {
            sidechainModulationGain.gain.setTargetAtTime(finalModulationValue, audioContext.currentTime, 0.01);
        }

        sidechainAnimationRequest = requestAnimationFrame(processEnvelope);
    }

    function stopSidechainEnvelopeProcessing() {
        if (sidechainAnimationRequest) {
            cancelAnimationFrame(sidechainAnimationRequest);
            sidechainAnimationRequest = null;
        }
        if (sidechainModulationGain) {
            sidechainModulationGain.gain.setTargetAtTime(0, audioContext.currentTime, 0.01);
        }
        sidechainSmoothedEnvelope = 0;
    }
    
    let isLoopRealtimePlaying = [false, false, false];
    let realtimeLoopSourceNodes = [null, null, null];
    
    function drawLoopWaveformVisuals(loopIndex, playheadPosition = -1) {
        const canvas = loopCanvases[loopIndex];
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const loopSelection = loopSelections[loopIndex];
        const sampleSelection = sampleSelections[loopIndex];
        
        const width = canvas.width;
        const height = canvas.height;
        const styles = getComputedStyle(canvas);

        ctx.fillStyle = styles.backgroundColor || 'var(--casilla-bg-color)';
        ctx.fillRect(0, 0, width, height);

        if (mainRecorderAudioBuffer && mainRecorderAudioBuffer.duration > 0) {
            const channelData = mainRecorderAudioBuffer.getChannelData(0);
            const zoom = loopZoomLevels[loopIndex];
            const panOffsetNormalized = loopPanOffsets[loopIndex];
            const totalBufferFrames = channelData.length;
            const visiblePortionNormalized = 1 / zoom;
            const startFrameInFullBuffer = Math.floor(panOffsetNormalized * totalBufferFrames);
            const framesToDisplayInView = Math.floor(visiblePortionNormalized * totalBufferFrames);
            
            if (framesToDisplayInView > 0) {
                ctx.strokeStyle = styles.getPropertyValue('--highlight-color').trim() || "magenta";
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                const step = Math.max(1, Math.floor(framesToDisplayInView / width));

                for (let i = 0; i < width; i++) {
                    let minVal = 1.0, maxVal = -1.0;
                    const frameIndexInViewStart = Math.floor(i * step);
                    
                    for (let j = 0; j < step; j++) {
                        const currentFrameInView = frameIndexInViewStart + j;
                        if (currentFrameInView >= framesToDisplayInView) break;
                        const actualFrameInBuffer = startFrameInFullBuffer + currentFrameInView;
                        if (actualFrameInBuffer < totalBufferFrames) {
                            let data = channelData[actualFrameInBuffer];
                            if (data < minVal) minVal = data;
                            if (data > maxVal) maxVal = data;
                        }
                    }
                    if (minVal > maxVal) { minVal = 0; maxVal = 0; }

                    let yMin = (0.5 * (-minVal + 1.0)) * height;
                    let yMax = (0.5 * (-maxVal + 1.0)) * height;
                    ctx.moveTo(i, yMin);
                    ctx.lineTo(i, yMax);
                }
                ctx.stroke();
            }
        }
        
        if (loopSelection.end > loopSelection.start) {
            ctx.fillStyle = styles.getPropertyValue('--loop-selection-bg').trim() || 'rgba(255, 255, 0, 0.3)';
            let selectionStartX = (loopSelection.start - loopPanOffsets[loopIndex]) / (1 / loopZoomLevels[loopIndex]) * width;
            let selectionEndX = (loopSelection.end - loopPanOffsets[loopIndex]) / (1 / loopZoomLevels[loopIndex]) * width;

            selectionStartX = Math.max(0, Math.min(width, selectionStartX));
            selectionEndX = Math.max(0, Math.min(width, selectionEndX));

            if (selectionEndX > selectionStartX) {
                ctx.fillRect(selectionStartX, 0, selectionEndX - selectionStartX, height);
            }
        }

        if (sampleSelection.end > sampleSelection.start) {
            ctx.fillStyle = styles.getPropertyValue('--sample-selection-bg').trim() || 'rgba(0, 150, 255, 0.3)';
            let selectionStartX = (sampleSelection.start - loopPanOffsets[loopIndex]) / (1 / loopZoomLevels[loopIndex]) * width;
            let selectionEndX = (sampleSelection.end - loopPanOffsets[loopIndex]) / (1 / loopZoomLevels[loopIndex]) * width;

            selectionStartX = Math.max(0, Math.min(width, selectionStartX));
            selectionEndX = Math.max(0, Math.min(width, selectionEndX));

            if (selectionEndX > selectionStartX) {
                ctx.fillRect(selectionStartX, 0, selectionEndX - selectionStartX, height);
            }
        }

        if (playheadPosition >= 0) {
            const playheadX = (playheadPosition - loopPanOffsets[loopIndex]) / (1 / loopZoomLevels[loopIndex]) * width;
            if (playheadX >= 0 && playheadX <= width) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(playheadX, 0);
                ctx.lineTo(playheadX, height);
                ctx.stroke();
            }
        }
    }

    function attachLoopCanvasEvents(loopIndex) {
        const canvas = loopCanvases[loopIndex];
        if (!canvas) return;
        let isDraggingOnCanvas = false;

        canvas.addEventListener('mousedown', (e) => {
            if (!mainRecorderAudioBuffer || e.button !== 0) return;

            if (isMidiMapping) return;

            isDraggingOnCanvas = true;
            
            const rect = canvas.getBoundingClientRect();
            const xOnCanvas = e.clientX - rect.left;
            const xInViewNormalized = Math.min(Math.max(xOnCanvas / rect.width, 0), 1);
            const zoom = loopZoomLevels[loopIndex];
            const panOffsetCurrentView = loopPanOffsets[loopIndex];
            const visiblePortion = 1 / zoom;
            let newSelectionPointNormalized = panOffsetCurrentView + (xInViewNormalized * visiblePortion);
            newSelectionPointNormalized = Math.min(Math.max(newSelectionPointNormalized, 0), 1);

            if (e.altKey) {
                isSelectingSampleFlags[loopIndex] = true;
                loopIsSelectingFlags[loopIndex] = false;
                sampleSelections[loopIndex] = { start: newSelectionPointNormalized, end: newSelectionPointNormalized };
            } else if (loopZoomLevels[loopIndex] > 1 && (e.metaKey || e.ctrlKey) ) {
                loopIsDraggingForPan[loopIndex] = true;
                loopPanLastMouseX[loopIndex] = e.clientX;
                canvas.style.cursor = 'grabbing';
                isDraggingOnCanvas = false;
            } else {
                loopIsSelectingFlags[loopIndex] = true;
                isSelectingSampleFlags[loopIndex] = false;
                loopSelections[loopIndex] = { start: newSelectionPointNormalized, end: newSelectionPointNormalized };
                canvas.style.cursor = 'crosshair';
            }
            drawLoopWaveformVisuals(loopIndex);
        });

        canvas.addEventListener('mousemove', (e) => {
             if (loopIsDraggingForPan[loopIndex]) {
                const deltaX = e.clientX - loopPanLastMouseX[loopIndex];
                loopPanLastMouseX[loopIndex] = e.clientX;
                handleLoopPan(loopIndex, loopPanOffsets[loopIndex] + (-deltaX / canvas.width) * (1 / loopZoomLevels[loopIndex]));
                return;
            }
            if (!isDraggingOnCanvas) return;

            const rect = canvas.getBoundingClientRect();
            const xOnCanvas = e.clientX - rect.left;
            const xInViewNormalized = Math.min(Math.max(xOnCanvas / rect.width, 0), 1);
            const zoom = loopZoomLevels[loopIndex];
            const panOffsetCurrentView = loopPanOffsets[loopIndex];
            const visiblePortion = 1 / zoom;
            let newEndPointNormalized = panOffsetCurrentView + (xInViewNormalized * visiblePortion);
            newEndPointNormalized = Math.min(Math.max(newEndPointNormalized, 0), 1);
            
            if (isSelectingSampleFlags[loopIndex]) {
                sampleSelections[loopIndex].end = newEndPointNormalized;
            } else if (loopIsSelectingFlags[loopIndex]) {
                loopSelections[loopIndex].end = newEndPointNormalized;
            }
            drawLoopWaveformVisuals(loopIndex);
        });

        const finalizeLoopSelectionOrPan = (event) => {
            if (loopIsDraggingForPan[loopIndex]) {
                loopIsDraggingForPan[loopIndex] = false;
                canvas.style.cursor = loopZoomLevels[loopIndex] > 1 ? 'grab' : 'crosshair';
            }
            if (isSelectingSampleFlags[loopIndex]) {
                if (sampleSelections[loopIndex].start > sampleSelections[loopIndex].end) {
                    [sampleSelections[loopIndex].start, sampleSelections[loopIndex].end] = [sampleSelections[loopIndex].end, sampleSelections[loopIndex].start];
                }
                isSelectingSampleFlags[loopIndex] = false;
            }
            if (loopIsSelectingFlags[loopIndex]) {
                 if (loopSelections[loopIndex].start > loopSelections[loopIndex].end) {
                    [loopSelections[loopIndex].start, loopSelections[loopIndex].end] = [loopSelections[loopIndex].end, loopSelections[loopIndex].start];
                }
                if (flexPitchCache[loopIndex]) flexPitchCache[loopIndex] = {};
                if (isLoopRealtimePlaying[loopIndex]) {
                    stopLoopRealtimePlayback(loopIndex);
                    startLoopRealtimePlayback(loopIndex);
                }
                loopIsSelectingFlags[loopIndex] = false;
            }
            isDraggingOnCanvas = false;
            drawLoopWaveformVisuals(loopIndex);
        };

        canvas.addEventListener('mouseup', finalizeLoopSelectionOrPan);
        canvas.addEventListener('mouseleave', (e) => {
            if (isDraggingOnCanvas) finalizeLoopSelectionOrPan(e);
            if (loopIsDraggingForPan[loopIndex]) finalizeLoopSelectionOrPan(e);
        });
        
        canvas.addEventListener('wheel', (e) => {
            if (!mainRecorderAudioBuffer) return;
            e.preventDefault();
            const zoomFactor = 1.2;
            const rect = canvas.getBoundingClientRect();
            const mouseXInCanvasViewNormalized = Math.min(Math.max((e.clientX - rect.left) / rect.width, 0), 1);
            
            if (e.deltaY < 0) {
                handleLoopZoom(loopIndex, loopZoomLevels[loopIndex] * zoomFactor, mouseXInCanvasViewNormalized);
            } else {
                handleLoopZoom(loopIndex, loopZoomLevels[loopIndex] / zoomFactor, mouseXInCanvasViewNormalized);
            }
        });
        canvas.style.cursor = 'crosshair';
    }

    function handleLoopZoom(loopIndex, newZoom, zoomOriginInViewNormalized = 0.5) {
        if (!mainRecorderAudioBuffer) return;
        const oldZoom = loopZoomLevels[loopIndex];
        newZoom = Math.max(1, Math.min(newZoom, 100));
        loopZoomLevels[loopIndex] = newZoom;

        const currentPanOffset = loopPanOffsets[loopIndex];
        const visiblePortionOld = 1 / oldZoom;
        const visiblePortionNew = 1 / newZoom;

        const focalPointInBuffer = currentPanOffset + (zoomOriginInViewNormalized * visiblePortionOld);
        
        let newPanOffset = focalPointInBuffer - (zoomOriginInViewNormalized * visiblePortionNew);
        
        const maxPanOffset = 1 - visiblePortionNew;
        newPanOffset = Math.max(0, Math.min(newPanOffset, maxPanOffset));
        
        loopPanOffsets[loopIndex] = newPanOffset;
        loopCanvases[loopIndex].style.cursor = newZoom > 1 ? 'grab' : 'crosshair';
        drawLoopWaveformVisuals(loopIndex);
    }

    function handleLoopPan(loopIndex, newPanAttempt) {
        if (!mainRecorderAudioBuffer || loopZoomLevels[loopIndex] <= 1) return;
        const zoom = loopZoomLevels[loopIndex];
        const visiblePortion = 1 / zoom;
        const maxPan = 1 - visiblePortion;
        
        newPanAttempt = Math.max(0, Math.min(newPanAttempt, maxPan));
        loopPanOffsets[loopIndex] = newPanAttempt;
        drawLoopWaveformVisuals(loopIndex);
    }

    loopZoomInBtns.forEach(btn => btn.addEventListener('click', () => {
        const loopIdx = parseInt(btn.dataset.loopindex);
        handleLoopZoom(loopIdx, loopZoomLevels[loopIdx] * 1.5, 0.5);
    }));
    loopZoomOutBtns.forEach(btn => btn.addEventListener('click', () => {
        const loopIdx = parseInt(btn.dataset.loopindex);
        handleLoopZoom(loopIdx, loopZoomLevels[loopIdx] / 1.5, 0.5);
    }));

    function attachLoopCanvasEventsAll() {
        for (let i = 0; i < loopCanvases.length; i++) {
            if (loopCanvases[i]) attachLoopCanvasEvents(i);
        }
    }
    
    function updateLoopAndGranulatorWithNewBuffer(audioBuf) {
        mainRecorderAudioBuffer = audioBuf;
        mainRecorderAudioBufferId++;
        flexPitchCache = [{}, {}, {}];
        
        for (let i = 0; i < loopSelections.length; i++) {
            loopZoomLevels[i] = 1;
            loopPanOffsets[i] = 0;
            sampleSelections[i] = { start: 0, end: 0 };
            if (loopCanvases[i]) {
                loopCanvases[i].style.cursor = 'crosshair';
                drawLoopWaveformVisuals(i);
            }
        }
        loopPlayPauseBtns.forEach(btn => { if(btn) btn.disabled = !mainRecorderAudioBuffer; });
        if (granulatorPlayToggleBtn) granulatorPlayToggleBtn.disabled = !mainRecorderAudioBuffer;
        if (spectralSynthPowerSwitch) spectralSynthPowerSwitch.disabled = !mainRecorderAudioBuffer;
    }

    function extractAudioBufferSegment(originalBuffer, startNormalized, endNormalized, ctx) {
        if (!originalBuffer || originalBuffer.duration === 0) return null;
        let startTimeSeconds = startNormalized * originalBuffer.duration;
        let endTimeSeconds = endNormalized * originalBuffer.duration;
        let durationSeconds = endTimeSeconds - startTimeSeconds;

        if (durationSeconds <= 0.001) return null;

        const startFrame = Math.floor(startTimeSeconds * originalBuffer.sampleRate);
        const frameCount = Math.max(1, Math.floor(durationSeconds * originalBuffer.sampleRate));
        const endFrame = startFrame + frameCount;

        if (startFrame < 0 || endFrame > originalBuffer.length || frameCount <= 0) {
             return null;
        }

        try {
            const segmentBuffer = ctx.createBuffer(originalBuffer.numberOfChannels, frameCount, originalBuffer.sampleRate);
            for (let i = 0; i < originalBuffer.numberOfChannels; i++) {
                const sourceChannelData = originalBuffer.getChannelData(i);
                const segmentChannelData = segmentBuffer.getChannelData(i);
                const subArray = sourceChannelData.subarray(startFrame, Math.min(endFrame, sourceChannelData.length));
                segmentChannelData.set(subArray);
            }
            return segmentBuffer;
        } catch (err) {
            console.error("Error extrayendo segmento de audio:", err);
            return null;
        }
    }
    
    function playLoopSegmentRealtimePlayback(loopIndex, scheduledTime) {
        if (!mainRecorderAudioBuffer || mainRecorderAudioBuffer.duration === 0 || !isLoopRealtimePlaying[loopIndex]) {
            stopLoopRealtimePlayback(loopIndex);
            return;
        }

        const selection = loopSelections[loopIndex];
        const isReversed = loopReverseSwitches[loopIndex] ? loopReverseSwitches[loopIndex].checked : false;
        const currentSpeed = loopSpeedControls[loopIndex] ? parseFloat(loopSpeedControls[loopIndex].value) : 1;
        const useFlexPitch = loopFlexPitchSwitches[loopIndex] ? loopFlexPitchSwitches[loopIndex].checked : false;

        let originalSegmentForPlayback = extractAudioBufferSegment(mainRecorderAudioBuffer, selection.start, selection.end, audioContext);
        if (!originalSegmentForPlayback || originalSegmentForPlayback.duration <= 0.001) {
            stopLoopRealtimePlayback(loopIndex);
            return;
        }

        if (isReversed) {
            originalSegmentForPlayback = createReversedAudioBuffer(originalSegmentForPlayback);
            if (!originalSegmentForPlayback) {
                stopLoopRealtimePlayback(loopIndex);
                return;
            }
        }

        let bufferToPlay = originalSegmentForPlayback;
        let finalPlaybackRate = currentSpeed;
        let segmentDuration = bufferToPlay.duration;

        if (useFlexPitch && currentSpeed !== 1.0 && typeof SoundTouch !== 'undefined' && typeof SimpleFilter !== 'undefined') {
            const cacheKey = `${mainRecorderAudioBufferId}_s${selection.start.toFixed(4)}_e${selection.end.toFixed(4)}_r${isReversed}_v${currentSpeed.toString()}`;
            if (flexPitchCache[loopIndex] && flexPitchCache[loopIndex][cacheKey]) {
                bufferToPlay = flexPitchCache[loopIndex][cacheKey];
            } else {
                let newProcessedBuffer = processAudioWithSoundTouch(originalSegmentForPlayback, currentSpeed);
                if (newProcessedBuffer && newProcessedBuffer.duration > 0.001) {
                    if (!flexPitchCache[loopIndex]) flexPitchCache[loopIndex] = {};
                    flexPitchCache[loopIndex][cacheKey] = newProcessedBuffer;
                    bufferToPlay = newProcessedBuffer;
                }
            }
            finalPlaybackRate = 1.0;
            segmentDuration = bufferToPlay.duration;
        }
        
        const sourceNode = audioContext.createBufferSource();
        sourceNode.buffer = bufferToPlay;
        sourceNode.playbackRate.value = finalPlaybackRate;
        if (loopVolumeGains[loopIndex]) sourceNode.connect(loopVolumeGains[loopIndex]);
        
        const startTime = scheduledTime || audioContext.currentTime;
        sourceNode.start(startTime);
        realtimeLoopSourceNodes[loopIndex] = sourceNode;

        const loopDurationSeconds = segmentDuration / finalPlaybackRate;
        const nextLoopTime = startTime + loopDurationSeconds;

        if (isLoopRealtimePlaying[loopIndex]) {
            loopNextStartTimeoutId[loopIndex] = setTimeout(() => {
                if (isLoopRealtimePlaying[loopIndex]) {
                    playLoopSegmentRealtimePlayback(loopIndex, nextLoopTime);
                }
            }, (nextLoopTime - audioContext.currentTime - 0.05) * 1000); // Schedule check slightly before it's due
        }
    }
    
    function startLoopRealtimePlayback(loopIndex) {
        if (isLoopRealtimePlaying[loopIndex] || !mainRecorderAudioBuffer) return;
        
        if (audioContext.state === 'suspended') {
            audioContext.resume().then(() => actuallyStartLoopPlayback(loopIndex));
        } else {
            actuallyStartLoopPlayback(loopIndex);
        }
    }

    function actuallyStartLoopPlayback(loopIndex) {
        isLoopRealtimePlaying[loopIndex] = true;
        if(loopPlayPauseBtns[loopIndex]) loopPlayPauseBtns[loopIndex].textContent = "Pause";
        
        loopPlaybackStartTimes[loopIndex] = audioContext.currentTime;
        playLoopSegmentRealtimePlayback(loopIndex, loopPlaybackStartTimes[loopIndex]);
        
        if (!animationFrameId_visualizer && isAnimationEnabled) { requestAnimationFrame(animateVisualizer); }

        const animationLoop = () => {
            if (!isLoopRealtimePlaying[loopIndex]) {
                drawLoopWaveformVisuals(loopIndex, -1);
                return;
            }
            
            const selection = loopSelections[loopIndex];
            const speed = parseFloat(loopSpeedControls[loopIndex].value);
            const isReversed = loopReverseSwitches[loopIndex].checked;
            
            let loopDuration = (selection.end - selection.start) * mainRecorderAudioBuffer.duration;
            if (loopDuration <= 0) loopDuration = 1;

            const elapsedTime = audioContext.currentTime - loopPlaybackStartTimes[loopIndex];
            const scaledElapsedTime = elapsedTime * speed;
            const currentPosInLoop = (scaledElapsedTime % loopDuration) / loopDuration;
            
            let finalProgress = currentPosInLoop;
            if(isReversed) {
                finalProgress = 1.0 - currentPosInLoop;
            }

            const playheadPositionInBuffer = selection.start + finalProgress * (selection.end - selection.start);
            
            drawLoopWaveformVisuals(loopIndex, playheadPositionInBuffer);
            loopPlaybackAnimationIds[loopIndex] = requestAnimationFrame(animationLoop);
        };
        if(loopPlaybackAnimationIds[loopIndex]) cancelAnimationFrame(loopPlaybackAnimationIds[loopIndex]);
        animationLoop();
    }

    function stopLoopRealtimePlayback(loopIndex) {
        isLoopRealtimePlaying[loopIndex] = false;

        if (loopNextStartTimeoutId[loopIndex]) {
            clearTimeout(loopNextStartTimeoutId[loopIndex]);
            loopNextStartTimeoutId[loopIndex] = null;
        }
        if (realtimeLoopSourceNodes[loopIndex]) {
            try {
                realtimeLoopSourceNodes[loopIndex].stop();
            } catch (e) {}
            realtimeLoopSourceNodes[loopIndex] = null;
        }

        if (loopPlaybackAnimationIds[loopIndex]) {
            cancelAnimationFrame(loopPlaybackAnimationIds[loopIndex]);
            loopPlaybackAnimationIds[loopIndex] = null;
        }
        
        drawLoopWaveformVisuals(loopIndex, -1);

        if(loopPlayPauseBtns[loopIndex]) loopPlayPauseBtns[loopIndex].textContent = "Play";
    }

    loopSpeedControls.forEach((control, i) => {
        if(!control) return;
        control.addEventListener('input', function() {
            if (isLoopRealtimePlaying[i]) {
                stopLoopRealtimePlayback(i);
                startLoopRealtimePlayback(i);
            }
        });
    });
    loopReverseSwitches.forEach((sw, i) => {
        if(!sw) return;
        sw.addEventListener('change', function() {
            if (flexPitchCache[i]) flexPitchCache[i] = {};
            if (isLoopRealtimePlaying[i]) {
                stopLoopRealtimePlayback(i);
                startLoopRealtimePlayback(i);
            }
        });
    });
    loopFlexPitchSwitches.forEach((sw, i) => {
        if(!sw) return;
        sw.addEventListener('change', function() {
            if (isLoopRealtimePlaying[i]) {
                stopLoopRealtimePlayback(i);
                startLoopRealtimePlayback(i);
            }
        });
    });
    loopPlayPauseBtns.forEach((btn, i) => {
        if(!btn) return;
        btn.disabled = !mainRecorderAudioBuffer;
        btn.addEventListener('click', () => {
            if (!mainRecorderAudioBuffer) return;
            if (!isLoopRealtimePlaying[i]) {
                startLoopRealtimePlayback(i);
            } else {
                stopLoopRealtimePlayback(i);
            }
        });
    });
    loopVolumeFaders.forEach((volCtrl, i) => {
        if(!volCtrl) return;
        volCtrl.addEventListener('input', function() {
            if (loopVolumeGains[i] && audioContext) {
                loopVolumeGains[i].gain.setTargetAtTime(parseFloat(this.value), audioContext.currentTime, 0.01);
            }
        });
    });
    
    function processAudioWithSoundTouch(audioBufferInput, rateFactor) {
        if (!audioBufferInput || audioBufferInput.duration === 0) return audioBufferInput;
        if (typeof SoundTouch === 'undefined' || typeof SimpleFilter === 'undefined') {
            console.warn("SoundTouch no está disponible. No se puede aplicar Flex Pitch.");
            return audioBufferInput;
        }

        const soundTouchInstance = new SoundTouch();
        soundTouchInstance.sampleRate = audioBufferInput.sampleRate;
        soundTouchInstance.tempo = rateFactor;

        const numChannels = audioBufferInput.numberOfChannels;
        const inputFrames = audioBufferInput.length;
        
        let interleavedInputSamples;
        if (numChannels === 1) {
            interleavedInputSamples = audioBufferInput.getChannelData(0);
        } else {
            const channelDataArray = [];
            for (let ch = 0; ch < numChannels; ch++) {
                channelDataArray.push(audioBufferInput.getChannelData(ch));
            }
            interleavedInputSamples = new Float32Array(inputFrames * numChannels);
            for (let f = 0; f < inputFrames; f++) {
                for (let ch = 0; ch < numChannels; ch++) {
                    interleavedInputSamples[f * numChannels + ch] = channelDataArray[ch][f];
                }
            }
        }

        const soundTouchSource = {
            extract: (target, numFramesToExtract, positionFrames) => {
                const requestedSamples = numFramesToExtract * numChannels;
                const startSampleInBuffer = positionFrames * numChannels;
                let framesActuallyExtracted = 0;

                if (startSampleInBuffer < interleavedInputSamples.length) {
                    const availableSamplesFromPosition = interleavedInputSamples.length - startSampleInBuffer;
                    const samplesToCopy = Math.min(requestedSamples, availableSamplesFromPosition);
                    
                    for (let i = 0; i < samplesToCopy; i++) {
                        target[i] = interleavedInputSamples[startSampleInBuffer + i];
                    }
                    framesActuallyExtracted = Math.floor(samplesToCopy / numChannels);
                    for (let i = samplesToCopy; i < requestedSamples; i++) {
                        target[i] = 0;
                    }
                } else {
                    for (let i = 0; i < requestedSamples; i++) {
                        target[i] = 0;
                    }
                    framesActuallyExtracted = 0;
                }
                return framesActuallyExtracted;
            }
        };

        let soundTouchFilter;
        try {
            soundTouchFilter = new SimpleFilter(soundTouchSource, soundTouchInstance);
        } catch (e) {
            console.error("Error al crear SimpleFilter de SoundTouch:", e);
            return audioBufferInput;
        }

        const processedSamplesContainer = [];
        const internalProcessingBufferSizeFrames = 4096;
        const tempProcessingBufferSamples = new Float32Array(internalProcessingBufferSizeFrames * numChannels);
        let framesExtractedCount, totalFramesProcessedBySoundTouch = 0;

        do {
            try {
                framesExtractedCount = soundTouchFilter.extract(tempProcessingBufferSamples, internalProcessingBufferSizeFrames);
            } catch (e) {
                console.error("Error durante SoundTouch extract:", e);
                framesExtractedCount = 0;
            }
            if (framesExtractedCount > 0) {
                totalFramesProcessedBySoundTouch += framesExtractedCount;
                processedSamplesContainer.push(tempProcessingBufferSamples.slice(0, framesExtractedCount * numChannels));
            }
        } while (framesExtractedCount > 0);

        if (processedSamplesContainer.length === 0 || totalFramesProcessedBySoundTouch === 0) {
            return null;
        }

        const totalProcessedSamples = processedSamplesContainer.reduce((sum, chunk) => sum + chunk.length, 0);
        const finalOutputSamplesInterleaved = new Float32Array(totalProcessedSamples);
        let currentOffset = 0;
        processedSamplesContainer.forEach(chunk => {
            finalOutputSamplesInterleaved.set(chunk, currentOffset);
            currentOffset += chunk.length;
        });
        
        const newTotalFrames = Math.round(totalProcessedSamples / numChannels);
        if (newTotalFrames <= 0) return null;

        const newProcessedAudioBuffer = audioContext.createBuffer(numChannels, newTotalFrames, audioBufferInput.sampleRate);
        for (let ch = 0; ch < numChannels; ch++) {
            const channelOutputData = newProcessedAudioBuffer.getChannelData(ch);
            for (let f = 0; f < newTotalFrames; f++) {
                const sampleIndexInInterleaved = f * numChannels + ch;
                if (sampleIndexInInterleaved < finalOutputSamplesInterleaved.length) {
                    channelOutputData[f] = finalOutputSamplesInterleaved[sampleIndexInInterleaved];
                } else {
                    channelOutputData[f] = 0;
                }
            }
        }
        return newProcessedAudioBuffer;
    }

    function createReversedAudioBuffer(inputAudioBuffer) {
        if (!inputAudioBuffer || !audioContext) return null;
        const numChannels = inputAudioBuffer.numberOfChannels;
        const frameLength = inputAudioBuffer.length;
        const sampleRate = inputAudioBuffer.sampleRate;

        try {
            const reversedBuffer = audioContext.createBuffer(numChannels, frameLength, sampleRate);
            for (let channel = 0; channel < numChannels; channel++) {
                const originalChannelData = inputAudioBuffer.getChannelData(channel);
                const reversedChannelData = reversedBuffer.getChannelData(channel);
                for (let i = 0; i < frameLength; i++) {
                    reversedChannelData[i] = originalChannelData[frameLength - 1 - i];
                }
            }
            return reversedBuffer;
        } catch (err) {
            console.error("Error creando buffer revertido:", err);
            return null;
        }
    }
    
    function getCurrentAppState() {
        if (!eqBandInstances || eqBandInstances.length === 0) {
            return {};
        }
        return {
            selectedSource: currentAudioSourceType,
            selectedMicId: micSelect ? micSelect.value : (micSelect?.options.length > 0 ? micSelect.options[0].value : ""),
            micVolumeLevel: micVolumeFader?.value ?? "1",
            isMicCurrentlyMuted: isMicMuted,
            selectedMicChannel: channelSelect?.value ?? "0",
            
            mainPlayerVolume: volumeFader?.value ?? "1",
            mainPlayerTimelineValue: timeline?.value ?? "0",
            isMainPlayerLooping: isMainPlayerLoopEnabled,
            isMainPlayerPlaying: isMainPlayerPlaying,
            mainPlayerFileOffset: mainPlayerStartOffset,
            
            samplerGrainPoints: JSON.parse(JSON.stringify(samplerGrainPoints)),
            granulatorOverlap: overlapDialEl?.getAttribute('data-value') ?? "0.5",
            granulatorCurrentGrainLength: grainLengthDialEl?.getAttribute('data-value') ?? "0.1",
            granulatorFilterCutoff: granulatorFilterFreqEl?.getAttribute('data-value') ?? "10000",
            granulatorPitchBend: pitchBendDialEl?.getAttribute('data-value') ?? "0",
            currentGranulatorFilterType: granulatorFilter?.type ?? "lowpass",
            granulatorOutputVolume: granulatorVolumeFader?.value ?? "1",
            isGranulatorCurrentlyRunning: isGranulatorRunning,

            isSpectralSynthOn: spectralSynthPowerSwitch?.checked ?? false,
            spectralSynthVolume: spectralSynthVolumeFader?.value ?? "1",
            isDrawModeActive: isDrawModeActive,
            drawnPaths: JSON.parse(JSON.stringify(drawnPaths)),

            granulatorLfoRate: granulatorLfoSpeedFader?.value ?? "1",
            granulatorLfoFilterDepth: granulatorLfoDepthFader?.value ?? "500",
            isGranulatorLfoOn: lfoPowerSwitch?.checked ?? false,
            
            isSidechainFromSourceOn: sourceSidechainSendSwitches.length > 0 ? sourceSidechainSendSwitches[0].checked : false,
            isSidechainEnvelopeActive: sidechainEnvelopePowerSwitch?.checked ?? false,
            sidechainThreshold: sidechainThresholdDialEl?.getAttribute('data-value') ?? "-24",
            sidechainAttack: sidechainAttackDialEl?.getAttribute('data-value') ?? "0.01",
            sidechainRelease: sidechainReleaseDialEl?.getAttribute('data-value') ?? "0.1",
            sidechainAmount: sidechainAmountDialEl?.getAttribute('data-value') ?? "1000",
            
            loopSidechainSendStates: loopSidechainSendSwitches.map(s => s?.checked ?? false),
            loopRegionSelections: loopSelections.map(sel => ({...sel})),
            sampleRegionSelections: sampleSelections.map(sel => ({...sel})),
            loopSpeedSettings: loopSpeedControls.map(c => c?.value ?? "1"),
            loopFlexPitchStates: loopFlexPitchSwitches.map(c => c?.checked ?? false),
            loopReverseStates: loopReverseSwitches.map(c => c?.checked ?? false),
            loopVolumeLevels: loopVolumeFaders.map(c => c?.value ?? "1"),
            loopPlaybackStates: isLoopRealtimePlaying.map(s => s),
            loopZoomLevels: loopZoomLevels.map(z => z),
            loopPanOffsets: loopPanOffsets.map(p => p),
            
            masterPreReverbVolume: masterVolumeFaderEl?.value ?? "1",
            masterTimelineValue: masterTimelineFader?.value ?? "0",
            isMasterRecordingPlaying: isMasterRecordingPlaying,
            masterRecordingOffset: masterRecordingStartOffset,
            
            reverbSize: reverbSizeDialEl?.getAttribute('data-value') ?? "3",
            reverbDryWet: reverbDryWetDialEl?.getAttribute('data-value') ?? "0.5",
            eqBandSettings: eqBandInstances.map((b) => ({
                x: b.x, 
                y: b.y,
                q: b.q
            })),
            patchBayMappings: JSON.parse(JSON.stringify(patchMappings)),
            midiMappings: JSON.parse(JSON.stringify(midiMap)),
            automationMemories: JSON.parse(JSON.stringify(automationMemories))
        };
    }
    
    function applySavedAppState(savedState){
        if(!savedState) return;

        if (savedState.eqBandSettings && eqBandInstances) {
            savedState.eqBandSettings.forEach((setting, i) => {
                if (eqBandInstances[i]) {
                    const band = eqBandInstances[i];
                    band.x = setting.x;
                    band.y = setting.y;
                    band.q = setting.q;
                    
                    const centerX = spectrumCanvas.width / 2;
                    const centerY = spectrumCanvas.height / 2;
                    const neutralRadius = Math.min(spectrumCanvas.width, spectrumCanvas.height) / 3.5;
                    band.updateFilter(centerX, centerY, neutralRadius);
                }
            });
        }

        if(savedState.drawnPaths) { drawnPaths = JSON.parse(JSON.stringify(savedState.drawnPaths)); }
        if(savedState.automationMemories) { 
            automationMemories = JSON.parse(JSON.stringify(savedState.automationMemories));
            updateAutomationBtnUI();
        }
    }

    if(stateButtons) stateButtons.forEach((btn,i)=>{
        if(!btn)return;
        btn.addEventListener("mousedown",(e)=>{ if(e.button===0) statePressTimes[i]=Date.now(); });
        btn.addEventListener("mouseup",(e)=>{
            if(e.button===0 && statePressTimes[i]!==0){
                const pressDuration = Date.now() - statePressTimes[i];
                if(pressDuration >= 700){
                    savedStates[i] = getCurrentAppState();
                    btn.style.backgroundColor="var(--highlight-color)";
                    setTimeout(()=>{btn.style.backgroundColor="";},600);
                } else {
                    if(savedStates[i]){
                        applySavedAppState(savedStates[i]);
                        btn.style.backgroundColor="green";
                        setTimeout(()=>{btn.style.backgroundColor="";},600);
                    } else {
                        btn.style.backgroundColor="lightcoral";
                        setTimeout(()=>{btn.style.backgroundColor="";},600);
                    }
                }
                statePressTimes[i]=0;
            }
        });
        btn.addEventListener("mouseleave",()=>{ statePressTimes[i]=0; });
        btn.addEventListener("touchstart",(e)=>{ statePressTimes[i]=Date.now(); e.preventDefault(); },{passive:false});
        btn.addEventListener("touchend",(e)=>{
             if(statePressTimes[i]!==0){
                const pressDuration = Date.now() - statePressTimes[i];
                if(pressDuration >= 700){
                    savedStates[i] = getCurrentAppState();
                    btn.style.backgroundColor="var(--highlight-color)";
                    setTimeout(()=>{btn.style.backgroundColor="";},600);
                } else {
                    if(savedStates[i]){
                        applySavedAppState(savedStates[i]);
                        btn.style.backgroundColor="green";
                        setTimeout(()=>{btn.style.backgroundColor="";},600);
                    } else {
                        btn.style.backgroundColor="lightcoral";
                        setTimeout(()=>{btn.style.backgroundColor="";},600);
                    }
                }
                statePressTimes[i]=0;
            }
        });
        btn.addEventListener("touchcancel",()=>{ statePressTimes[i]=0; });
    });
    
    if(recordMasterBtnEl) recordMasterBtnEl.addEventListener('click', function(){
        if(!masterOutputRecorder) { return; }
        if(audioContext.state === 'suspended') audioContext.resume();

        if(masterOutputRecorder.state === 'inactive'){
            masterRecordedChunksForMaster = [];
            try {
                masterOutputRecorder.start();
                this.textContent="Detener Grab. Master";
                this.style.backgroundColor="red";
                if(playMasterBufferBtnEl) playMasterBufferBtnEl.disabled = true;
                if(pauseMasterBufferBtnEl) pauseMasterBufferBtnEl.disabled = true;
                if(downloadMasterBtnEl) downloadMasterBtnEl.disabled = true;
            } catch (recErr) {
                console.error("Error al iniciar grabación del master:", recErr);
            }
        } else if (masterOutputRecorder.state === 'recording'){
            masterOutputRecorder.stop();
            this.textContent="Grabar Master";
            this.style.backgroundColor="";
        }
    });
    
    function setupMasterRecorder() {
        if(!audioContext || !finalOutputGain) { return; }
        if(audioContext.createMediaStreamDestination){
            const mediaStreamDestNode = audioContext.createMediaStreamDestination();
            window.masterAudioStreamDestinationNode = mediaStreamDestNode;
            try {
                finalOutputGain.connect(mediaStreamDestNode);
            } catch (e) {
                console.error("Error conectando finalOutputGain a masterAudioStreamDestinationNode en setupMasterRecorder:", e);
                return;
            }

            masterOutputRecorder = new MediaRecorder(mediaStreamDestNode.stream);
            masterRecordedChunksForMaster = [];
            masterOutputRecorder.ondataavailable = (event) => {
                if (event.data && event.data.size > 0) masterRecordedChunksForMaster.push(event.data);
            };
            masterOutputRecorder.onstop = async () => {
              if (masterRecordedChunksForMaster.length === 0) {
                if(playMasterBufferBtnEl) playMasterBufferBtnEl.disabled = true;
                if(downloadMasterBtnEl) downloadMasterBtnEl.disabled = true;
                return;
              }
              const blob = new Blob(masterRecordedChunksForMaster, {type: 'audio/webm;codecs=opus'});
              masterRecordedChunksForMaster = [];
              
              const reader = new FileReader();
              reader.onload = async (fileReaderEvent) => {
                try {
                    if(fileReaderEvent.target.result instanceof ArrayBuffer){
                        masterRecordedAudioBuffer = await audioContext.decodeAudioData(fileReaderEvent.target.result);
                        masterRecordingStartOffset = 0;
                        if(masterDurationDisplay) masterDurationDisplay.textContent = formatTime(masterRecordedAudioBuffer.duration);
                        if(masterTimelineFader) {
                            localUpdateRangeParamProgrammatic(masterTimelineFader, 0);
                            masterTimelineFader.max = masterRecordedAudioBuffer.duration;
                        }
                        if(playMasterBufferBtnEl) playMasterBufferBtnEl.disabled = false;
                        if(pauseMasterBufferBtnEl) pauseMasterBufferBtnEl.disabled = true;
                        if(downloadMasterBtnEl) downloadMasterBtnEl.disabled = false;
                        updateMasterRecordingTimelineDisplay(true);
                    }
                } catch(decodeErr) { console.error("Error al decodificar audio del master grabado:", decodeErr); }
              };
              reader.onerror = (err) => { console.error("Error de FileReader en grabación del master:",err); };
              reader.readAsArrayBuffer(blob);
            };
        } else {
            console.warn("MediaStreamDestination API no soportada. Grabación de Master deshabilitada.");
            if(recordMasterBtnEl) recordMasterBtnEl.disabled = true;
            if(downloadMasterBtnEl) downloadMasterBtnEl.disabled = true;
        }
    }

    function playMasterRecordedAudio(){
        if(!masterRecordedAudioBuffer) return;
        if(audioContext.state === 'suspended') audioContext.resume();

        if(masterBufferSourceNode) {
            try { masterBufferSourceNode.onended = null; masterBufferSourceNode.stop(); masterBufferSourceNode.disconnect(); } catch(e){}
        }
        masterBufferSourceNode = audioContext.createBufferSource();
        masterBufferSourceNode.buffer = masterRecordedAudioBuffer;
        masterBufferSourceNode.connect(audioContext.destination);

        const validOffset = Math.max(0, Math.min(masterRecordingStartOffset, masterRecordedAudioBuffer.duration));
        masterBufferSourceNode.start(0, validOffset);
        masterRecordingStartTime = audioContext.currentTime - validOffset;
        isMasterRecordingPlaying = true;

        if(playMasterBufferBtnEl) playMasterBufferBtnEl.textContent="Pause Grab.";
        if(pauseMasterBufferBtnEl) pauseMasterBufferBtnEl.disabled = false;
        updateMasterRecordingTimelineDisplay();

        masterBufferSourceNode.onended = () => {
            if (masterBufferSourceNode && isMasterRecordingPlaying && !masterBufferSourceNode.loop) {
                const expectedEndTime = masterRecordingStartTime + masterRecordedAudioBuffer.duration;
                if (audioContext.currentTime >= expectedEndTime - 0.1 || masterRecordingStartOffset >= masterRecordedAudioBuffer.duration) {
                    isMasterRecordingPlaying = false;
                    masterRecordingStartOffset = 0;
                    if(masterTimelineFader) localUpdateRangeParamProgrammatic(masterTimelineFader, masterRecordingStartOffset);
                    if(masterCurrentTimeDisplay) masterCurrentTimeDisplay.textContent = formatTime(masterRecordingStartOffset);
                    if(playMasterBufferBtnEl) playMasterBufferBtnEl.textContent="Play Grab.";
                    if(pauseMasterBufferBtnEl) pauseMasterBufferBtnEl.disabled = true;
                    updateMasterRecordingTimelineDisplay(true);
                }
            }
            if(masterBufferSourceNode && masterBufferSourceNode.onended === arguments.callee) {
                masterBufferSourceNode = null;
            }
        };
    }

    function pauseMasterRecordedAudio(){
        if(isMasterRecordingPlaying && masterBufferSourceNode){
            try { masterBufferSourceNode.stop(); } catch(e){}
            masterRecordingStartOffset = (audioContext.currentTime - masterRecordingStartTime);
            masterRecordingStartOffset = Math.max(0, Math.min(masterRecordingStartOffset, masterRecordedAudioBuffer.duration));
            if(masterTimelineFader) localUpdateRangeParamProgrammatic(masterTimelineFader, masterRecordingStartOffset);
            
            isMasterRecordingPlaying = false;
            if(playMasterBufferBtnEl) playMasterBufferBtnEl.textContent="Play Grab.";
            if(pauseMasterBufferBtnEl) pauseMasterBufferBtnEl.disabled = true;
            if(animationRequestId_MasterTimeline) cancelAnimationFrame(animationRequestId_MasterTimeline);
            animationRequestId_MasterTimeline = null;
            updateMasterRecordingTimelineDisplay(true);
        }
    }
    
    if(playMasterBufferBtnEl){
        playMasterBufferBtnEl.disabled = true;
        playMasterBufferBtnEl.addEventListener('click', () => {
            if(!masterRecordedAudioBuffer) return;
            if(!isMasterRecordingPlaying) playMasterRecordedAudio();
            else pauseMasterRecordedAudio();
        });
    }
    if(pauseMasterBufferBtnEl){
        pauseMasterBufferBtnEl.disabled = true;
        pauseMasterBufferBtnEl.addEventListener('click', () => {
            if(isMasterRecordingPlaying) pauseMasterRecordedAudio();
        });
    }

    if(masterTimelineFader) masterTimelineFader.addEventListener('input', () => {
        if(masterRecordedAudioBuffer){
            const newTime = parseFloat(masterTimelineFader.value);
            if(!isMasterRecordingPlaying) {
                 masterRecordingStartOffset = newTime;
                 if(masterCurrentTimeDisplay) masterCurrentTimeDisplay.textContent = formatTime(masterRecordingStartOffset);
            }
        }
    });
    if(masterTimelineFader) masterTimelineFader.addEventListener('change', () => {
        if(masterRecordedAudioBuffer){
            const newTime = parseFloat(masterTimelineFader.value);
            masterRecordingStartOffset = newTime;
            if(masterCurrentTimeDisplay) masterCurrentTimeDisplay.textContent = formatTime(masterRecordingStartOffset);
            if(isMasterRecordingPlaying){
                if(masterBufferSourceNode) try { masterBufferSourceNode.stop(); } catch(e){}
                playMasterRecordedAudio();
            }
        }
    });

    let animationRequestId_MasterTimeline = null;
    function updateMasterRecordingTimelineDisplay(isPausedOrForceUpdate = false){
        function step(){
            if(isMasterRecordingPlaying && masterRecordedAudioBuffer && audioContext){
                let currentTimePoint = (audioContext.currentTime - masterRecordingStartTime);
                if(currentTimePoint < 0) currentTimePoint = 0;
                if(currentTimePoint >= masterRecordedAudioBuffer.duration) currentTimePoint = masterRecordedAudioBuffer.duration;
                
                if(masterTimelineFader && parseFloat(masterTimelineFader.value).toFixed(1) !== parseFloat(currentTimePoint).toFixed(1)) {
                    masterTimelineFader.value = currentTimePoint;
                    const numInput = document.getElementById('masterTimelineValueInput');
                    if(numInput) numInput.value = parseFloat(currentTimePoint).toFixed(1);
                }
                if(masterCurrentTimeDisplay) masterCurrentTimeDisplay.textContent = formatTime(currentTimePoint);
            }
            if(isMasterRecordingPlaying) animationRequestId_MasterTimeline = requestAnimationFrame(step);
            else {
                if(animationRequestId_MasterTimeline) cancelAnimationFrame(animationRequestId_MasterTimeline);
                animationRequestId_MasterTimeline = null;
            }
        }
        if(isPausedOrForceUpdate && !isMasterRecordingPlaying) {
            if(animationRequestId_MasterTimeline) cancelAnimationFrame(animationRequestId_MasterTimeline);
            animationRequestId_MasterTimeline = null;
            let finalTime = masterRecordingStartOffset;
            if (masterRecordedAudioBuffer && finalTime >= masterRecordedAudioBuffer.duration) finalTime = masterRecordedAudioBuffer.duration;
            finalTime = masterRecordedAudioBuffer ? Math.max(0, Math.min(finalTime, masterRecordedAudioBuffer.duration)) : 0;
            if(masterTimelineFader) {
                masterTimelineFader.value = finalTime;
                const numInput = document.getElementById('masterTimelineValueInput');
                if(numInput) numInput.value = parseFloat(finalTime).toFixed(1);
            }
            if(masterCurrentTimeDisplay) masterCurrentTimeDisplay.textContent = formatTime(finalTime);
        } else if (isMasterRecordingPlaying) {
            if(animationRequestId_MasterTimeline) cancelAnimationFrame(animationRequestId_MasterTimeline);
            step();
        }
    }

    function audioBufferToWavBlob(audioBuff, opt = {}) {
        const numChannels = audioBuff.numberOfChannels;
        const sampleRate = audioBuff.sampleRate;
        const format = opt.float32 ? 3 : 1;
        const bitDepth = format === 3 ? 32 : 16;

        let channels = [];
        for (let i = 0; i < numChannels; i++) channels.push(audioBuff.getChannelData(i));
        
        const totalFrames = audioBuff.length;
        const interleavedResult = new Float32Array(totalFrames * numChannels);
        for (let frame = 0; frame < totalFrames; frame++) {
            for (let ch = 0; ch < numChannels; ch++) {
                interleavedResult[frame * numChannels + ch] = channels[ch][frame];
            }
        }

        const dataLengthBytes = interleavedResult.length * (bitDepth / 8);
        const wavHeaderLength = 44;
        const totalFileLength = wavHeaderLength + dataLengthBytes;

        const wavArrayBuffer = new ArrayBuffer(totalFileLength);
        const view = new DataView(wavArrayBuffer);

        function writeStringToArrayView(dataView, offset, str) {
            for (let i = 0; i < str.length; i++) dataView.setUint8(offset + i, str.charCodeAt(i));
        }

        writeStringToArrayView(view, 0, 'RIFF');
        view.setUint32(4, wavHeaderLength - 8 + dataLengthBytes, true);
        writeStringToArrayView(view, 8, 'WAVE');
        writeStringToArrayView(view, 12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, format, true);
        view.setUint16(22, numChannels, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * numChannels * (bitDepth / 8), true);
        view.setUint16(32, numChannels * (bitDepth / 8), true);
        view.setUint16(34, bitDepth, true);
        writeStringToArrayView(view, 36, 'data');
        view.setUint32(40, dataLengthBytes, true);

        let byteOffset = wavHeaderLength;
        if (format === 1) {
            for (let i = 0; i < interleavedResult.length; i++, byteOffset += 2) {
                let s = Math.max(-1, Math.min(1, interleavedResult[i]));
                view.setInt16(byteOffset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
            }
        } else {
            for (let i = 0; i < interleavedResult.length; i++, byteOffset += 4) {
                view.setFloat32(byteOffset, interleavedResult[i], true);
            }
        }
        return new Blob([view], { type: 'audio/wav' });
    }

    if(downloadMasterBtnEl){
        downloadMasterBtnEl.disabled = true;
        downloadMasterBtnEl.addEventListener('click', () => {
            if(masterRecordedAudioBuffer){
                const wavBlob = audioBufferToWavBlob(masterRecordedAudioBuffer, { float32: false });
                const downloadUrl = URL.createObjectURL(wavBlob);
                const anchor = document.createElement('a');
                anchor.style.display = 'none';
                anchor.href = downloadUrl;
                const dateString = new Date().toISOString().slice(0,19).replace(/-/g,'').replace(/:/g,'').replace('T','_');
                anchor.download = `SUSPIRA_Master_${dateString}.wav`;
                document.body.appendChild(anchor);
                anchor.click();
                document.body.removeChild(anchor);
                URL.revokeObjectURL(downloadUrl);
            } else {
                alert("Graba algo en el Master para descargarlo.");
            }
        });
    }
    
    function triggerSampleOn(loopIndex) {
        if (!mainRecorderAudioBuffer || activeSamplers[loopIndex]) return;

        const selection = sampleSelections[loopIndex];
        if (selection.start >= selection.end) return;
        
        const isReversed = loopReverseSwitches[loopIndex] ? loopReverseSwitches[loopIndex].checked : false;
        const currentSpeed = loopSpeedControls[loopIndex] ? parseFloat(loopSpeedControls[loopIndex].value) : 1;
        const useFlexPitch = loopFlexPitchSwitches[loopIndex] ? loopFlexPitchSwitches[loopIndex].checked : false;

        let segment = extractAudioBufferSegment(mainRecorderAudioBuffer, selection.start, selection.end, audioContext);
        if (!segment) return;

        if (isReversed) {
            segment = createReversedAudioBuffer(segment);
            if (!segment) return;
        }

        let bufferToPlay = segment;
        let finalPlaybackRate = currentSpeed;

        if (useFlexPitch && currentSpeed !== 1.0 && typeof SoundTouch !== 'undefined' && typeof SimpleFilter !== 'undefined') {
            let newProcessedBuffer = processAudioWithSoundTouch(segment, currentSpeed);
            if (newProcessedBuffer && newProcessedBuffer.duration > 0.001) {
                bufferToPlay = newProcessedBuffer;
                finalPlaybackRate = 1.0;
            }
        }
        
        if (!bufferToPlay || bufferToPlay.duration <= 0.001) {
            return;
        }

        const source = audioContext.createBufferSource();
        source.buffer = bufferToPlay;
        source.playbackRate.value = finalPlaybackRate;
        
        const gainNode = audioContext.createGain();
        source.connect(gainNode);
        gainNode.connect(loopVolumeGains[loopIndex]);

        const now = audioContext.currentTime;
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(1, now + 0.01);

        source.start(now);
        
        source.onended = () => {
            if (activeSamplers[loopIndex] && activeSamplers[loopIndex].source === source) {
                activeSamplers[loopIndex] = null;
            }
        };

        activeSamplers[loopIndex] = { source, gain: gainNode };
    }

    function triggerSampleOff(loopIndex) {
        if (!activeSamplers[loopIndex]) return;

        const { source, gain } = activeSamplers[loopIndex];
        const now = audioContext.currentTime;
        const releaseTime = 0.02;

        gain.gain.cancelScheduledValues(now);
        gain.gain.setValueAtTime(gain.gain.value, now);
        gain.gain.linearRampToValueAtTime(0, now + releaseTime);

        try {
          source.stop(now + releaseTime);
        } catch(e) {}
        activeSamplers[loopIndex] = null;
    }
    
    function setupMidi() {
        const midiMapBtn = document.getElementById('midiMapBtn');
        let midiInitialized = false;

        midiMapBtn.addEventListener('click', () => {
            if (!midiInitialized && navigator.requestMIDIAccess) {
                navigator.requestMIDIAccess()
                    .then(onMIDISuccess, onMIDIFailure);
                midiInitialized = true;
            }

            isMidiMapping = !isMidiMapping;
            document.body.classList.toggle('midi-mapping-active', isMidiMapping);
            midiMapBtn.classList.toggle('active', isMidiMapping);

            if (isMidiMapping) {
                console.log("MAPEADO MIDI ACTIVADO: Haz clic en un control y mueve un knob/fader/botón en tu controlador.");
            } else {
                console.log("MAPEADO MIDI DESACTIVADO.");
                if (elementToMap) {
                    elementToMap.classList.remove('control-listening');
                    elementToMap = null;
                }
            }
        });

        document.querySelectorAll('.mappable').forEach(el => {
            el.addEventListener('click', (e) => {
                if (isMidiMapping) {
                    e.preventDefault();
                    e.stopPropagation();

                    if (elementToMap && elementToMap.element) elementToMap.element.classList.remove('control-listening');
                    if(elementToMap && elementToMap.classList) elementToMap.classList.remove('control-listening');

                    elementToMap = el;
                    elementToMap.classList.add('control-listening');
                    console.log(`Escuchando MIDI para el control: ${el.id || el.dataset.paramId}`);
                }
            });
        });
        
        if (!navigator.requestMIDIAccess) {
            console.warn("Web MIDI API no está soportada en este navegador.");
        }
    }

    function onMIDISuccess(midiAccess) {
        console.log("Acceso MIDI concedido.");
        for (let input of midiAccess.inputs.values()) {
            input.onmidimessage = onMidiMessage;
            console.log(`Escuchando en el dispositivo MIDI: ${input.name}`);
        }
    }

    function onMIDIFailure() {
        console.error("No se pudo acceder a los dispositivos MIDI.");
        alert("No se pudo acceder a los dispositivos MIDI. Por favor, revisa la configuración de este sitio en tu navegador (haz clic en el candado en la barra de direcciones) y asegúrate de que el permiso para 'Dispositivos MIDI' esté activado. Luego, recarga la página.");
    }

    function onMidiMessage(event) {
        const command = event.data[0] & 0xf0;
        const number = event.data[1];
        const value = event.data.length > 2 ? event.data[2] : 0;

        if (isMidiMapping && elementToMap) {
            let key;
            let type;
            if (command === 0xB0) {
                key = `cc_${number}`;
                type = 'CC';
            } else if (command === 0x90) {
                key = `note_${number}`;
                type = 'Note';
            } else {
                return;
            }

            midiMap[key] = { id: elementToMap.id };
            console.log(`Control MIDI ${type} #${number} mapeado a ${elementToMap.id}`);
            
            if(elementToMap.classList) elementToMap.classList.remove('control-listening');
            if(elementToMap.element) elementToMap.element.classList.remove('control-listening');
            elementToMap = null;
            isMidiMapping = false;
            document.body.classList.remove('midi-mapping-active');
            document.getElementById('midiMapBtn').classList.remove('active');
            return;
        }

        let key;
        if (command === 0xB0) key = `cc_${number}`;
        else if (command === 0x90 || command === 0x80) key = `note_${number}`;
        else return;

        const mapping = midiMap[key];
        if (!mapping) return;

        const targetElement = document.getElementById(mapping.id);
        if (!targetElement) return;

        if (command === 0xB0) {
            const normalizedValue = value / 127.0;

            if (targetElement.classList.contains('dial')) {
                const min = parseFloat(targetElement.dataset.min);
                const max = parseFloat(targetElement.dataset.max);
                const newValue = min + normalizedValue * (max - min);
                localUpdateDialParamProgrammatic(targetElement, newValue);
            } else if (targetElement.type === 'range') {
                const min = parseFloat(targetElement.min);
                const max = parseFloat(targetElement.max);
                const newValue = min + normalizedValue * (max - min);
                localUpdateRangeParamProgrammatic(targetElement, newValue);
            } else {
                const lastValue = lastCCValues[number] || 0;
                const threshold = 64;
                if (value >= threshold && lastValue < threshold) {
                    if (targetElement.id.startsWith('loopCanvas')) {
                         const sampleIndex = parseInt(targetElement.id.replace('loopCanvas', '')) - 1;
                         if (!isNaN(sampleIndex)) triggerSampleOn(sampleIndex);
                    } else if (targetElement.tagName === 'BUTTON') {
                        targetElement.click();
                    }
                }
                lastCCValues[number] = value;
            }
        } else if (command === 0x90 && value > 0) {
             if (targetElement.id.startsWith('loopCanvas')) {
                const sampleIndex = parseInt(targetElement.id.replace('loopCanvas', '')) - 1;
                if (!isNaN(sampleIndex)) triggerSampleOn(sampleIndex);
             } else if (targetElement.tagName === 'BUTTON') {
                targetElement.click();
             }
        } else if (command === 0x80 || (command === 0x90 && value === 0)) {
             if (targetElement.id.startsWith('loopCanvas')) {
                const sampleIndex = parseInt(targetElement.id.replace('loopCanvas', '')) - 1;
                if (!isNaN(sampleIndex)) triggerSampleOff(sampleIndex);
             }
        }
    }
    
    function setupGlobalKeyListeners(){
        document.addEventListener('keydown',(e)=>{
            const activeEl = document.activeElement;
            if(e.repeat || (activeEl && (activeEl.tagName==='INPUT'||activeEl.tagName==='SELECT'||activeEl.tagName==='TEXTAREA'||activeEl.isContentEditable))) return;
            
            const key = e.key;
            
            if(e.code==='Space' && playPauseBtn){
                e.preventDefault();
                playPauseBtn.click();
                return;
            }

            if (key.toUpperCase() === 'P') {
                stopAutomationRecording();
                e.preventDefault();
            }
            
            switch(key.toUpperCase()){
                case'R': if(recordBtn&&!recordBtn.disabled)recordBtn.click();break;
                case'T': if(stopRecBtn&&!stopRecBtn.disabled)stopRecBtn.click();break;
                case'G': if(granulatorPlayToggleBtn&&!granulatorPlayToggleBtn.disabled)toggleGranulator();break;
                case'Y': if(appendRecBtn) appendRecBtn.click();break;
                case'U': if(overdubNowBtn)overdubNowBtn.click();break;
                case'A': if(loopPlayPauseBtns[0]&&!loopPlayPauseBtns[0].disabled)loopPlayPauseBtns[0].click();break;
                case'S': if(loopPlayPauseBtns[1]&&!loopPlayPauseBtns[1].disabled)loopPlayPauseBtns[1].click();break;
                case'D': if(loopPlayPauseBtns[2]&&!loopPlayPauseBtns[2].disabled)loopPlayPauseBtns[2].click();break;
                case'M': if(recordMasterBtnEl&&!recordMasterBtnEl.disabled)recordMasterBtnEl.click();break;
            }

            switch(key) {
                case'1': if(stateButtons[0]&&!stateButtons[0].disabled)stateButtons[0].dispatchEvent(new MouseEvent('mouseup', {bubbles:true, button:0})); break;
                case'2': if(stateButtons[1]&&!stateButtons[1].disabled)stateButtons[1].dispatchEvent(new MouseEvent('mouseup', {bubbles:true, button:0})); break;
                case'3': if(stateButtons[2]&&!stateButtons[2].disabled)stateButtons[2].dispatchEvent(new MouseEvent('mouseup', {bubbles:true, button:0})); break;
                case'4': if(stateButtons[3]&&!stateButtons[3].disabled)stateButtons[3].dispatchEvent(new MouseEvent('mouseup', {bubbles:true, button:0})); break;
                case'5': triggerSampleOn(0); break;
                case'6': triggerSampleOn(1); break;
                case'7': triggerSampleOn(2); break;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            const activeEl = document.activeElement;
            if (activeEl && (activeEl.tagName==='INPUT'||activeEl.tagName==='SELECT'||activeEl.tagName==='TEXTAREA'||activeEl.isContentEditable)) return;

            switch(e.key){
                case '5': triggerSampleOff(0); break;
                case '6': triggerSampleOff(1); break;
                case '7': triggerSampleOff(2); break;
            }
        });
    }

    function setupSpectralSynthEventListeners() {
        if (!spectrumCanvas) return;

        if (spectralSynthDrawModeSwitch) {
            spectralSynthDrawModeSwitch.addEventListener('change', (e) => {
                isDrawModeActive = e.target.checked;
                if (!isDrawModeActive) {
                    stopSpectralSynth();
                }
            });
        }
        
        if (undoDrawingBtn) {
            undoDrawingBtn.addEventListener('click', () => {
                if(drawnPaths.length > 1) {
                    drawnPaths.pop();
                } else if (drawnPaths.length === 1 && drawnPaths[0].length > 0) {
                    drawnPaths = [[]];
                }
                
                if (pathPlaybackRequestID !== null) {
                    stopPathPlayback();
                    if (drawnPaths.flat().length > 0) {
                        startPathPlayback();
                    }
                }
            });
        }
        
        spectrumCanvas.addEventListener('mouseenter', (e) => {
             if (spectralSynthPowerSwitch && spectralSynthPowerSwitch.checked && mainRecorderAudioBuffer && isDrawModeActive) {
                if(audioContext.state === 'suspended') audioContext.resume();
                
                if (!isDrawingPath && pathPlaybackRequestID === null) {
                     const rect = spectrumCanvas.getBoundingClientRect();
                     const scaleX = spectrumCanvas.width / rect.width;
                     const scaleY = spectrumCanvas.height / rect.height;
                     const x = ((e.clientX - rect.left) * scaleX) / spectrumCanvas.width;
                     const y = ((e.clientY - rect.top) * scaleY) / spectrumCanvas.height;
                     lastSpectralCoords = { x: Math.max(0, Math.min(x, 1)), y: Math.max(0, Math.min(y, 1)), active: true };
                     startSpectralSynth();
                }
             }
        });
        
        if(spectralSynthPowerSwitch) {
            spectralSynthPowerSwitch.disabled = !mainRecorderAudioBuffer;
            spectralSynthPowerSwitch.addEventListener('change', (e) => {
                const hasDrawing = drawnPaths.flat().length > 0;
                if (e.target.checked) {
                    if (hasDrawing) {
                        startPathPlayback();
                    }
                } else {
                    stopSpectralSynth();
                    stopPathPlayback();
                }
            });
        }

        if(clearDrawingBtn) {
            clearDrawingBtn.addEventListener('click', () => {
                drawnPaths = [[]];
                stopPathPlayback();
                
                const isMouseOverCanvas = spectrumCanvas.matches(':hover');
                if (isMouseOverCanvas && spectralSynthPowerSwitch.checked && !isSpectralSynthActive && isDrawModeActive) {
                    startSpectralSynth();
                } else if (!isMouseOverCanvas && isSpectralSynthActive) {
                    stopSpectralSynth();
                }
            });
        }
    }

    function scheduleNextSpectralGrain() {
        if (!isSpectralSynthActive || !mainRecorderAudioBuffer || !lastSpectralCoords.active || pathPlaybackRequestID !== null || isDrawingPath) {
            return;
        }

        if (currentSpectralSynthSource) {
            try { currentSpectralSynthSource.stop(0); } catch(e) {}
            currentSpectralSynthSource = null;
        }
        
        const grainLength = 0.1; 
        const bufferDuration = mainRecorderAudioBuffer.duration;

        let startPosition = lastSpectralCoords.x * (bufferDuration - grainLength);
        startPosition = Math.max(0, Math.min(startPosition, bufferDuration - grainLength));

        const source = audioContext.createBufferSource();
        source.buffer = mainRecorderAudioBuffer;

        const envelope = audioContext.createGain();
        source.connect(envelope);
        envelope.connect(spectralSynthInputGain);

        const now = audioContext.currentTime;
        const fadeIn = grainLength * 0.5;
        
        envelope.gain.setValueAtTime(0, now);
        envelope.gain.linearRampToValueAtTime(1, now + fadeIn);
        envelope.gain.linearRampToValueAtTime(0, now + grainLength);
        
        source.start(now, startPosition, grainLength);
        currentSpectralSynthSource = source;
        source.onended = () => {
            if (currentSpectralSynthSource === source) currentSpectralSynthSource = null;
            try { source.disconnect(); envelope.disconnect(); } catch(e){}
        };
        
        const finalDelay = 50;
        spectralSynthTimeoutId = setTimeout(scheduleNextSpectralGrain, finalDelay);
    }

    function startPathPlayback() {
        if (pathPlaybackRequestID || !spectralSynthPowerSwitch.checked) return;
        
        stopSpectralSynth();
        pathPlaybackIndex = 0;

        function playbackLoop() {
            if (!spectralSynthPowerSwitch.checked) { 
                stopPathPlayback();
                return; 
            }
            const currentPath = drawnPaths.flat();
            if (currentPath.length < 1) { 
                stopPathPlayback();
                return; 
            }

            const currentPoint = currentPath[pathPlaybackIndex];
            lastSpectralCoords = { x: currentPoint.x, y: currentPoint.y, active: true };
            updateSpectralSynthFilters();
            
            playGrainAtCurrentPathPosition();

            pathPlaybackIndex++;
            if (pathPlaybackIndex >= currentPath.length) {
                pathPlaybackIndex = 0;
            }
            
            const finalDelay = 50;
            pathPlaybackRequestID = setTimeout(playbackLoop, finalDelay);
        }
        playbackLoop();
    }

    function stopPathPlayback() {
        if (pathPlaybackRequestID) {
            clearTimeout(pathPlaybackRequestID);
            pathPlaybackRequestID = null;
        }
    }

    function playGrainAtCurrentPathPosition() {
        if (!mainRecorderAudioBuffer || !lastSpectralCoords.active) return;
        
        if (currentSpectralSynthSource) {
            try { currentSpectralSynthSource.stop(0); } catch(e) {}
            currentSpectralSynthSource = null;
        }

        const grainLength = 0.1;
        const bufferDuration = mainRecorderAudioBuffer.duration;
        let startPosition = lastSpectralCoords.x * (bufferDuration - grainLength);
        startPosition = Math.max(0, Math.min(startPosition, bufferDuration - grainLength));

        const source = audioContext.createBufferSource();
        source.buffer = mainRecorderAudioBuffer;
        const envelope = audioContext.createGain();
        source.connect(envelope);
        envelope.connect(spectralSynthInputGain);

        const now = audioContext.currentTime;
        const fadeIn = grainLength * 0.5;
        
        envelope.gain.setValueAtTime(0, now);
        envelope.gain.linearRampToValueAtTime(1, now + fadeIn);
        envelope.gain.linearRampToValueAtTime(0, now + grainLength);
        
        source.start(now, startPosition, grainLength);
        currentSpectralSynthSource = source;
        source.onended = () => {
            if (currentSpectralSynthSource === source) currentSpectralSynthSource = null;
            try { source.disconnect(); envelope.disconnect(); } catch(e){}
        };
    }

    function updateSpectralSynthFilters() {
        if (!lastSpectralCoords.active) return;
        const centerFreqNormalized = 1 - lastSpectralCoords.y;
        const brushSizeNormalized = 0.1; 

        spectralFilterBank.forEach((channel, i) => {
            const filterPosNormalized = i / (SPECTRAL_FILTER_COUNT - 1);
            const distance = Math.abs(filterPosNormalized - centerFreqNormalized);
            
            let gainValue = 0;
            if (distance < brushSizeNormalized) {
                gainValue = 1.0 - (distance / brushSizeNormalized);
                gainValue = Math.pow(gainValue, 2);
            }
            
            channel.gainNode.gain.setTargetAtTime(gainValue, audioContext.currentTime, 0.015);
        });
    }
    
    function startSpectralSynth() {
        if (isSpectralSynthActive) return;
        isSpectralSynthActive = true;
        updateSpectralSynthFilters();
        scheduleNextSpectralGrain();
    }

    function stopSpectralSynth() {
        if (!isSpectralSynthActive) return;
        isSpectralSynthActive = false;
        if (spectralSynthTimeoutId) {
            clearTimeout(spectralSynthTimeoutId);
            spectralSynthTimeoutId = null;
        }
        spectralFilterBank.forEach(channel => {
            channel.gainNode.gain.cancelScheduledValues(audioContext.currentTime);
            channel.gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.2);
        });
    }

    function setupAutomationMemories() {
        memButtons.forEach((button, index) => {
            if (!button) return;
            button.addEventListener('click', () => {
                const now = performance.now();
                const DOUBLE_CLICK_THRESHOLD = 400; // ms

                if (now - memBtnLastClickTime[index] < DOUBLE_CLICK_THRESHOLD) {
                    if (automationMemories[index]) {
                        stopAutomationPlayback(index);
                        automationMemories[index] = null;
                        console.log(`Automation memory in slot ${index + 1} deleted.`);
                        updateAutomationBtnUI();
                    }
                    memBtnLastClickTime[index] = 0;
                } else {
                    memBtnLastClickTime[index] = now;
                    const state = automationPlaybackStates[index];
                    if (state.isPlaying) {
                        stopAutomationPlayback(index);
                    } else if (automationMemories[index]) {
                        playAutomation(index);
                    } else {
                        armAutomationSlot(index);
                    }
                }
            });
        });
    }

    function updateAutomationBtnUI() {
        memButtons.forEach((btn, i) => {
            if (!btn) return;
            btn.classList.remove('automation-armed', 'automation-has-data', 'automation-playing');
            btn.style.animation = '';

            const state = automationPlaybackStates[i];

            if (state.isPlaying) {
                btn.classList.add('automation-playing');
            } else if (armedAutomationSlot === i) {
                btn.classList.add('automation-armed');
                btn.style.animation = 'blink-red 1s infinite';
            } else if (automationMemories[i]) {
                btn.classList.add('automation-has-data');
            }
        });
    }

    function armAutomationSlot(index) {
        if (isRecordingAutomation) return;
        
        automationPlaybackStates.forEach((state, i) => {
            if(state.isPlaying) stopAutomationPlayback(i);
        });

        if (armedAutomationSlot === index) {
            armedAutomationSlot = -1;
        } else {
            armedAutomationSlot = index;
            automationMemories[index] = null; 
        }
        updateAutomationBtnUI();
    }

    function startAutomationRecording(controlId, value) {
        isRecordingAutomation = true;
        automationRecordingStartTime = performance.now();
        tempAutomationSequence = [];
        console.log(`Automation recording started for slot ${armedAutomationSlot + 1}`);
        
        recordAutomationEvent(controlId, value, true);
        updateAutomationBtnUI();
    }
    
    window.recordAutomationEvent = function(controlId, value, isFirstEvent = false) {
        if (armedAutomationSlot !== -1 && !isRecordingAutomation) {
            startAutomationRecording(controlId, value);
            return;
        }

        if (isRecordingAutomation) {
            let timestamp = isFirstEvent ? 0 : performance.now() - automationRecordingStartTime;
            tempAutomationSequence.push({ id: controlId, value: value, time: timestamp });
        }
    }

    function stopAutomationRecording() {
        if (!isRecordingAutomation) return;

        isRecordingAutomation = false;
        if (armedAutomationSlot !== -1 && tempAutomationSequence.length > 0) {
            automationMemories[armedAutomationSlot] = tempAutomationSequence;
            console.log(`Automation recorded to slot ${armedAutomationSlot + 1} with ${tempAutomationSequence.length} events.`);
        } else if (armedAutomationSlot !== -1) {
             automationMemories[armedAutomationSlot] = null;
             console.log(`Automation recording for slot ${armedAutomationSlot + 1} cancelled (no events).`);
        }
        
        armedAutomationSlot = -1;
        tempAutomationSequence = [];
        updateAutomationBtnUI();
    }

    function playAutomation(index) {
        const sequence = automationMemories[index];
        if (!sequence || sequence.length === 0 || automationPlaybackStates[index].isPlaying) return;

        automationPlaybackStates.forEach((state, i) => {
            if(state.isPlaying) stopAutomationPlayback(i);
        });
        
        const state = automationPlaybackStates[index];
        state.isPlaying = true;
        state.eventIndex = 0;
        state.startTime = performance.now();
        console.log(`Playing automation from slot ${index + 1}`);
        updateAutomationBtnUI();

        function playbackLoop() {
            if (!state.isPlaying) return;

            const elapsedTime = performance.now() - state.startTime;
            
            while (state.eventIndex < sequence.length && sequence[state.eventIndex].time <= elapsedTime) {
                const event = sequence[state.eventIndex];
                updateParameterProgrammatically(event.id, event.value);
                state.eventIndex++;
            }

            if (state.eventIndex >= sequence.length) {
                const totalDuration = sequence[sequence.length - 1].time;
                state.startTime = performance.now() - (elapsedTime - totalDuration);
                state.eventIndex = 0;
            }

            state.loopId = requestAnimationFrame(playbackLoop);
        }
        state.loopId = requestAnimationFrame(playbackLoop);
    }

    function stopAutomationPlayback(index) {
        const state = automationPlaybackStates[index];
        if (!state.isPlaying) return;

        cancelAnimationFrame(state.loopId);
        state.isPlaying = false;
        state.loopId = null;
        console.log(`Stopped automation playback for slot ${index + 1}`);
        updateAutomationBtnUI();
    }

})();
</script>
</body>
</html>
